!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACCEPT	StandardValues.scala	/^  val ACCEPT = "Accept"$/;"	V
ACCEPTED	StandardValues.scala	/^  val ACCEPTED = 202$/;"	V
ACCEPT_CHARSET	StandardValues.scala	/^  val ACCEPT_CHARSET = "Accept-Charset"$/;"	V
ACCEPT_ENCODING	StandardValues.scala	/^  val ACCEPT_ENCODING = "Accept-Encoding"$/;"	V
ACCEPT_LANGUAGE	StandardValues.scala	/^  val ACCEPT_LANGUAGE = "Accept-Language"$/;"	V
ACCEPT_RANGES	StandardValues.scala	/^  val ACCEPT_RANGES = "Accept-Ranges"$/;"	V
ACCESS_CONTROL_ALLOW_CREDENTIALS	StandardValues.scala	/^  val ACCESS_CONTROL_ALLOW_CREDENTIALS = "Access-Control-Allow-Credentials"$/;"	V
ACCESS_CONTROL_ALLOW_HEADERS	StandardValues.scala	/^  val ACCESS_CONTROL_ALLOW_HEADERS = "Access-Control-Allow-Headers"$/;"	V
ACCESS_CONTROL_ALLOW_METHODS	StandardValues.scala	/^  val ACCESS_CONTROL_ALLOW_METHODS = "Access-Control-Allow-Methods"$/;"	V
ACCESS_CONTROL_ALLOW_ORIGIN	StandardValues.scala	/^  val ACCESS_CONTROL_ALLOW_ORIGIN = "Access-Control-Allow-Origin"$/;"	V
ACCESS_CONTROL_EXPOSE_HEADERS	StandardValues.scala	/^  val ACCESS_CONTROL_EXPOSE_HEADERS = "Access-Control-Expose-Headers"$/;"	V
ACCESS_CONTROL_MAX_AGE	StandardValues.scala	/^  val ACCESS_CONTROL_MAX_AGE = "Access-Control-Max-Age"$/;"	V
ACCESS_CONTROL_REQUEST_HEADERS	StandardValues.scala	/^  val ACCESS_CONTROL_REQUEST_HEADERS = "Access-Control-Request-Headers"$/;"	V
ACCESS_CONTROL_REQUEST_METHOD	StandardValues.scala	/^  val ACCESS_CONTROL_REQUEST_METHOD = "Access-Control-Request-Method"$/;"	V
AGE	StandardValues.scala	/^  val AGE = "Age"$/;"	V
ALLOW	StandardValues.scala	/^  val ALLOW = "Allow"$/;"	V
AUTHORIZATION	StandardValues.scala	/^  val AUTHORIZATION = "Authorization"$/;"	V
AUTH_CANCEL	OpenIDError.scala	/^  object AUTH_CANCEL extends OpenIDError("auth_cancel", """OpenID authentication was cancelled.""")$/;"	o
AUTH_ERROR	OpenIDError.scala	/^  object AUTH_ERROR extends OpenIDError("auth_error", """The OpenID server failed to verify the OpenID response.""")$/;"	o
AbsolutePath	ExternalAssets.scala	/^  val AbsolutePath = """^(\/|[a-zA-Z]:\\\\).*""".r$/;"	V
AcceptExtractors	RequestExtractors.scala	/^trait AcceptExtractors {$/;"	t
Accepted	Results.scala	/^  val Accepted = new Status(ACCEPTED)$/;"	V
Accepting	RequestExtractors.scala	/^case class Accepting(val mimeType: String) {$/;"	r
Accepts	RequestExtractors.scala	/^  object Accepts {$/;"	o
AcceptsMp3	RequestExtractors.scala	/^ * val AcceptsMp3 = Accepting("audio\/mp3")$/;"	V
Action	Action.scala	/^object Action extends ActionBuilder$/;"	o
Action	Action.scala	/^trait Action[A] extends EssentialAction {$/;"	t
ActionBuilder	Action.scala	/^trait ActionBuilder {$/;"	t
Akka	Akka.scala	/^object Akka {$/;"	o
AkkaPlugin	Akka.scala	/^class AkkaPlugin(app: Application) extends Plugin {$/;"	c
AliasesDictionary	Anorm.scala	/^  private lazy val AliasesDictionary: Map[String, Any] = metaData.ms.flatMap(_.column.alias.map(_.toUpperCase())).zip(data).toMap$/;"	V
AnyContentAsFormUrlEncoded	ContentTypes.scala	/^case class AnyContentAsFormUrlEncoded(data: Map[String, Seq[String]]) extends AnyContent$/;"	r
AnyContentAsJson	ContentTypes.scala	/^case class AnyContentAsJson(json: JsValue) extends AnyContent$/;"	r
AnyContentAsMultipartFormData	ContentTypes.scala	/^case class AnyContentAsMultipartFormData(mdf: MultipartFormData[TemporaryFile]) extends AnyContent$/;"	r
AnyContentAsRaw	ContentTypes.scala	/^case class AnyContentAsRaw(raw: RawBuffer) extends AnyContent$/;"	r
AnyContentAsText	ContentTypes.scala	/^case class AnyContentAsText(txt: String) extends AnyContent$/;"	r
AnyContentAsXml	ContentTypes.scala	/^case class AnyContentAsXml(xml: NodeSeq) extends AnyContent$/;"	r
Appendable	FakeRuntime.scala	/^  trait Appendable[T] {$/;"	t
Appendable	ScalaTemplate.scala	/^trait Appendable[T] {$/;"	t
Application	Application.scala	/^trait Application {$/;"	t
ApplicationProvider	ApplicationProvider.scala	/^trait ApplicationProvider {$/;"	t
AssetCompilationException	PlayExceptions.scala	/^  case class AssetCompilationException(source: Option[File], message: String, atLine: Option[Int], column: Option[Int]) extends PlayException.ExceptionSource($/;"	r
Assets	Assets.scala	/^object Assets extends AssetsBuilder$/;"	o
AssetsBuilder	Assets.scala	/^class AssetsBuilder extends Controller {$/;"	c
AssetsCompiler	PlayAssetsCompiler.scala	/^  def AssetsCompiler(name: String,$/;"	m
Async	Results.scala	/^  def Async(promise: Future[Result]) = AsyncResult(promise)$/;"	m
AsyncResult	Results.scala	/^case class AsyncResult(result: Future[Result]) extends Result with WithHeaders[AsyncResult] {$/;"	r
Authenticated	Security.scala	/^  def Authenticated(action: String => EssentialAction): EssentialAction = Authenticated($/;"	m
AxAttribute	OpenID.scala	/^    val AxAttribute = """^openid\\.([^.]+\\.value\\.([^.]+(\\.\\d+)?))$""".r$/;"	V
BAD_GATEWAY	StandardValues.scala	/^  val BAD_GATEWAY = 502$/;"	V
BAD_REQUEST	StandardValues.scala	/^  val BAD_REQUEST = 400$/;"	V
BAD_RESPONSE	OpenIDError.scala	/^  object BAD_RESPONSE extends OpenIDError("bad_response", """Bad response from the OpenID server.""")$/;"	o
BINARY	StandardValues.scala	/^  val BINARY = "application\/octet-stream"$/;"	V
BINARY	StandardValues.scala	/^  val BINARY = MimeTypes.BINARY$/;"	V
BODY_CONTENT	Action.scala	/^  type BODY_CONTENT = A$/;"	T
BODY_CONTENT	Results.scala	/^  type BODY_CONTENT = A$/;"	T
BadGateway	Results.scala	/^  val BadGateway = new Status(BAD_GATEWAY)$/;"	V
BadPart	ContentTypes.scala	/^  case class BadPart(headers: Map[String, String]) extends Part$/;"	r
BadRequest	Results.scala	/^  val BadRequest = new Status(BAD_REQUEST)$/;"	V
BaseScalaTemplate	FakeRuntime.scala	/^  case class BaseScalaTemplate[T <: Appendable[T], F <: Format[T]](format: F) {$/;"	r
BaseScalaTemplate	ScalaTemplate.scala	/^  case class BaseScalaTemplate[T <: Appendable[T], F <: Format[T]](format: F) {$/;"	r
BatchSql	Anorm.scala	/^case class BatchSql(sql: SqlQuery, params: Seq[Seq[(String, ParameterValue[_])]]) {$/;"	r
BindersSpec	BindersSpec.scala	/^object BindersSpec extends Specification {$/;"	o
Block	ScalaTemplateCompiler.scala	/^    case class Block(whitespace: String, args: Option[PosString], content: Seq[TemplateTree]) extends ScalaExpPart with Positional$/;"	r
BodyParser	Action.scala	/^object BodyParser {$/;"	o
BodyParser	Action.scala	/^trait BodyParser[+A] extends Function1[RequestHeader, Iteratee[Array[Byte], Either[Result, A]]] {$/;"	t
BodyParsers	ContentTypes.scala	/^object BodyParsers extends BodyParsers$/;"	o
BodyParsers	ContentTypes.scala	/^trait BodyParsers {$/;"	t
BodyParsers.parse._	csrf.scala	/^    import BodyParsers.parse._$/;"	i
BoneCPPlugin	DB.scala	/^class BoneCPPlugin(app: Application) extends DBPlugin {$/;"	c
Broadcaster	Concurrent.scala	/^  trait Broadcaster {$/;"	t
BufferSize	PlayJvm.scala	/^  final val BufferSize = 8192$/;"	V
C1	JsonExtensionSpec.scala	/^case class C1[A](id: Id[A], name: String)$/;"	r
CACHE_CONTROL	StandardValues.scala	/^  val CACHE_CONTROL = "Cache-Control"$/;"	V
CONFLICT	StandardValues.scala	/^  val CONFLICT = 409$/;"	V
CONNECTION	StandardValues.scala	/^  val CONNECTION = "Connection"$/;"	V
CONTENT_DISPOSITION	StandardValues.scala	/^  val CONTENT_DISPOSITION = "Content-Disposition"$/;"	V
CONTENT_ENCODING	StandardValues.scala	/^  val CONTENT_ENCODING = "Content-Encoding"$/;"	V
CONTENT_LANGUAGE	StandardValues.scala	/^  val CONTENT_LANGUAGE = "Content-Language"$/;"	V
CONTENT_LENGTH	StandardValues.scala	/^  val CONTENT_LENGTH = "Content-Length"$/;"	V
CONTENT_LOCATION	StandardValues.scala	/^  val CONTENT_LOCATION = "Content-Location"$/;"	V
CONTENT_MD5	StandardValues.scala	/^  val CONTENT_MD5 = "Content-MD5"$/;"	V
CONTENT_RANGE	StandardValues.scala	/^  val CONTENT_RANGE = "Content-Range"$/;"	V
CONTENT_TRANSFER_ENCODING	StandardValues.scala	/^  val CONTENT_TRANSFER_ENCODING = "Content-Transfer-Encoding"$/;"	V
CONTENT_TYPE	StandardValues.scala	/^  val CONTENT_TYPE = "Content-Type"$/;"	V
CONTINUE	StandardValues.scala	/^  val CONTINUE = 100$/;"	V
COOKIE	StandardValues.scala	/^  val COOKIE = "Cookie"$/;"	V
COOKIE_NAME	Http.scala	/^    def COOKIE_NAME: String$/;"	m
COOKIE_NAME	Http.scala	/^    val COOKIE_NAME = Play.maybeApplication.flatMap(_.configuration.getString("flash.cookieName")).getOrElse("PLAY_FLASH")$/;"	V
COOKIE_NAME	Http.scala	/^    val COOKIE_NAME = Play.maybeApplication.flatMap(_.configuration.getString("session.cookieName")).getOrElse("PLAY_SESSION")$/;"	V
COOKIE_NAME	csrf.scala	/^      def COOKIE_NAME: Option[String] = c.getString("csrf.cookie.name") \/\/ If None, we search for TOKEN_NAME in play session$/;"	m
CREATED	StandardValues.scala	/^  val CREATED = 201$/;"	V
CREATE_IF_NOT_FOUND	csrf.scala	/^      def CREATE_IF_NOT_FOUND: Boolean = c.getBoolean("csrf.cookie.createIfNotFound").getOrElse(true)$/;"	m
CRLF	ContentTypes.scala	/^            val CRLF = "\\r\\n".getBytes$/;"	V
CRLFCRLF	ContentTypes.scala	/^            val CRLFCRLF = CRLF ++ CRLF$/;"	V
CSRF	csrf.scala	/^  object CSRF {$/;"	o
CSRF._	csrf.scala	/^    import CSRF._$/;"	i
CSRFFilter	csrf.scala	/^  class CSRFFilter(generator: () => CSRF.Token) extends EssentialFilter {$/;"	c
CSRFFilter	csrf.scala	/^  object CSRFFilter {$/;"	o
CSS	StandardValues.scala	/^  def CSS(implicit codec: Codec) = withCharset(MimeTypes.CSS)$/;"	m
CSS	StandardValues.scala	/^  val CSS = "text\/css"$/;"	V
Cache	Cache.scala	/^object Cache {$/;"	o
Cache.seqFormat	PlayCommands.scala	/^import Cache.seqFormat$/;"	i
CacheAPI	Cache.scala	/^trait CacheAPI {$/;"	t
CachePlugin	Cache.scala	/^abstract class CachePlugin extends Plugin {$/;"	a
CacheSpec	CacheSpec.scala	/^object CacheSpec extends Specification {$/;"	o
Cached	Cached.scala	/^case class Cached[A](key: RequestHeader => String, duration: Int)(action: Action[A])(implicit app: Application) extends Action[A] {$/;"	r
Cached	Cached.scala	/^object Cached {$/;"	o
Call	Http.scala	/^  case class Call(method: String, url: String) extends play.mvc.Call {$/;"	r
Car	JsonSpec.scala	/^  case class Car(id: Long, models: Map[String, String])$/;"	r
CarFormat	JsonSpec.scala	/^  implicit val CarFormat = ($/;"	V
CaseInsensitiveOrdered	CaseInstensitiveOrdered.scala	/^object CaseInsensitiveOrdered extends Ordering[String] {$/;"	o
Cat	JsonExtensionSpec.scala	/^case class Cat(name: String)$/;"	r
Channel	Concurrent.scala	/^  trait Channel[E] {$/;"	t
CheckDone	Enumeratee.scala	/^  trait CheckDone[From, To] extends Enumeratee[From, To] {$/;"	t
ChunkedResult	Results.scala	/^case class ChunkedResult[A](header: ResponseHeader, chunks: Iteratee[A, Unit] => _)(implicit val writeable: Writeable[A]) extends PlainResult {$/;"	r
Codec	Results.scala	/^case class Codec(val charset: String)(val encode: String => Array[Byte], val decode: Array[Byte] => String)$/;"	r
Codec	Results.scala	/^object Codec {$/;"	o
Codecs	Codecs.scala	/^object Codecs {$/;"	o
CoffeescriptCompiler	CoffeescriptCompiler.scala	/^object CoffeescriptCompiler {$/;"	o
CoffeescriptCompiler	PlayAssetsCompiler.scala	/^  val CoffeescriptCompiler = AssetsCompiler("coffeescript",$/;"	V
Collections	Collections.scala	/^object Collections {$/;"	o
ColoredLevel	Logger.scala	/^  class ColoredLevel extends ClassicConverter {$/;"	c
Colors	Color.scala	/^object Colors {$/;"	o
Colors	Console.scala	/^object Colors {$/;"	o
Column	Anorm.scala	/^object Column {$/;"	o
Column	Anorm.scala	/^trait Column[A] extends ((Any, MetaDataItem) => MayErr[SqlRequestError, A])$/;"	t
ColumnName	Anorm.scala	/^case class ColumnName(qualified: String, alias: Option[String])$/;"	r
ColumnNotFound	Anorm.scala	/^case class ColumnNotFound(columnName: String, possibilities: List[String]) extends SqlRequestError {$/;"	r
ColumnsDictionary	Anorm.scala	/^  private lazy val ColumnsDictionary: Map[String, Any] = metaData.ms.map(_.column.qualified.toUpperCase()).zip(data).toMap$/;"	V
Comet	Comet.scala	/^object Comet {$/;"	o
CometMessage	Comet.scala	/^  case class CometMessage[A](toJavascriptMessage: A => String)$/;"	r
CometMessage	Comet.scala	/^  object CometMessage {$/;"	o
CommandSupport.{ ClearOnFailure, FailureWall }	PlayCommands.scala	/^import CommandSupport.{ ClearOnFailure, FailureWall }$/;"	i
Comment	Messages.scala	/^    case class Comment(msg: String)$/;"	r
Comment	RoutesCompiler.scala	/^  case class Comment(comment: String)$/;"	r
Comment	ScalaTemplateCompiler.scala	/^    case class Comment(msg: String) extends TemplateTree with Positional$/;"	r
CompilationError	TemplateCompilerSpec.scala	/^  case class CompilationError(message: String, line: Int, column: Int) extends RuntimeException(message)$/;"	r
CompilationException	JavascriptCompiler.scala	/^  case class CompilationException(message: String, jsFile: File, atLine: Option[Int]) extends PlayException.ExceptionSource($/;"	r
CompilationException	PlayExceptions.scala	/^  case class CompilationException(problem: xsbti.Problem) extends PlayException.ExceptionSource($/;"	r
CompilationFailed	PlayLogger.scala	/^  val CompilationFailed = """.*Compilation failed"""$/;"	V
CompileError	PlayLogger.scala	/^  val CompileError = """(?s)(.*\\.scala):(\\d+): (.*)""".r$/;"	V
CompilerHelper	TemplateCompilerSpec.scala	/^  class CompilerHelper(sourceDir: File, generatedDir: File, generatedClasses: File) {$/;"	c
CompilerInstance	ScalaTemplateCompiler.scala	/^      class CompilerInstance {$/;"	c
CompilerInstance	ScalaTemplateCompiler.scala	/^      object CompilerInstance extends CompilerInstance$/;"	o
Concurrent	Concurrent.scala	/^object Concurrent {$/;"	o
ConcurrentSpec	ConcurrentSpec.scala	/^object ConcurrentSpec extends Specification {$/;"	o
Conf	csrf.scala	/^    object Conf {$/;"	o
Conf._	csrf.scala	/^    import Conf._$/;"	i
Configuration	Configuration.scala	/^case class Configuration(underlying: Config) {$/;"	r
Configuration	Configuration.scala	/^object Configuration {$/;"	o
ConfigurationSpec	ConfigurationSpec.scala	/^object ConfigurationSpec extends Specification {$/;"	o
Conflict	Results.scala	/^  val Conflict = new Status(CONFLICT)$/;"	V
Console	Console.scala	/^class Console extends xsbti.AppMain {$/;"	c
Console	Console.scala	/^object Console {$/;"	o
Constraint	Validation.scala	/^case class Constraint[-T](name: Option[String], args: Seq[Any])(f: (T => ValidationResult)) {$/;"	r
Constraint	Validation.scala	/^object Constraint {$/;"	o
ConstraintFormat	JsConstraints.scala	/^trait ConstraintFormat {$/;"	t
ConstraintReads	JsConstraints.scala	/^trait ConstraintReads {$/;"	t
ConstraintWrites	JsConstraints.scala	/^trait ConstraintWrites {$/;"	t
Constraints	Validation.scala	/^object Constraints extends Constraints$/;"	o
Constraints	Validation.scala	/^trait Constraints {$/;"	t
ConsumerKey	OAuth.scala	/^case class ConsumerKey(key: String, secret: String)$/;"	r
Cont	Iteratee.scala	/^  case class Cont[E, +A](k: Input[E] => Iteratee[E, A]) extends Step[E, A]$/;"	r
Cont	Iteratee.scala	/^object Cont {$/;"	o
Content	Content.scala	/^trait Content {$/;"	t
ContentTypeOf	ContentTypeOf.scala	/^case class ContentTypeOf[-A](mimeType: Option[String])$/;"	r
ContentTypeOf	ContentTypeOf.scala	/^object ContentTypeOf extends DefaultContentTypeOfs$/;"	o
ContentTypes	StandardValues.scala	/^object ContentTypes extends ContentTypes$/;"	o
ContentTypes	StandardValues.scala	/^trait ContentTypes {$/;"	t
ContinuousState	PlayCommands.scala	/^      val ContinuousState = AttributeKey[WatchState]("watch state", "Internal: tracks state for continuous execution.")$/;"	V
Controller	Controller.scala	/^trait Controller extends Results with BodyParsers with Status with HeaderNames with ContentTypes with RequestExtractors with Rendering {$/;"	t
Conversions	Conversions.scala	/^object Conversions {$/;"	o
Cookie	Http.scala	/^  case class Cookie(name: String, value: String, maxAge: Option[Int] = None, path: String = "\/", domain: Option[String] = None, secure: Boolean = false, httpOnly: Boolean = true)$/;"	r
CookieBaker	Http.scala	/^  trait CookieBaker[T <: AnyRef] {$/;"	t
Cookies	Http.scala	/^  object Cookies {$/;"	o
Cookies	Http.scala	/^  trait Cookies {$/;"	t
CountryLocale	Messages.scala	/^  private val CountryLocale = """([a-zA-Z]{2})-([a-zA-Z]{2}|[0-9]{3})""".r$/;"	V
Created	Results.scala	/^  val Created = new Status(CREATED)$/;"	V
Crypto	Crypto.scala	/^object Crypto {$/;"	o
CryptoSpec	CryptoSpec.scala	/^object CryptoSpec extends Specification {$/;"	o
DATE	StandardValues.scala	/^  val DATE = "Date"$/;"	V
DB	DB.scala	/^object DB {$/;"	o
DBApi	DB.scala	/^trait DBApi {$/;"	t
DBPlugin	DB.scala	/^trait DBPlugin extends Plugin {$/;"	t
DEFAULT_MAX_TEXT_LENGTH	ContentTypes.scala	/^    lazy val DEFAULT_MAX_TEXT_LENGTH: Int = Play.maybeApplication.flatMap { app =>$/;"	V
DELETE	Helpers.scala	/^  val DELETE = "DELETE"$/;"	V
DOWNS	Evolutions.scala	/^    val DOWNS = "DOWNS"$/;"	V
DataPart	ContentTypes.scala	/^  case class DataPart(key: String, value: String) extends Part$/;"	r
DateTime	Task.scala	/^  type DateTime = play.data.format.Formats.DateTime @field$/;"	T
Def	ScalaTemplateCompiler.scala	/^    case class Def(name: PosString, params: PosString, code: Simple) extends Positional$/;"	r
DefDef	ScalaTemplateCompiler.scala	/^        type DefDef = PresentationCompiler.global.DefDef$/;"	T
Default	Default.scala	/^object Default extends Controller {$/;"	o
Default	FakeRuntime.scala	/^    case class Default(default: Any) {$/;"	r
Default	ScalaTemplate.scala	/^    case class Default(default: Any) {$/;"	r
DefaultApplication	Application.scala	/^class DefaultApplication($/;"	c
DefaultContentTypeOfs	ContentTypeOf.scala	/^trait DefaultContentTypeOfs {$/;"	t
DefaultDateReads	Reads.scala	/^  implicit val DefaultDateReads = dateReads("yyyy-MM-dd")$/;"	V
DefaultFormat	Format.scala	/^trait DefaultFormat {$/;"	t
DefaultGlobal	GlobalSettings.scala	/^object DefaultGlobal extends GlobalSettings$/;"	o
DefaultJodaDateReads	Reads.scala	/^  implicit val DefaultJodaDateReads = jodaDateReads("yyyy-MM-dd")$/;"	V
DefaultJodaLocalDateReads	Reads.scala	/^  implicit val DefaultJodaLocalDateReads = jodaLocalDateReads("")$/;"	V
DefaultReads	Reads.scala	/^trait DefaultReads {$/;"	t
DefaultRequestBody	JavaParsers.scala	/^  case class DefaultRequestBody($/;"	r
DefaultSqlDateReads	Reads.scala	/^  implicit val DefaultSqlDateReads = sqlDateReads("yyyy-MM-dd")$/;"	V
DefaultWriteables	Writeable.scala	/^trait DefaultWriteables extends LowPriorityWriteables {$/;"	t
DefaultWrites	Writes.scala	/^trait DefaultWrites {$/;"	t
DevSettings	ApplicationProvider.scala	/^trait DevSettings {$/;"	t
DiscardingCookie	Http.scala	/^  case class DiscardingCookie(name: String, path: String = "\/", domain: Option[String] = None, secure: Boolean = false) {$/;"	r
Discovery._	DiscoverySpec.scala	/^    import Discovery._$/;"	i
Discovery._	OpenID.scala	/^  import Discovery._$/;"	i
DiscoverySpec	DiscoverySpec.scala	/^object DiscoverySpec extends Specification with Mockito {$/;"	o
Display	ScalaTemplateCompiler.scala	/^    case class Display(exp: ScalaExp) extends TemplateTree with Positional$/;"	r
DnName	FakeKeyStore.scala	/^  val DnName = "CN=localhost, OU=Unit Testing, O=Mavericks, L=Moon Base 1, ST=Cyberspace, C=CY"$/;"	V
Dog	JsonExtensionSpec.scala	/^case class Dog(name: String, master: User)$/;"	r
Done	Iteratee.scala	/^  case class Done[+A, E](a: A, remaining: Input[E]) extends Step[E, A]$/;"	r
Done	Iteratee.scala	/^object Done {$/;"	o
DoneIt	Concurrent.scala	/^      case class DoneIt(s: Iteratee[E, Iteratee[E, A]]) extends State$/;"	r
DummyRequest	FormSpec.scala	/^class DummyRequest(data: Map[String, Array[String]]) extends play.mvc.Http.Request {$/;"	c
DynamicFormSpec	DynamicFormSpec.scala	/^object DynamicFormSpec extends Specification {$/;"	o
DynamicPart	PathParts.scala	/^case class DynamicPart(name: String, constraint: String) extends PathPart with Positional {$/;"	r
DynamicPart	Router.scala	/^case class DynamicPart(name: String, constraint: String) extends PathPart {$/;"	r
EOF	RoutesCompiler.scala	/^    def EOF: util.matching.Regex = "\\\\z".r$/;"	m
ETAG	StandardValues.scala	/^  val ETAG = "Etag"$/;"	V
EVENT_STREAM	StandardValues.scala	/^  def EVENT_STREAM(implicit codec: Codec) = withCharset(MimeTypes.EVENT_STREAM)$/;"	m
EVENT_STREAM	StandardValues.scala	/^  val EVENT_STREAM = "text\/event-stream"$/;"	V
EXPECT	StandardValues.scala	/^  val EXPECT = "Expect"$/;"	V
EXPECTATION_FAILED	StandardValues.scala	/^  val EXPECTATION_FAILED = 417$/;"	V
EXPIRES	StandardValues.scala	/^  val EXPIRES = "Expires"$/;"	V
EhCachePlugin	Cache.scala	/^class EhCachePlugin(app: Application) extends CachePlugin {$/;"	c
EitherToFEither	JavaHelpers.scala	/^class EitherToFEither[A,B]() extends play.libs.F.Function[Either[A,B],play.libs.F.Either[A,B]] {$/;"	c
El	Iteratee.scala	/^  case class El[+E](e: E) extends Input[E]$/;"	r
EmptyContent	Results.scala	/^  case class EmptyContent()$/;"	r
EntityTooLarge	Results.scala	/^  val EntityTooLarge = new Status(REQUEST_ENTITY_TOO_LARGE)$/;"	V
Enumeratee	Enumeratee.scala	/^object Enumeratee {$/;"	o
Enumeratee	Enumeratee.scala	/^trait Enumeratee[From, To] {$/;"	t
Enumeratee.CheckDone	TraversableIteratee.scala	/^  import Enumeratee.CheckDone$/;"	i
EnumerateesSpec	EnumerateesSpec.scala	/^object EnumerateesSpec extends Specification {$/;"	o
Enumerator	Enumerator.scala	/^object Enumerator {$/;"	o
Enumerator	Enumerator.scala	/^trait Enumerator[E] {$/;"	t
Enumerator.Pushee	Concurrent.scala	/^import Enumerator.Pushee$/;"	i
EnumeratorsSpec	EnumeratorsSpec.scala	/^object EnumeratorsSpec extends Specification {$/;"	o
Error	Iteratee.scala	/^  case class Error[E](msg: String, input: Input[E]) extends Step[E, Nothing]$/;"	r
Error	Iteratee.scala	/^object Error {$/;"	o
Error	SqlParser.scala	/^case class Error(msg: SqlRequestError) extends SqlResult[Nothing]$/;"	r
Errors	OpenIDError.scala	/^object Errors {$/;"	o
EssentialAction	Action.scala	/^object EssentialAction {$/;"	o
EssentialAction	Action.scala	/^trait EssentialAction extends (RequestHeader => Iteratee[Array[Byte], Result]) with Handler {$/;"	t
EssentialFilter	Filters.scala	/^trait EssentialFilter {$/;"	t
EventIdExtractor	EventSource.scala	/^  case class EventIdExtractor[E](eventId: E => Option[String])$/;"	r
EventIdExtractor	EventSource.scala	/^  object EventIdExtractor extends LowPriorityEventIdExtractor$/;"	o
EventNameExtractor	EventSource.scala	/^  case class EventNameExtractor[E](eventName: E => Option[String])$/;"	r
EventNameExtractor	EventSource.scala	/^  object EventNameExtractor extends LowPriorityEventNameExtractor {$/;"	o
EventSource	EventSource.scala	/^object EventSource {$/;"	o
Evolutions	Evolutions.scala	/^object Evolutions {$/;"	o
Evolutions._	Evolutions.scala	/^  import Evolutions._$/;"	i
EvolutionsPlugin	Evolutions.scala	/^class EvolutionsPlugin(app: Application) extends Plugin with HandleWebCommandSupport {$/;"	c
Exit	Console.scala	/^  case class Exit(val code: Int) extends xsbti.Exit$/;"	r
ExpectationFailed	Results.scala	/^  val ExpectationFailed = new Status(EXPECTATION_FAILED)$/;"	V
ExternalAssets	ExternalAssets.scala	/^object ExternalAssets extends Controller {$/;"	o
FAILED_DEPENDENCY	StandardValues.scala	/^  val FAILED_DEPENDENCY = 424$/;"	V
FIREFOX	Helpers.scala	/^  val FIREFOX = classOf[FirefoxDriver]$/;"	V
FORBIDDEN	StandardValues.scala	/^  val FORBIDDEN = 403$/;"	V
FORM	StandardValues.scala	/^  def FORM(implicit codec: Codec) = withCharset(MimeTypes.FORM)$/;"	m
FORM	StandardValues.scala	/^  val FORM = "application\/x-www-form-urlencoded"$/;"	V
FOUND	StandardValues.scala	/^  val FOUND = 302$/;"	V
FRAMES_TYPE	WebSocket.scala	/^  type FRAMES_TYPE = A$/;"	T
FROM	StandardValues.scala	/^  val FROM = "From"$/;"	V
FailedDependency	Results.scala	/^  val FailedDependency = new Status(FAILED_DEPENDENCY)$/;"	V
FakeApplication	Fakes.scala	/^case class FakeApplication($/;"	r
FakeHeaders	Fakes.scala	/^case class FakeHeaders(val data: Seq[(String, Seq[String])] = Seq.empty) extends Headers$/;"	r
FakeKeyStore	FakeKeyStore.scala	/^object FakeKeyStore {$/;"	o
FakeRequest	Fakes.scala	/^case class FakeRequest[A](method: String, uri: String, headers: FakeHeaders, body: A, remoteAddress: String = "127.0.0.1", version: String = "HTTP\/1.1", id: Long = 666, tags: Map[String,String] = Map.empty[String,String]) extends Request[A] {$/;"	r
FakeRequest	Fakes.scala	/^object FakeRequest {$/;"	o
Field	Form.scala	/^case class Field(private val form: Form[_], name: String, constraints: Seq[(String, Seq[Any])], format: Option[(String, Seq[Any])], errors: Seq[FormError], value: Option[String]) {$/;"	r
FieldMapping	Form.scala	/^case class FieldMapping[T](val key: String = "", val constraints: Seq[Constraint[T]] = Nil)(implicit val binder: Formatter[T]) extends Mapping[T] {$/;"	r
File	PlayReloader.scala	/^          classFile -> classFile.lastModified$/;"	c
FileInfo	ContentTypes.scala	/^      case class FileInfo(partName: String, fileName: String, contentType: Option[String])$/;"	r
FileInfoMatcher	ContentTypes.scala	/^      object FileInfoMatcher {$/;"	o
FilePart	ContentTypes.scala	/^  case class FilePart[A](key: String, filename: String, contentType: Option[String], ref: A) extends Part$/;"	r
Files	Files.scala	/^object Files {$/;"	o
Filter	Filters.scala	/^object Filter {$/;"	o
Filter	Filters.scala	/^trait Filter extends EssentialFilter {$/;"	t
FilterChain	Filters.scala	/^object FilterChain{$/;"	o
Filters	Filters.scala	/^object Filters {$/;"	o
Flash	Http.scala	/^  case class Flash(data: Map[String, String] = Map.empty[String, String]) {$/;"	r
Flash	Http.scala	/^  object Flash extends CookieBaker[Flash] {$/;"	o
Forbidden	Results.scala	/^  val Forbidden = new Status(FORBIDDEN)$/;"	V
Form	Form.scala	/^case class Form[T](mapping: Mapping[T], data: Map[String, String], errors: Seq[FormError], value: Option[T]) {$/;"	r
Form	Form.scala	/^object Form {$/;"	o
Form._	Forms.scala	/^  import Form._$/;"	i
FormError	Form.scala	/^case class FormError(key: String, message: String, args: Seq[Any] = Nil) {$/;"	r
FormSpec	FormSpec.scala	/^object FormSpec extends Specification {$/;"	o
FormUrlEncodedParser	FormUrlEncodedParser.scala	/^object FormUrlEncodedParser {$/;"	o
Format	FakeRuntime.scala	/^  trait Format[T <: Appendable[T]] {$/;"	t
Format	Format.scala	/^object Format extends PathFormat with ConstraintFormat with DefaultFormat {$/;"	o
Format	Format.scala	/^trait Format[A] extends Writes[A] with Reads[A]$/;"	t
Format	ScalaTemplate.scala	/^  trait Format[T <: Appendable[T]] {$/;"	t
Format.constraints._	JsonValidSpec.scala	/^      import Format.constraints._$/;"	i
FormatSpec	FormatSpec.scala	/^object FormatSpec extends Specification {$/;"	o
Formats._	Forms.scala	/^  import Formats._$/;"	i
Forms	Forms.scala	/^object Forms {$/;"	o
Forms._	csrf.scala	/^  import Forms._$/;"	i
Found	Results.scala	/^  def Found(url: String): SimpleResult[Results.EmptyContent] = Redirect(url, FOUND)$/;"	m
FrameFormatter	Frame.scala	/^case class FrameFormatter[A](toFrame: A => WebSocketFrame, fromFrame: PartialFunction[WebSocketFrame, A]) extends play.api.mvc.WebSocket.FrameFormatter[A] {$/;"	r
FrameFormatter	WebSocket.scala	/^  object FrameFormatter {$/;"	o
FrameFormatter	WebSocket.scala	/^  trait FrameFormatter[A] {$/;"	t
Frames	Frame.scala	/^object Frames {$/;"	o
G8Helpers.Regs._	Console.scala	/^          import G8Helpers.Regs._$/;"	i
GATEWAY_TIMEOUT	StandardValues.scala	/^  val GATEWAY_TIMEOUT = 504$/;"	V
GET	Helpers.scala	/^  val GET = "GET"$/;"	V
GONE	StandardValues.scala	/^  val GONE = 410$/;"	V
GatewayTimeout	Results.scala	/^  val GatewayTimeout = new Status(GATEWAY_TIMEOUT)$/;"	V
GeneratedKeyStore	FakeKeyStore.scala	/^  val GeneratedKeyStore = "conf\/generated.keystore"$/;"	V
GeneratedSource	RoutesCompiler.scala	/^  case class GeneratedSource(file: File) {$/;"	r
GeneratedSource	ScalaTemplateCompiler.scala	/^  case class GeneratedSource(file: File) extends AbstractGeneratedSource{$/;"	r
GeneratedSourceVirtual	ScalaTemplateCompiler.scala	/^  case class GeneratedSourceVirtual(path: String) extends AbstractGeneratedSource {$/;"	r
Global	csrf.scala	/^  object Global extends WithFilters(CSRFFilter()) with GlobalSettings$/;"	o
GlobalPlugin	GlobalSettings.scala	/^class GlobalPlugin(app: Application) extends Plugin {$/;"	c
GlobalSettings	GlobalSettings.scala	/^trait GlobalSettings {$/;"	t
Gone	Results.scala	/^  val Gone = new Status(GONE)$/;"	V
HEAD	Helpers.scala	/^  val HEAD = "HEAD"$/;"	V
HOST	StandardValues.scala	/^  val HOST = "Host"$/;"	V
HTML	StandardValues.scala	/^  def HTML(implicit codec: Codec) = withCharset(MimeTypes.HTML)$/;"	m
HTML	StandardValues.scala	/^  val HTML = "text\/html"$/;"	V
HTMLUNIT	Helpers.scala	/^  val HTMLUNIT = classOf[HtmlUnitDriver]$/;"	V
HTTP	NettyServer.scala	/^  val HTTP = {$/;"	V
HTTPS	NettyServer.scala	/^  val HTTPS = sslPort.map { port =>$/;"	V
HTTP_VERSION_NOT_SUPPORTED	StandardValues.scala	/^  val HTTP_VERSION_NOT_SUPPORTED = 505$/;"	V
HandleWebCommandSupport	ApplicationProvider.scala	/^trait HandleWebCommandSupport {$/;"	t
Handler	Action.scala	/^trait Handler$/;"	t
HandlerCall	RoutesCompiler.scala	/^  case class HandlerCall(packageName: String, controller: String, instantiate: Boolean, method: String, parameters: Option[Seq[Parameter]]) extends Positional {$/;"	r
HandlerDef	Router.scala	/^  case class HandlerDef(ref: AnyRef, controller: String, method: String, parameterTypes: Seq[Class[_]], verb: String, comments: String, path: String)$/;"	r
HandlerInvoker	Router.scala	/^  object HandlerInvoker {$/;"	o
HandlerInvoker	Router.scala	/^  trait HandlerInvoker[T] {$/;"	t
HandlerRef	Action.scala	/^class HandlerRef[T](callValue: => T, handlerDef: play.core.Router.HandlerDef)(implicit handlerInvoker: play.core.Router.HandlerInvoker[T]) extends play.mvc.HandlerRef {$/;"	c
Hash	RoutesCompiler.scala	/^  object Hash {$/;"	o
Hash	ScalaTemplateCompiler.scala	/^  object Hash {$/;"	o
HeaderNames	StandardValues.scala	/^object HeaderNames extends HeaderNames$/;"	o
HeaderNames	StandardValues.scala	/^trait HeaderNames {$/;"	t
Headers	Http.scala	/^  trait Headers {$/;"	t
Helper	TemplateCompilerSpec.scala	/^object Helper {$/;"	o
Helper._	TemplateCompilerSpec.scala	/^  import Helper._$/;"	i
Helpers	Helpers.scala	/^object Helpers extends Status with HeaderNames {$/;"	o
HelpersSpec	HelpersSpec.scala	/^class HelpersSpec extends Specification {$/;"	c
Html	RequestExtractors.scala	/^    val Html = Accepting(MimeTypes.HTML)$/;"	V
Html	TemplateCompilerSpec.scala	/^  case class Html(text: String) extends Appendable[Html] {$/;"	r
Html	TemplateUtilsSpec.scala	/^        case class Html(text: String) extends Appendable[Html] {$/;"	r
Html	Templates.scala	/^class Html(val buffer: StringBuilder) extends Appendable[Html] with Content with play.mvc.Content {$/;"	c
Html	Templates.scala	/^object Html {$/;"	o
HtmlFormat	TemplateCompilerSpec.scala	/^  object HtmlFormat extends Format[Html] {$/;"	o
HtmlFormat	TemplateUtilsSpec.scala	/^        object HtmlFormat extends Format[Html] {$/;"	o
HtmlFormat	Templates.scala	/^object HtmlFormat extends Format[Html] {$/;"	o
HtmlResolver	OpenID.scala	/^  class HtmlResolver extends Resolver {$/;"	c
HttpVerb	RoutesCompiler.scala	/^  case class HttpVerb(value: String) {$/;"	r
HttpVersionNotSupported	Results.scala	/^  val HttpVersionNotSupported = new Status(HTTP_VERSION_NOT_SUPPORTED)$/;"	V
Hub	Concurrent.scala	/^  trait Hub[E] extends Broadcaster {$/;"	t
IF_MATCH	StandardValues.scala	/^  val IF_MATCH = "If-Match"$/;"	V
IF_MODIFIED_SINCE	StandardValues.scala	/^  val IF_MODIFIED_SINCE = "If-Modified-Since"$/;"	V
IF_NONE_MATCH	StandardValues.scala	/^  val IF_NONE_MATCH = "If-None-Match"$/;"	V
IF_RANGE	StandardValues.scala	/^  val IF_RANGE = "If-Range"$/;"	V
IF_UNMODIFIED_SINCE	StandardValues.scala	/^  val IF_UNMODIFIED_SINCE = "If-Unmodified-Since"$/;"	V
INSUFFICIENT_STORAGE	StandardValues.scala	/^  val INSUFFICIENT_STORAGE = 507$/;"	V
INTERNAL_SERVER_ERROR	StandardValues.scala	/^  val INTERNAL_SERVER_ERROR = 500$/;"	V
INVALID_TOKEN	csrf.scala	/^    val INVALID_TOKEN: PlainResult  = BadRequest("Invalid CSRF Token")$/;"	V
IN_MEMORY_JNDI	JNDI.scala	/^  private val IN_MEMORY_JNDI = "tyrex.naming.MemoryContextFactory"$/;"	V
IN_MEMORY_URL	JNDI.scala	/^  private val IN_MEMORY_URL = "\/"$/;"	V
Id	Anorm.scala	/^case class Id[ID](id: ID) extends Pk[ID] {$/;"	r
Id	JsonExtensionSpec.scala	/^case class Id[A](id: A)$/;"	r
IdParser	Console.scala	/^  private val IdParser = """(\\p{L}[\\p{L}\\p{LD}_-]*)""".r$/;"	V
IdxPathNode	JsPath.scala	/^case class IdxPathNode(idx: Int) extends PathNode {$/;"	r
InPlaceLogger	PlayLogger.scala	/^object InPlaceLogger {$/;"	o
Include	Router.scala	/^  object Include {$/;"	o
Include	RoutesCompiler.scala	/^  case class Include(prefix: String, router: String) extends Rule$/;"	r
InconsistentDatabase	Evolutions.scala	/^case class InconsistentDatabase(db: String, script: String, error: String, rev: Int) extends PlayException.RichDescription($/;"	r
Input	Iteratee.scala	/^object Input {$/;"	o
InsufficientStorage	Results.scala	/^  val InsufficientStorage = new Status(INSUFFICIENT_STORAGE)$/;"	V
InternalServerError	Results.scala	/^  val InternalServerError = new Status(INTERNAL_SERVER_ERROR)$/;"	V
Invalid	Validation.scala	/^case class Invalid(errors: Seq[ValidationError]) extends ValidationResult {$/;"	r
Invalid	Validation.scala	/^object Invalid {$/;"	o
InvalidDatabaseRevision	Evolutions.scala	/^case class InvalidDatabaseRevision(db: String, script: String) extends PlayException.RichDescription($/;"	r
IsoDateReads	Reads.scala	/^  val IsoDateReads = dateReads("yyyy-MM-dd'T'HH:mm:ssz", { input => $/;"	V
Iteratee	Iteratee.scala	/^object Iteratee {$/;"	o
Iteratee	Iteratee.scala	/^trait Iteratee[E, +A] {$/;"	t
JAVA	PlayCommands.scala	/^  val JAVA = "java"$/;"	V
JAVASCRIPT	StandardValues.scala	/^  def JAVASCRIPT(implicit codec: Codec) = withCharset(MimeTypes.JAVASCRIPT)$/;"	m
JAVASCRIPT	StandardValues.scala	/^  val JAVASCRIPT = "text\/javascript"$/;"	V
JNDI	JNDI.scala	/^object JNDI {$/;"	o
JSON	StandardValues.scala	/^  def JSON(implicit codec: Codec) = withCharset(MimeTypes.JSON)$/;"	m
JSON	StandardValues.scala	/^  val JSON = "application\/json"$/;"	V
JUnitXmlTestsListener	JUnitXmlTestListener.scala	/^class JUnitXmlTestsListener(val outputDir: String, logger: Logger) extends TestsListener {$/;"	c
JavaAction	JavaAction.scala	/^trait JavaAction extends Action[play.mvc.Http.RequestBody] with JavaHelpers {$/;"	t
JavaGlobalSettingsAdapter	JavaGlobalSettingsAdapter.scala	/^class JavaGlobalSettingsAdapter(val underlying: play.GlobalSettings) extends GlobalSettings {$/;"	c
JavaHelpers	JavaHelpers.scala	/^object JavaHelpers extends JavaHelpers$/;"	o
JavaHelpers	JavaHelpers.scala	/^trait JavaHelpers {$/;"	t
JavaParsers	JavaParsers.scala	/^object JavaParsers extends BodyParsers {$/;"	o
JavaPromise	JavaPromise.scala	/^object JavaPromise {$/;"	o
JavaResultExtractor	JavaResults.scala	/^object JavaResultExtractor {$/;"	o
JavaResults	JavaResults.scala	/^object JavaResults extends Results with DefaultWriteables with DefaultContentTypeOfs {$/;"	o
JavaScript	RequestExtractors.scala	/^    val JavaScript = Accepting(MimeTypes.JAVASCRIPT)$/;"	V
JavaWebSocket	JavaWebSocket.scala	/^object JavaWebSocket extends JavaHelpers {$/;"	o
JavacError	PlayReloader.scala	/^            val JavacError = """\\[error\\]\\s*(.*[.]java):(\\d+):\\s*(.*)""".r$/;"	V
JavacErrorInfo	PlayReloader.scala	/^            val JavacErrorInfo = """\\[error\\]\\s*([a-z ]+):(.*)""".r$/;"	V
JavacErrorPosition	PlayReloader.scala	/^            val JavacErrorPosition = """\\[error\\](\\s*)\\^\\s*""".r$/;"	V
JavascriptCompiler	JavascriptCompiler.scala	/^object JavascriptCompiler {$/;"	o
JavascriptCompiler	PlayAssetsCompiler.scala	/^  def JavascriptCompiler(fullCompilerOptions: Option[com.google.javascript.jscomp.CompilerOptions]) = AssetsCompiler("javascripts",$/;"	m
JavascriptLitteral	Binders.scala	/^object JavascriptLitteral {$/;"	o
JavascriptLitteral	Binders.scala	/^trait JavascriptLitteral[A] {$/;"	t
JavascriptReverseRoute	Router.scala	/^  case class JavascriptReverseRoute(name: String, f: String)$/;"	r
JsArray	JsValue.scala	/^case class JsArray(value: Seq[JsValue] = List()) extends JsValue{$/;"	r
JsArrayReducer	Reads.scala	/^  implicit val JsArrayReducer = Reducer[JsValue, JsArray]( js => JsArray(Seq(js)) )$/;"	V
JsBoolean	JsValue.scala	/^case class JsBoolean(value: Boolean) extends JsValue$/;"	r
JsError	JsResult.scala	/^case class JsError(errors: Seq[(JsPath, Seq[ValidationError])]) extends JsResult[Nothing] {$/;"	r
JsError	JsResult.scala	/^object JsError {$/;"	o
JsErrorObj	Reads.scala	/^  def JsErrorObj(knownValue: JsValue, key: String, args: JsValue*) = {$/;"	m
JsMacroImpl	JsMacroImpl.scala	/^object JsMacroImpl {$/;"	o
JsNumber	JsValue.scala	/^case class JsNumber(value: BigDecimal) extends JsValue$/;"	r
JsObject	JsValue.scala	/^case class JsObject(fields: Seq[(String, JsValue)]) extends JsValue {$/;"	r
JsObjectReducer	Reads.scala	/^  implicit val JsObjectReducer = Reducer[JsObject, JsObject]( o => o )$/;"	V
JsPath	JsPath.scala	/^case class JsPath(path: List[PathNode] = List()) {$/;"	r
JsPath	JsPath.scala	/^object JsPath extends JsPath(List.empty) {$/;"	o
JsPathSpec	JsPathSpec.scala	/^object JsPathSpec extends Specification {$/;"	o
JsResult	JsResult.scala	/^object JsResult {$/;"	o
JsResultException	JsValue.scala	/^case class JsResultException(errors: Seq[(JsPath, Seq[ValidationError])]) extends RuntimeException( "JsResultException(errors:%s)".format(errors) )$/;"	r
JsString	JsValue.scala	/^case class JsString(value: String) extends JsValue$/;"	r
JsSuccess	JsResult.scala	/^case class JsSuccess[T](value: T, path: JsPath = JsPath()) extends JsResult[T] {$/;"	r
JsUndefined	JsValue.scala	/^case class JsUndefined(error: String) extends JsValue$/;"	r
Json	Json.scala	/^object Json {$/;"	o
Json	RequestExtractors.scala	/^    val Json = Accepting(MimeTypes.JSON)$/;"	V
Json._	JsConstraints.scala	/^import Json._$/;"	i
Json._	JsResult.scala	/^import Json._$/;"	i
Json._	Reads.scala	/^import Json._$/;"	i
Json._	Writes.scala	/^import Json._$/;"	i
JsonExtensionSpec	JsonExtensionSpec.scala	/^object JsonExtensionSpec extends Specification {$/;"	o
JsonRichSpec	JsonRichSpec.scala	/^object JsonRichSpec extends Specification {$/;"	o
JsonSpec	JsonSpec.scala	/^object JsonSpec extends Specification {$/;"	o
JsonTransSpec	JsonTransSpec.scala	/^object JsonTransSpec extends Specification {$/;"	o
JsonValidSpec	JsonValidSpec.scala	/^object JsonValidSpec extends Specification {$/;"	o
Jsonp	Jsonp.scala	/^case class Jsonp(padding: String, json: JsValue)$/;"	r
Jsonp	Jsonp.scala	/^object Jsonp {$/;"	o
JvmIO	PlayJvm.scala	/^object JvmIO {$/;"	o
KeyPathNode	JsPath.scala	/^case class KeyPathNode(key: String) extends PathNode{$/;"	r
KeyPattern	Form.scala	/^    val KeyPattern = ("^" + java.util.regex.Pattern.quote(key) + """\\[(\\d+)\\].*$""").r$/;"	V
Keys._	PlayAssetsCompiler.scala	/^import Keys._$/;"	i
Keys._	PlayCommands.scala	/^import Keys._$/;"	i
Keys._	PlayEclipse.scala	/^import Keys._$/;"	i
Keys._	PlayProject.scala	/^import Keys._$/;"	i
Keys._	PlayReloader.scala	/^import Keys._$/;"	i
Keys._	PlaySettings.scala	/^import Keys._$/;"	i
Keys._	Project.scala	/^import Keys._$/;"	i
LAST_MODIFIED	StandardValues.scala	/^  val LAST_MODIFIED = "Last-Modified"$/;"	V
LENGTH_REQUIRED	StandardValues.scala	/^  val LENGTH_REQUIRED = 411$/;"	V
LOCATION	StandardValues.scala	/^  val LOCATION = "Location"$/;"	V
LOCKED	StandardValues.scala	/^  val LOCKED = 423$/;"	V
Lang	Messages.scala	/^case class Lang(language: String, country: String = "") {$/;"	r
Lang	Messages.scala	/^object Lang {$/;"	o
LazyHelper	Util.scala	/^object LazyHelper{$/;"	o
LazyHelper	Util.scala	/^trait LazyHelper[M[_], T] {$/;"	t
LessCompiler	LessCompiler.scala	/^object LessCompiler {$/;"	o
LessCompiler	PlayAssetsCompiler.scala	/^  val LessCompiler = AssetsCompiler("less",$/;"	V
Locked	Results.scala	/^  val Locked = new Status(LOCKED)$/;"	V
Logger	Logger.scala	/^class Logger(val logger: Slf4jLogger) extends LoggerLike$/;"	c
Logger	Logger.scala	/^object Logger extends LoggerLike {$/;"	o
LoggerLike	Logger.scala	/^trait LoggerLike {$/;"	t
LowPriorityEventIdExtractor	EventSource.scala	/^  trait LowPriorityEventIdExtractor {$/;"	t
LowPriorityEventNameExtractor	EventSource.scala	/^  trait LowPriorityEventNameExtractor {$/;"	t
LowPriorityWriteables	Writeable.scala	/^trait LowPriorityWriteables {$/;"	t
MAX_FORWARDS	StandardValues.scala	/^  val MAX_FORWARDS = "Max-Forwards"$/;"	V
MAX_MESSAGE_WATERMARK	RequestBodyHandler.scala	/^    val MAX_MESSAGE_WATERMARK = 10$/;"	V
METHOD_NOT_ALLOWED	StandardValues.scala	/^  val METHOD_NOT_ALLOWED = 405$/;"	V
MIN_MESSAGE_WATERMARK	RequestBodyHandler.scala	/^    val MIN_MESSAGE_WATERMARK = 10$/;"	V
MISSING_PARAMETERS	OpenIDError.scala	/^  object MISSING_PARAMETERS extends OpenIDError("missing_parameters", """The OpenID server omitted parameters in the callback.""")$/;"	o
MOVED_PERMANENTLY	StandardValues.scala	/^  val MOVED_PERMANENTLY = 301$/;"	V
MULTIPLE_CHOICES	StandardValues.scala	/^  val MULTIPLE_CHOICES = 300$/;"	V
MULTI_STATUS	StandardValues.scala	/^  val MULTI_STATUS = 207$/;"	V
Mapping	Form.scala	/^trait Mapping[T] {$/;"	t
Matched	Iteratee.scala	/^  case class Matched[A](val content: A) extends MatchInfo[A]$/;"	r
MaxDataPartSizeExceeded	ContentTypes.scala	/^  case class MaxDataPartSizeExceeded(key: String) extends Part$/;"	r
MaxSizeExceeded	ContentTypes.scala	/^case class MaxSizeExceeded(length: Int)$/;"	r
MayErr	Utils.scala	/^case class MayErr[+E, +A](e: Either[E, A]) {$/;"	r
MayErr	Utils.scala	/^object MayErr {$/;"	o
MayErr._	Anorm.scala	/^import MayErr._$/;"	i
MayErr._	SqlParser.scala	/^    import MayErr._$/;"	i
MayErr._	SqlParser.scala	/^  import MayErr._$/;"	i
MaybeGeneratedSource	RoutesCompiler.scala	/^  object MaybeGeneratedSource {$/;"	o
MaybeGeneratedSource	ScalaTemplateCompiler.scala	/^  object MaybeGeneratedSource {$/;"	o
MediaRange	MediaRange.scala	/^case class MediaRange(mediaType: String, mediaSubType: String, parameters: Option[String]) {$/;"	r
MediaRange	MediaRange.scala	/^object MediaRange {$/;"	o
MediaRangeSpec	MediaRangeSpec.scala	/^object MediaRangeSpec extends Specification {$/;"	o
Messages	Messages.scala	/^object Messages {$/;"	o
MessagesApi	Messages.scala	/^case class MessagesApi(messages: Map[String, Map[String, String]]) {$/;"	r
MessagesPlugin	Messages.scala	/^class MessagesPlugin(app: Application) extends Plugin {$/;"	c
MessagesSpec	MessagesSpec.scala	/^object MessagesSpec extends Specification {$/;"	o
Meta	ScalaTemplateCompiler.scala	/^      val Meta = """([A-Z]+): (.*)""".r$/;"	V
MetaData	Anorm.scala	/^case class MetaData(ms: List[MetaDataItem]) {$/;"	r
MetaDataItem	Anorm.scala	/^case class MetaDataItem(column: ColumnName, nullable: Boolean, clazz: String)$/;"	r
MethodNotAllowed	Results.scala	/^  val MethodNotAllowed = new Status(METHOD_NOT_ALLOWED)$/;"	V
MimeTypes	MimeTypes.scala	/^object MimeTypes {$/;"	o
MimeTypes	StandardValues.scala	/^object MimeTypes extends MimeTypes$/;"	o
MimeTypes	StandardValues.scala	/^trait MimeTypes {$/;"	t
Min	Task.scala	/^  type Min = play.data.validation.Constraints.Min @field$/;"	T
MockRow	Anorm.scala	/^case class MockRow(data: List[Any], metaData: MetaData) extends Row$/;"	r
Mode	Play.scala	/^  type Mode = Value$/;"	T
Mode	Play.scala	/^object Mode extends Enumeration {$/;"	o
MovedPermanently	Results.scala	/^  def MovedPermanently(url: String): SimpleResult[Results.EmptyContent] = Redirect(url, MOVED_PERMANENTLY)$/;"	m
MultiStatus	Results.scala	/^  val MultiStatus = new Status(MULTI_STATUS)$/;"	V
Multipart	ContentTypes.scala	/^    object Multipart {$/;"	o
MultipartFormData	ContentTypes.scala	/^case class MultipartFormData[A](dataParts: Map[String, Seq[String]], files: Seq[FilePart[A]], badParts: Seq[BadPart]) {$/;"	r
MultipartFormData	ContentTypes.scala	/^object MultipartFormData {$/;"	o
MultipartFormData._	ContentTypes.scala	/^import MultipartFormData._$/;"	i
MysqlCustomProperties	DB.scala	/^    val MysqlCustomProperties = ".*\\\\?(.*)".r$/;"	V
MysqlFullUrl	DB.scala	/^    val MysqlFullUrl = "^mysql:\/\/([a-zA-Z0-9_]+):([^@]+)@([^\/]+)\/([^\\\\s]+)$".r$/;"	V
NETWORK_ERROR	OpenIDError.scala	/^  object NETWORK_ERROR extends OpenIDError("network_error", """Couldn't contact the server.""")$/;"	o
NONE	PlayCommands.scala	/^  val NONE = "none"$/;"	V
NON_AUTHORITATIVE_INFORMATION	StandardValues.scala	/^  val NON_AUTHORITATIVE_INFORMATION = 203$/;"	V
NOT_ACCEPTABLE	StandardValues.scala	/^  val NOT_ACCEPTABLE = 406$/;"	V
NOT_FOUND	StandardValues.scala	/^  val NOT_FOUND = 404$/;"	V
NOT_IMPLEMENTED	StandardValues.scala	/^  val NOT_IMPLEMENTED = 501$/;"	V
NOT_MODIFIED	StandardValues.scala	/^  val NOT_MODIFIED = 304$/;"	V
NO_CONTENT	StandardValues.scala	/^  val NO_CONTENT = 204$/;"	V
NO_SERVER	OpenIDError.scala	/^  object NO_SERVER extends OpenIDError("no_server", """The OpenID server could not be resolved.""")$/;"	o
Name	ScalaTemplateCompiler.scala	/^      val Name = """([a-zA-Z0-9_]+)[.]scala[.]([a-z]+)""".r$/;"	V
NamedThreadFactory	NamedThreadFactory.scala	/^case class NamedThreadFactory(name: String) extends ThreadFactory {$/;"	r
NettyPromise	NettyPromise.scala	/^object NettyPromise {$/;"	o
NettyServer	NettyServer.scala	/^class NettyServer(appProvider: ApplicationProvider, port: Int, sslPort: Option[Int] = None, address: String = "0.0.0.0", val mode: Mode.Mode = Mode.Prod) extends Server with ServerWithStop {$/;"	c
NettyServer	NettyServer.scala	/^object NettyServer {$/;"	o
NoContent	Results.scala	/^  val NoContent = SimpleResult(header = ResponseHeader(NO_CONTENT), body = Enumerator(Results.EmptyContent()))$/;"	V
NonAuthoritativeInformation	Results.scala	/^  val NonAuthoritativeInformation = new Status(NON_AUTHORITATIVE_INFORMATION)$/;"	V
NotAcceptable	Results.scala	/^  val NotAcceptable = new Status(NOT_ACCEPTABLE)$/;"	V
NotFound	Results.scala	/^  val NotFound = new Status(NOT_FOUND)$/;"	V
NotImplemented	Results.scala	/^  val NotImplemented = new Status(NOT_IMPLEMENTED)$/;"	V
NotModified	Results.scala	/^  val NotModified = SimpleResult(header = ResponseHeader(NOT_MODIFIED), body = Enumerator(Results.EmptyContent()))$/;"	V
NotWaiting	Promise.scala	/^trait NotWaiting[+A] extends PromiseValue[A] {$/;"	t
OAuth	OAuth.scala	/^case class OAuth(info: ServiceInfo, use10a: Boolean = true) {$/;"	r
OAuthCalculator	OAuth.scala	/^case class OAuthCalculator(consumerKey: ConsumerKey, token: RequestToken) extends AbstractOAuthConsumer(consumerKey.key, consumerKey.secret) with SignatureCalculator {$/;"	r
OFormat	Format.scala	/^object OFormat {$/;"	o
OFormat	Format.scala	/^trait OFormat[A] extends OWrites[A] with Reads[A] with Format[A] $/;"	t
OK	StandardValues.scala	/^  val OK = 200$/;"	V
ORIGIN	StandardValues.scala	/^  val ORIGIN = "Origin"$/;"	V
OWrites	Writes.scala	/^object OWrites extends PathWrites with ConstraintWrites {$/;"	o
OWrites	Writes.scala	/^trait OWrites[-A] extends Writes[A]{$/;"	t
ObjectMapping	Form.scala	/^trait ObjectMapping {$/;"	t
ObjectMapping1	Form.scala	/^case class ObjectMapping1[R, A1](apply: Function1[A1, R], unapply: Function1[R, Option[(A1)]], f1: (String, Mapping[A1]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping10	ObjectMappings.scala	/^case class ObjectMapping10[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10](apply: Function10[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping11	ObjectMappings.scala	/^case class ObjectMapping11[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11](apply: Function11[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping12	ObjectMappings.scala	/^case class ObjectMapping12[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12](apply: Function12[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), f12: (String, Mapping[A12]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping13	ObjectMappings.scala	/^case class ObjectMapping13[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13](apply: Function13[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), f12: (String, Mapping[A12]), f13: (String, Mapping[A13]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping14	ObjectMappings.scala	/^case class ObjectMapping14[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14](apply: Function14[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), f12: (String, Mapping[A12]), f13: (String, Mapping[A13]), f14: (String, Mapping[A14]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping15	ObjectMappings.scala	/^case class ObjectMapping15[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15](apply: Function15[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), f12: (String, Mapping[A12]), f13: (String, Mapping[A13]), f14: (String, Mapping[A14]), f15: (String, Mapping[A15]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping16	ObjectMappings.scala	/^case class ObjectMapping16[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16](apply: Function16[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), f12: (String, Mapping[A12]), f13: (String, Mapping[A13]), f14: (String, Mapping[A14]), f15: (String, Mapping[A15]), f16: (String, Mapping[A16]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping17	ObjectMappings.scala	/^case class ObjectMapping17[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17](apply: Function17[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), f12: (String, Mapping[A12]), f13: (String, Mapping[A13]), f14: (String, Mapping[A14]), f15: (String, Mapping[A15]), f16: (String, Mapping[A16]), f17: (String, Mapping[A17]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping18	ObjectMappings.scala	/^case class ObjectMapping18[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18](apply: Function18[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), f12: (String, Mapping[A12]), f13: (String, Mapping[A13]), f14: (String, Mapping[A14]), f15: (String, Mapping[A15]), f16: (String, Mapping[A16]), f17: (String, Mapping[A17]), f18: (String, Mapping[A18]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping2	ObjectMappings.scala	/^case class ObjectMapping2[R, A1, A2](apply: Function2[A1, A2, R], unapply: Function1[R, Option[(A1, A2)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping3	ObjectMappings.scala	/^case class ObjectMapping3[R, A1, A2, A3](apply: Function3[A1, A2, A3, R], unapply: Function1[R, Option[(A1, A2, A3)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping4	ObjectMappings.scala	/^case class ObjectMapping4[R, A1, A2, A3, A4](apply: Function4[A1, A2, A3, A4, R], unapply: Function1[R, Option[(A1, A2, A3, A4)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping5	ObjectMappings.scala	/^case class ObjectMapping5[R, A1, A2, A3, A4, A5](apply: Function5[A1, A2, A3, A4, A5, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping6	ObjectMappings.scala	/^case class ObjectMapping6[R, A1, A2, A3, A4, A5, A6](apply: Function6[A1, A2, A3, A4, A5, A6, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping7	ObjectMappings.scala	/^case class ObjectMapping7[R, A1, A2, A3, A4, A5, A6, A7](apply: Function7[A1, A2, A3, A4, A5, A6, A7, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping8	ObjectMappings.scala	/^case class ObjectMapping8[R, A1, A2, A3, A4, A5, A6, A7, A8](apply: Function8[A1, A2, A3, A4, A5, A6, A7, A8, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
ObjectMapping9	ObjectMappings.scala	/^case class ObjectMapping9[R, A1, A2, A3, A4, A5, A6, A7, A8, A9](apply: Function9[A1, A2, A3, A4, A5, A6, A7, A8, A9, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	r
Of	PlayCommands.scala	/^          classOf[play.api.PlayException.ExceptionAttachment].getName)$/;"	c
Of	PlayCommands.scala	/^          classOf[play.api.PlayException.ExceptionSource].getName,$/;"	c
Of	PlayCommands.scala	/^          classOf[play.api.PlayException.InterestingLines].getName,$/;"	c
Of	PlayCommands.scala	/^          classOf[play.api.PlayException.RichDescription].getName,$/;"	c
Of	PlayCommands.scala	/^          classOf[play.api.PlayException].getName,$/;"	c
Of	PlayCommands.scala	/^          classOf[play.api.UsefulException].getName,$/;"	c
Of	PlayCommands.scala	/^          classOf[play.core.SBTLink].getName,$/;"	c
Of	PlayCommands.scala	/^          classOf[play.core.server.ServerWithStop].getName,$/;"	c
OfflineEvolutions	Evolutions.scala	/^object OfflineEvolutions {$/;"	o
Ok	Results.scala	/^  val Ok = new Status(OK)$/;"	V
OpenID	OpenID.scala	/^object OpenID extends OpenIDClient(WS.url)$/;"	o
OpenIDServer	OpenID.scala	/^case class OpenIDServer(url: String, delegate: Option[String])$/;"	r
OpenIDSpec	OpenIDSpec.scala	/^object OpenIDSpec extends Specification with Mockito {$/;"	o
OptionalMapping	Form.scala	/^case class OptionalMapping[T](wrapped: Mapping[T], val constraints: Seq[Constraint[Option[T]]] = Nil) extends Mapping[Option[T]] {$/;"	r
PARTIAL_CONTENT	StandardValues.scala	/^  val PARTIAL_CONTENT = 206$/;"	V
PAYMENT_REQUIRED	StandardValues.scala	/^  val PAYMENT_REQUIRED = 402$/;"	V
POST	Helpers.scala	/^  val POST = "POST"$/;"	V
POST_LOOKUP	csrf.scala	/^      def POST_LOOKUP: Boolean = c.getBoolean("csrf.tokenInBody").getOrElse(true)$/;"	m
PRAGMA	StandardValues.scala	/^  val PRAGMA = "Pragma"$/;"	V
PRECONDITION_FAILED	StandardValues.scala	/^  val PRECONDITION_FAILED = 412$/;"	V
PROXY_AUTHENTICATE	StandardValues.scala	/^  val PROXY_AUTHENTICATE = "Proxy-Authenticate"$/;"	V
PROXY_AUTHENTICATION_REQUIRED	StandardValues.scala	/^  val PROXY_AUTHENTICATION_REQUIRED = 407$/;"	V
PROXY_AUTHORIZATION	StandardValues.scala	/^  val PROXY_AUTHORIZATION = "Proxy-Authorization"$/;"	V
PUT	Helpers.scala	/^  val PUT = "PUT"$/;"	V
Param	Router.scala	/^  case class Param[T](name: String, value: Either[String, T])$/;"	r
Parameter	RoutesCompiler.scala	/^  case class Parameter(name: String, typeName: String, fixed: Option[String], default: Option[String]) extends Positional {$/;"	r
ParameterValue	Anorm.scala	/^case class ParameterValue[A](aValue: A, statementSetter: ToStatement[A]) {$/;"	r
Params	ScalaTemplateCompiler.scala	/^    case class Params(code: String) extends Positional$/;"	r
ParamsExtractor	Router.scala	/^    trait ParamsExtractor {$/;"	t
Parser._	PlayCommands.scala	/^import Parser._$/;"	i
Parsing	Binders.scala	/^  class Parsing[A](parse: String => A, serialize: A => String, error: (String, Exception) => String)$/;"	c
Parsing	Binders.scala	/^  class Parsing[A](parse: String => A, serialize: A => String, error: (String, Exception) => String)(implicit codec: Codec)$/;"	c
Parsing	Iteratee.scala	/^object Parsing {$/;"	o
Parsing._	ParsingSpec.scala	/^import Parsing._$/;"	i
ParsingSpec	ParsingSpec.scala	/^object ParsingSpec extends Specification {$/;"	o
PartHandler	ContentTypes.scala	/^      type PartHandler[A] = PartialFunction[Map[String, String], Iteratee[Array[Byte], A]]$/;"	T
PartInfoMatcher	ContentTypes.scala	/^      object PartInfoMatcher {$/;"	o
Partial	PartialValidationSpec.scala	/^trait Partial$/;"	t
PartialContent	Results.scala	/^  val PartialContent = new Status(PARTIAL_CONTENT)$/;"	V
PartialValidationSpec	PartialValidationSpec.scala	/^class PartialValidationSpec extends Specification {$/;"	c
PatchPanel	Concurrent.scala	/^  trait PatchPanel[E] {$/;"	t
PathBindable	Binders.scala	/^object PathBindable {$/;"	o
PathBindable	Binders.scala	/^trait PathBindable[A] {$/;"	t
PathFormat	JsConstraints.scala	/^trait PathFormat {$/;"	t
PathPart	PathParts.scala	/^trait PathPart$/;"	t
PathPart	Router.scala	/^trait PathPart$/;"	t
PathPattern	PathParts.scala	/^case class PathPattern(parts: Seq[PathPart]) {$/;"	r
PathPattern	Router.scala	/^case class PathPattern(parts: Seq[PathPart]) {$/;"	r
PathReads	JsConstraints.scala	/^trait PathReads {$/;"	t
PathWrites	JsConstraints.scala	/^trait PathWrites {$/;"	t
Pk	Anorm.scala	/^abstract class Pk[+ID] {$/;"	a
Plain	ScalaTemplateCompiler.scala	/^    case class Plain(text: String) extends TemplateTree with Positional$/;"	r
PlainResult	Results.scala	/^object PlainResult {$/;"	o
PlainResult	Results.scala	/^trait PlainResult extends Result with WithHeaders[PlainResult] {$/;"	t
Play	Play.scala	/^object Play {$/;"	o
Play.current	Assets.scala	/^import Play.current$/;"	i
Play.current	ExternalAssets.scala	/^import Play.current$/;"	i
PlayAssetsCompiler	PlayAssetsCompiler.scala	/^trait PlayAssetsCompiler {$/;"	t
PlayCommands	PlayCommands.scala	/^trait PlayCommands extends PlayAssetsCompiler with PlayEclipse {$/;"	t
PlayEclipse	PlayEclipse.scala	/^trait PlayEclipse {$/;"	t
PlayExceptions	PlayExceptions.scala	/^object PlayExceptions extends PlayExceptions$/;"	o
PlayExceptions	PlayExceptions.scala	/^trait PlayExceptions {$/;"	t
PlayExceptions._	PlayAssetsCompiler.scala	/^import PlayExceptions._$/;"	i
PlayExceptions._	PlayCommands.scala	/^import PlayExceptions._$/;"	i
PlayExceptions._	PlayReloader.scala	/^import PlayExceptions._$/;"	i
PlayKeys	PlayKeys.scala	/^object PlayKeys extends PlayKeys/;"	o
PlayKeys	PlayKeys.scala	/^trait PlayKeys {$/;"	t
PlayKeys._	PlayAssetsCompiler.scala	/^import PlayKeys._$/;"	i
PlayKeys._	PlayCommands.scala	/^import PlayKeys._$/;"	i
PlayKeys._	PlaySettings.scala	/^import PlayKeys._$/;"	i
PlayLogManager	PlayLogger.scala	/^class PlayLogManager(extra: ScopedKey[_] => Seq[AbstractLogger], playPositionMapper: Position => Option[Position]) extends LogManager {$/;"	c
PlayLogManager	PlayLogger.scala	/^object PlayLogManager {$/;"	o
PlayMagic	Templates.scala	/^object PlayMagic {$/;"	o
PlayMagicForJava	TemplateMagicForJava.scala	/^object PlayMagicForJava {$/;"	o
PlayPipelineFactory	NettyServer.scala	/^  class PlayPipelineFactory(secure: Boolean = false) extends ChannelPipelineFactory {$/;"	c
PlayPositionMapper	PlayPositionMapper.scala	/^trait PlayPositionMapper {$/;"	t
PlayProject	PlayProject.scala	/^object PlayProject extends Plugin with PlayExceptions with PlayKeys with PlayReloader with PlayCommands$/;"	o
PlayPromise	Promise.scala	/^class PlayPromise[+A](fu: scala.concurrent.Future[A]) {$/;"	c
PlayRedeemable	Promise.scala	/^class PlayRedeemable[-A](p: scala.concurrent.Promise[A]) extends Redeemable[A] {$/;"	c
PlayReloader	PlayReloader.scala	/^trait PlayReloader {$/;"	t
PlaySettings	PlaySettings.scala	/^trait PlaySettings {$/;"	t
PlaySourcePositionFilter	PlayLogger.scala	/^class PlaySourcePositionFilter(val playPositionMapper: Position => Option[Position]) {$/;"	c
Plugin	Plugins.scala	/^trait Plugin {$/;"	t
PluginDeclaration	Application.scala	/^    val PluginDeclaration = """([0-9_]+):(.*)""".r$/;"	V
Pointer	PlayLogger.scala	/^  val Pointer = """([\\t ]*)\\^""".r$/;"	V
Port	package.scala	/^  type Port = Int$/;"	T
PosString	ScalaTemplateCompiler.scala	/^    case class PosString(str: String) extends Positional {$/;"	r
Post	JsonSpec.scala	/^  case class Post(body: String, created_at: Option[Date])$/;"	r
PostCompile	PlayCommands.scala	/^  def PostCompile(scope: Configuration) = (sourceDirectory in scope, dependencyClasspath in scope, compile in scope, javaSource in scope, sourceManaged in scope, classDirectory in scope, cacheDirectory in scope) map { (src, deps, analysis, javaSrc, srcManaged, classes, cacheDir) =>$/;"	m
PostFormat	JsonSpec.scala	/^  implicit val PostFormat = ($/;"	V
PostgresFullUrl	DB.scala	/^    val PostgresFullUrl = "^postgres:\/\/([a-zA-Z0-9_]+):([^@]+)@([^\/]+)\/([^\\\\s]+)$".r$/;"	V
PreconditionFailed	Results.scala	/^  val PreconditionFailed = new Status(PRECONDITION_FAILED)$/;"	V
PresentationCompiler	ScalaTemplateCompiler.scala	/^      object PresentationCompiler extends TreeCreationMethods {$/;"	o
PriorityEight	Anorm.scala	/^trait PriorityEight extends PrioritySeven {$/;"	t
PriorityFive	Anorm.scala	/^trait PriorityFive extends PriorityFour {$/;"	t
PriorityFour	Anorm.scala	/^trait PriorityFour extends PriorityThree {$/;"	t
PriorityNine	Anorm.scala	/^trait PriorityNine extends PriorityEight {$/;"	t
PriorityOne	Anorm.scala	/^trait PriorityOne {$/;"	t
PrioritySeven	Anorm.scala	/^trait PrioritySeven extends PrioritySix {$/;"	t
PrioritySix	Anorm.scala	/^trait PrioritySix extends PriorityFive {$/;"	t
PriorityThree	Anorm.scala	/^trait PriorityThree extends PriorityTwo {$/;"	t
PriorityTwo	Anorm.scala	/^trait PriorityTwo extends PriorityOne {$/;"	t
Project	Project.scala	/^object Project extends Plugin with PlayExceptions with PlayKeys with PlayReloader with PlayCommands$/;"	o
Promise	Promise.scala	/^object Promise {$/;"	o
PromiseSpec	PromiseSpec.scala	/^class PromiseSpec extends Specification {$/;"	c
ProxyDriver	ProxyDriver.scala	/^class ProxyDriver(proxied: Driver) extends Driver {$/;"	c
PurePromise	Promise.scala	/^object PurePromise {$/;"	o
PushEnumerator	Enumerator.scala	/^class PushEnumerator[E] private[iteratee] ($/;"	c
Pushee	Enumerator.scala	/^  trait Pushee[E] {$/;"	t
QueryStringBindable	Binders.scala	/^object QueryStringBindable {$/;"	o
QueryStringBindable	Binders.scala	/^trait QueryStringBindable[A] {$/;"	t
Queueing	Concurrent.scala	/^      case class Queueing(q: Queue[Input[E]], length: Long) extends State$/;"	r
RANGE	StandardValues.scala	/^  val RANGE = "Range"$/;"	V
REFERER	StandardValues.scala	/^  val REFERER = "Referer"$/;"	V
REQUESTED_RANGE_NOT_SATISFIABLE	StandardValues.scala	/^  val REQUESTED_RANGE_NOT_SATISFIABLE = 416$/;"	V
REQUEST_ENTITY_TOO_LARGE	StandardValues.scala	/^  val REQUEST_ENTITY_TOO_LARGE = 413$/;"	V
REQUEST_TIMEOUT	StandardValues.scala	/^  val REQUEST_TIMEOUT = 408$/;"	V
REQUEST_URI_TOO_LONG	StandardValues.scala	/^  val REQUEST_URI_TOO_LONG = 414$/;"	V
RESET_CONTENT	StandardValues.scala	/^  val RESET_CONTENT = 205$/;"	V
RETRY_AFTER	StandardValues.scala	/^  val RETRY_AFTER = "Retry-After"$/;"	V
ROUTE_ACTION_METHOD	Routes.scala	/^    val ROUTE_ACTION_METHOD = "ROUTE_ACTION_METHOD"$/;"	V
ROUTE_COMMENTS	Routes.scala	/^    val ROUTE_COMMENTS = "ROUTE_COMMENTS"$/;"	V
ROUTE_CONTROLLER	Routes.scala	/^    val ROUTE_CONTROLLER = "ROUTE_CONTROLLER"$/;"	V
ROUTE_PATTERN	Routes.scala	/^    val ROUTE_PATTERN = "ROUTE_PATTERN"$/;"	V
ROUTE_VERB	Routes.scala	/^    val ROUTE_VERB = "ROUTE_VERB"$/;"	V
RawBuffer	ContentTypes.scala	/^case class RawBuffer(memoryThreshold: Int, initialData: Array[Byte] = Array.empty[Byte]) {$/;"	r
Reads	Reads.scala	/^object Reads extends ConstraintReads with PathReads with DefaultReads {$/;"	o
Reads	Reads.scala	/^trait Reads[A] {$/;"	t
Reads._	JsonValidSpec.scala	/^      import Reads._$/;"	i
Reads.constraints._	JsonTransSpec.scala	/^import Reads.constraints._$/;"	i
RecUser	JsonExtensionSpec.scala	/^case class RecUser(name: String, cat: Option[Cat] = None, hobbies: List[String] = List(), friends: List[RecUser] = List())$/;"	r
RecursiveSearch	JsPath.scala	/^case class RecursiveSearch(key: String) extends PathNode {$/;"	r
Redeemable	Promise.scala	/^trait Redeemable[-A] {$/;"	t
Redeemed	Promise.scala	/^case class Redeemed[+A](a: A) extends NotWaiting[A]$/;"	r
Redirect	Results.scala	/^  def Redirect(call: Call): SimpleResult[Results.EmptyContent] = Redirect(call.url)$/;"	m
Redirect	Results.scala	/^  def Redirect(url: String, queryString: Map[String, Seq[String]] = Map.empty, status: Int = SEE_OTHER) = {$/;"	m
Redirect	Results.scala	/^  def Redirect(url: String, status: Int): SimpleResult[Results.EmptyContent] = Redirect(url, Map.empty, status)$/;"	m
ReflectionsCache	ReflectionsCache.scala	/^object ReflectionsCache {$/;"	o
ReloadableApplication	ApplicationProvider.scala	/^class ReloadableApplication(sbtLink: SBTLink) extends ApplicationProvider {$/;"	c
Rendering	Render.scala	/^trait Rendering {$/;"	t
RepeatedMapping	Form.scala	/^case class RepeatedMapping[T](wrapped: Mapping[T], val key: String = "", val constraints: Seq[Constraint[List[T]]] = Nil) extends Mapping[List[T]] {$/;"	r
RepeatedMapping	Form.scala	/^object RepeatedMapping {$/;"	o
Request	Http.scala	/^  object Request {$/;"	o
Request	Http.scala	/^  trait Request[+A] extends RequestHeader {$/;"	t
RequestExtractors	RequestExtractors.scala	/^trait RequestExtractors extends AcceptExtractors {$/;"	t
RequestHeader	Http.scala	/^  object RequestHeader {$/;"	o
RequestHeader	Http.scala	/^  trait RequestHeader {$/;"	t
RequestTaggingHandler	Action.scala	/^trait RequestTaggingHandler extends Handler {$/;"	t
RequestTimeout	Results.scala	/^  val RequestTimeout = new Status(REQUEST_TIMEOUT)$/;"	V
RequestToken	OAuth.scala	/^case class RequestToken(token: String, secret: String)$/;"	r
Required	Task.scala	/^  type Required = play.data.validation.Constraints.Required @field$/;"	T
ResetContent	Results.scala	/^  val ResetContent = SimpleResult(header = ResponseHeader(RESET_CONTENT), body = Enumerator(Results.EmptyContent()))$/;"	V
Resolver	OpenID.scala	/^  trait Resolver {$/;"	t
Response	Http.scala	/^  trait Response {$/;"	t
Response	WS.scala	/^case class Response(ahcResponse: AHCResponse) {$/;"	r
ResponseHeader	Results.scala	/^case class ResponseHeader(status: Int, headers: Map[String, String] = Map.empty) {$/;"	r
ResponseHeaders	WS.scala	/^case class ResponseHeaders(status: Int, headers: Map[String, Seq[String]])$/;"	r
ResultSet	SqlParser.scala	/^  type ResultSet = Stream[Row]$/;"	T
ResultSetParser	SqlParser.scala	/^object ResultSetParser {$/;"	o
ResultSetParser	SqlParser.scala	/^trait ResultSetParser[+A] extends (ResultSet => SqlResult[A]) {$/;"	t
ResultWrapper	JavaResults.scala	/^  class ResultWrapper(r: play.api.mvc.Result) extends play.mvc.Result {$/;"	c
Results	Results.scala	/^object Results extends Results {$/;"	o
Results	Results.scala	/^trait Results {$/;"	t
Results._	ContentTypes.scala	/^import Results._$/;"	i
Results._	GlobalSettings.scala	/^  import Results._$/;"	i
Results._	csrf.scala	/^  import Results._$/;"	i
ResultsSpec	ResultsSpec.scala	/^object ResultsSpec extends Specification {$/;"	o
RichDate	FakeRuntime.scala	/^    class RichDate(date: java.util.Date) {$/;"	c
RichDate	ScalaTemplate.scala	/^    class RichDate(date: java.util.Date) {$/;"	c
RichString	FakeRuntime.scala	/^    class RichString(string: String) {$/;"	c
RichString	ScalaTemplate.scala	/^    class RichString(string: String) {$/;"	c
RichUrl	RichUrl.scala	/^ trait RichUrl[A] {$/;"	t
Route	Router.scala	/^   object Route {$/;"	o
Route	RoutesCompiler.scala	/^  case class Route(verb: HttpVerb, path: PathPattern, call: HandlerCall, comments: List[Comment] = List()) extends Rule$/;"	r
RouteFiles	PlayCommands.scala	/^  val RouteFiles = (state: State, confDirectory: File, generatedDir: File, additionalImports: Seq[String]) => {$/;"	V
RouteParams	Router.scala	/^  case class RouteParams(path: Map[String, String], queryString: Map[String, Seq[String]]) {$/;"	r
Router	Router.scala	/^object Router {$/;"	o
RouterSpec	RouterSpec.scala	/^object RouterSpec extends Specification {$/;"	o
Routes	Router.scala	/^  trait Routes {$/;"	t
Routes	Routes.scala	/^  object Routes {$/;"	o
RoutesCompilationError	RoutesCompiler.scala	/^  case class RoutesCompilationError(source: File, message: String, line: Option[Int], column: Option[Int]) extends RuntimeException(message)$/;"	r
RoutesCompilationException	PlayExceptions.scala	/^  case class RoutesCompilationException(source: File, message: String, atLine: Option[Int], column: Option[Int]) extends PlayException.ExceptionSource($/;"	r
RoutesCompiler	RoutesCompiler.scala	/^object RoutesCompiler {$/;"	o
RoutesCompilerSpec	RoutesCompilerSpec.scala	/^object RoutesCompilerSpec extends Specification {$/;"	o
Row	Anorm.scala	/^object Row {$/;"	o
Row	Anorm.scala	/^trait Row {$/;"	t
RowParser	SqlParser.scala	/^object RowParser {$/;"	o
RowParser	SqlParser.scala	/^trait RowParser[+A] extends (Row => SqlResult[A]) {$/;"	t
SCALA	PlayCommands.scala	/^  val SCALA = "scala"$/;"	V
SEE_OTHER	StandardValues.scala	/^  val SEE_OTHER = 303$/;"	V
SERVER	StandardValues.scala	/^  val SERVER = "Server"$/;"	V
SERVICE_UNAVAILABLE	StandardValues.scala	/^  val SERVICE_UNAVAILABLE = 503$/;"	V
SET_COOKIE	StandardValues.scala	/^  val SET_COOKIE = "Set-Cookie"$/;"	V
SET_COOKIE2	StandardValues.scala	/^  val SET_COOKIE2 = "Set-Cookie2"$/;"	V
SWITCHING_PROTOCOLS	StandardValues.scala	/^  val SWITCHING_PROTOCOLS = 101$/;"	V
Scala29Compiler	ScalaTemplateCompiler.scala	/^          type Scala29Compiler = {$/;"	T
ScalaExp	ScalaTemplateCompiler.scala	/^    case class ScalaExp(parts: Seq[ScalaExpPart]) extends TemplateTree with Positional$/;"	r
ScalaExpPart	ScalaTemplateCompiler.scala	/^    abstract class ScalaExpPart$/;"	a
ScalaForms	FormSpec.scala	/^object ScalaForms {$/;"	o
ScalaTemplateCompiler	ScalaTemplateCompiler.scala	/^  object ScalaTemplateCompiler {$/;"	o
ScalaTemplates	PlayCommands.scala	/^  val ScalaTemplates = (state: State, sourceDirectory: File, generatedDir: File, templateTypes: PartialFunction[String, (String, String)], additionalImports: Seq[String]) => {$/;"	V
ScriptSpec	ScriptSpec.scala	/^object ScriptSpec extends Specification {$/;"	o
Security	Security.scala	/^object Security {$/;"	o
SeeOther	Results.scala	/^  def SeeOther(url: String): SimpleResult[Results.EmptyContent] = Redirect(url, SEE_OTHER)$/;"	m
Server	Server.scala	/^trait Server {$/;"	t
ServerWithStop	NettyServer.scala	/^trait ServerWithStop {$/;"	t
ServiceInfo	OAuth.scala	/^case class ServiceInfo(requestTokenURL: String, accessTokenURL: String, authorizationURL: String, key: ConsumerKey)$/;"	r
ServiceUnavailable	Results.scala	/^  val ServiceUnavailable = new Status(SERVICE_UNAVAILABLE)$/;"	V
Session	Http.scala	/^  case class Session(data: Map[String, String] = Map.empty[String, String]) {$/;"	r
Session	Http.scala	/^  object Session extends CookieBaker[Session] {$/;"	o
SignatureCalculator	WS.scala	/^trait SignatureCalculator {$/;"	t
Simple	ScalaTemplateCompiler.scala	/^    case class Simple(code: String) extends ScalaExpPart with Positional$/;"	r
SimpleLocale	Messages.scala	/^  private val SimpleLocale = """([a-zA-Z]{2})""".r$/;"	V
SimpleResult	Results.scala	/^case class SimpleResult[A](header: ResponseHeader, body: Enumerator[A])(implicit val writeable: Writeable[A]) extends PlainResult {$/;"	r
SimpleSql	Anorm.scala	/^case class SimpleSql[T](sql: SqlQuery, params: Seq[(String, ParameterValue[_])], defaultParser: RowParser[T]) extends Sql {$/;"	r
SomeForm	PartialValidationSpec.scala	/^class SomeForm {$/;"	c
Source	ScalaTemplateCompiler.scala	/^  case class Source(code: String, pos: Position = NoPosition)$/;"	r
Source	ScalaTemplateCompiler.scala	/^  object Source {$/;"	o
SourceMapper	ApplicationProvider.scala	/^trait SourceMapper {$/;"	t
SpecsSpec	SpecsSpec.scala	/^object SpecsSpec extends Specification {$/;"	o
Sql	Anorm.scala	/^object Sql {$/;"	o
Sql	Anorm.scala	/^trait Sql {$/;"	t
SqlMappingError	Anorm.scala	/^case class SqlMappingError(msg: String) extends SqlRequestError$/;"	r
SqlParser	SqlParser.scala	/^object SqlParser {$/;"	o
SqlParser.ResultSet	SqlParser.scala	/^import SqlParser.ResultSet$/;"	i
SqlParser._	Anorm.scala	/^  import SqlParser._$/;"	i
SqlParser._	Anorm.scala	/^import SqlParser._$/;"	i
SqlQuery	Anorm.scala	/^case class SqlQuery(query: String, argsInitialOrder: List[String] = List.empty, queryTimeout: Option[Int] = None) extends Sql {$/;"	r
SqlRequestError	Anorm.scala	/^abstract class SqlRequestError$/;"	a
SqlResult	SqlParser.scala	/^trait SqlResult[+A] {$/;"	t
SqlRow	Anorm.scala	/^case class SqlRow(metaData: MetaData, data: List[Any]) extends Row {$/;"	r
SqlStatementParser	SqlStatementParser.scala	/^object SqlStatementParser extends JavaTokenParsers {$/;"	o
StaticApplication	ApplicationProvider.scala	/^class StaticApplication(applicationPath: File) extends ApplicationProvider {$/;"	c
StaticPart	PathParts.scala	/^case class StaticPart(value: String) extends PathPart {$/;"	r
StaticPart	Router.scala	/^case class StaticPart(value: String) extends PathPart {$/;"	r
Status	Results.scala	/^  class Status(status: Int) extends SimpleResult[Results.EmptyContent](header = ResponseHeader(status), body = Enumerator(Results.EmptyContent())) {$/;"	c
Status	Results.scala	/^  def Status(code: Int) = new Status(code)$/;"	m
Status	StandardValues.scala	/^object Status extends Status$/;"	o
Status	StandardValues.scala	/^trait Status {$/;"	t
Step	Iteratee.scala	/^object Step {$/;"	o
Success	SqlParser.scala	/^case class Success[A](a: A) extends SqlResult[A]$/;"	r
TE	StandardValues.scala	/^  val TE = "Te"$/;"	V
TEMPORARY_REDIRECT	StandardValues.scala	/^  val TEMPORARY_REDIRECT = 307$/;"	V
TEXT	StandardValues.scala	/^  def TEXT(implicit codec: Codec) = withCharset(MimeTypes.TEXT)$/;"	m
TEXT	StandardValues.scala	/^  val TEXT = "text\/plain"$/;"	V
TODO	Controller.scala	/^  val TODO = Action {$/;"	V
TOKEN_NAME	csrf.scala	/^      def TOKEN_NAME: String = c.getString("csrf.token.name").getOrElse("csrfToken")$/;"	m
TOO_MANY_REQUEST	StandardValues.scala	/^  val TOO_MANY_REQUEST = 429$/;"	V
TRAILER	StandardValues.scala	/^  val TRAILER = "Trailer"$/;"	V
TRANSFER_ENCODING	StandardValues.scala	/^  val TRANSFER_ENCODING = "Transfer-Encoding"$/;"	V
Task	Task.scala	/^class Task {$/;"	c
Template	ScalaTemplateCompiler.scala	/^    case class Template(name: PosString, comment: Option[Comment], params: PosString, imports: Seq[Simple], defs: Seq[Def], sub: Seq[Template], content: Seq[TemplateTree]) extends Positional$/;"	r
Template0	FakeRuntime.scala	/^  trait Template0[Result] { def render(): Result }$/;"	t
Template0	ScalaTemplate.scala	/^  trait Template0[Result] { def render(): Result }$/;"	t
Template1	FakeRuntime.scala	/^  trait Template1[A, Result] { def render(a: A): Result }$/;"	t
Template1	ScalaTemplate.scala	/^  trait Template1[A, Result] { def render(a: A): Result }$/;"	t
Template10	FakeRuntime.scala	/^  trait Template10[A, B, C, D, E, F, G, H, I, J, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J): Result }$/;"	t
Template10	ScalaTemplate.scala	/^  trait Template10[A, B, C, D, E, F, G, H, I, J, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J): Result }$/;"	t
Template11	FakeRuntime.scala	/^  trait Template11[A, B, C, D, E, F, G, H, I, J, K, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K): Result }$/;"	t
Template11	ScalaTemplate.scala	/^  trait Template11[A, B, C, D, E, F, G, H, I, J, K, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K): Result }$/;"	t
Template12	FakeRuntime.scala	/^  trait Template12[A, B, C, D, E, F, G, H, I, J, K, L, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L): Result }$/;"	t
Template12	ScalaTemplate.scala	/^  trait Template12[A, B, C, D, E, F, G, H, I, J, K, L, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L): Result }$/;"	t
Template13	FakeRuntime.scala	/^  trait Template13[A, B, C, D, E, F, G, H, I, J, K, L, M, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M): Result }$/;"	t
Template13	ScalaTemplate.scala	/^  trait Template13[A, B, C, D, E, F, G, H, I, J, K, L, M, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M): Result }$/;"	t
Template14	FakeRuntime.scala	/^  trait Template14[A, B, C, D, E, F, G, H, I, J, K, L, M, N, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N): Result }$/;"	t
Template14	ScalaTemplate.scala	/^  trait Template14[A, B, C, D, E, F, G, H, I, J, K, L, M, N, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N): Result }$/;"	t
Template15	FakeRuntime.scala	/^  trait Template15[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O): Result }$/;"	t
Template15	ScalaTemplate.scala	/^  trait Template15[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O): Result }$/;"	t
Template16	FakeRuntime.scala	/^  trait Template16[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P): Result }$/;"	t
Template16	ScalaTemplate.scala	/^  trait Template16[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P): Result }$/;"	t
Template17	FakeRuntime.scala	/^  trait Template17[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q): Result }$/;"	t
Template17	ScalaTemplate.scala	/^  trait Template17[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q): Result }$/;"	t
Template18	FakeRuntime.scala	/^  trait Template18[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q, r: R): Result }$/;"	t
Template18	ScalaTemplate.scala	/^  trait Template18[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q, r: R): Result }$/;"	t
Template19	FakeRuntime.scala	/^  trait Template19[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q, r: R, s: S): Result }$/;"	t
Template19	ScalaTemplate.scala	/^  trait Template19[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q, r: R, s: S): Result }$/;"	t
Template2	FakeRuntime.scala	/^  trait Template2[A, B, Result] { def render(a: A, b: B): Result }$/;"	t
Template2	ScalaTemplate.scala	/^  trait Template2[A, B, Result] { def render(a: A, b: B): Result }$/;"	t
Template20	FakeRuntime.scala	/^  trait Template20[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q, r: R, s: S, t: T): Result }$/;"	t
Template20	ScalaTemplate.scala	/^  trait Template20[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q, r: R, s: S, t: T): Result }$/;"	t
Template21	FakeRuntime.scala	/^  trait Template21[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q, r: R, s: S, t: T, u: U): Result }$/;"	t
Template21	ScalaTemplate.scala	/^  trait Template21[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q, r: R, s: S, t: T, u: U): Result }$/;"	t
Template22	FakeRuntime.scala	/^  trait Template22[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q, r: R, s: S, t: T, u: U, v: V): Result }$/;"	t
Template22	ScalaTemplate.scala	/^  trait Template22[A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, k: K, l: L, m: M, n: N, o: O, p: P, q: Q, r: R, s: S, t: T, u: U, v: V): Result }$/;"	t
Template3	FakeRuntime.scala	/^  trait Template3[A, B, C, Result] { def render(a: A, b: B, c: C): Result }$/;"	t
Template3	ScalaTemplate.scala	/^  trait Template3[A, B, C, Result] { def render(a: A, b: B, c: C): Result }$/;"	t
Template4	FakeRuntime.scala	/^  trait Template4[A, B, C, D, Result] { def render(a: A, b: B, c: C, d: D): Result }$/;"	t
Template4	ScalaTemplate.scala	/^  trait Template4[A, B, C, D, Result] { def render(a: A, b: B, c: C, d: D): Result }$/;"	t
Template5	FakeRuntime.scala	/^  trait Template5[A, B, C, D, E, Result] { def render(a: A, b: B, c: C, d: D, e: E): Result }$/;"	t
Template5	ScalaTemplate.scala	/^  trait Template5[A, B, C, D, E, Result] { def render(a: A, b: B, c: C, d: D, e: E): Result }$/;"	t
Template6	FakeRuntime.scala	/^  trait Template6[A, B, C, D, E, F, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F): Result }$/;"	t
Template6	ScalaTemplate.scala	/^  trait Template6[A, B, C, D, E, F, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F): Result }$/;"	t
Template7	FakeRuntime.scala	/^  trait Template7[A, B, C, D, E, F, G, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G): Result }$/;"	t
Template7	ScalaTemplate.scala	/^  trait Template7[A, B, C, D, E, F, G, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G): Result }$/;"	t
Template8	FakeRuntime.scala	/^  trait Template8[A, B, C, D, E, F, G, H, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H): Result }$/;"	t
Template8	ScalaTemplate.scala	/^  trait Template8[A, B, C, D, E, F, G, H, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H): Result }$/;"	t
Template9	FakeRuntime.scala	/^  trait Template9[A, B, C, D, E, F, G, H, I, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I): Result }$/;"	t
Template9	ScalaTemplate.scala	/^  trait Template9[A, B, C, D, E, F, G, H, I, Result] { def render(a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I): Result }$/;"	t
TemplateAsFunctionCompiler	ScalaTemplateCompiler.scala	/^    object TemplateAsFunctionCompiler {$/;"	o
TemplateCompilationError	ScalaTemplateCompiler.scala	/^  case class TemplateCompilationError(source: File, message: String, line: Int, column: Int) extends RuntimeException(message)$/;"	r
TemplateCompilationException	PlayExceptions.scala	/^  case class TemplateCompilationException(source: File, message: String, atLine: Int, column: Int) extends PlayException.ExceptionSource($/;"	r
TemplateCompilerSpec	TemplateCompilerSpec.scala	/^object TemplateCompilerSpec extends Specification {$/;"	o
TemplateMagic	FakeRuntime.scala	/^  object TemplateMagic {$/;"	o
TemplateMagic	ScalaTemplate.scala	/^  object TemplateMagic {$/;"	o
TemplateParser	ScalaTemplateCompiler.scala	/^    class TemplateParser extends JavaTokenParsers {$/;"	c
TemplateParserSpec	TemplateParserSpec.scala	/^object TemplateParserSpec extends Specification {$/;"	o
TemplateTree	ScalaTemplateCompiler.scala	/^    abstract class TemplateTree$/;"	a
TemplateUtilsSpec	TemplateUtilsSpec.scala	/^object TemplateUtilsSpec extends Specification {$/;"	o
TemplatesSpec	TemplatesSpec.scala	/^object TemplatesSpec extends Specification {$/;"	o
TemporaryFile	Files.scala	/^  case class TemporaryFile(file: File) {$/;"	r
TemporaryFile	Files.scala	/^  object TemporaryFile {$/;"	o
TemporaryRedirect	Results.scala	/^  def TemporaryRedirect(url: String): SimpleResult[Results.EmptyContent] = Redirect(url, TEMPORARY_REDIRECT)$/;"	m
Test	JsonValidSpec.scala	/^      case class Test(field: String)$/;"	r
TestApplication	ApplicationProvider.scala	/^class TestApplication(application: Application) extends ApplicationProvider {$/;"	c
TestBrowser	Selenium.scala	/^case class TestBrowser(webDriver: WebDriver, baseUrl: Option[String]) extends FluentAdapter(webDriver) {$/;"	r
TestBrowser	Selenium.scala	/^object TestBrowser {$/;"	o
TestServer	Selenium.scala	/^case class TestServer(port: Int, application: FakeApplication = FakeApplication(), sslPort: Option[Int] = None) {$/;"	r
TestSuite	JUnitXmlTestListener.scala	/^  class TestSuite(val name: String) {$/;"	c
Text	TemplateUtilsSpec.scala	/^        case class Text(text: String) extends Appendable[Text] {$/;"	r
TextFormat	TemplateUtilsSpec.scala	/^        object TextFormat extends Format[Text] {$/;"	o
Threads	Threads.scala	/^object Threads {$/;"	o
ThreadsSpec	ThreadsSpec.scala	/^object ThreadsSpec extends Specification {$/;"	o
Thrown	Promise.scala	/^case class Thrown(e: scala.Throwable) extends NotWaiting[Nothing]$/;"	r
ToStatement	Anorm.scala	/^object ToStatement {$/;"	o
ToStatement	Anorm.scala	/^trait ToStatement[A] { def set(s: java.sql.PreparedStatement, index: Int, aValue: A): Unit }$/;"	t
Token	csrf.scala	/^    case class Token(value: String)$/;"	r
Token	csrf.scala	/^    object Token {$/;"	o
TooManyRequest	Results.scala	/^  val TooManyRequest = new Status(TOO_MANY_REQUEST)$/;"	V
Toto	JsonExtensionSpec.scala	/^case class Toto(name: String)$/;"	r
Traversable	TraversableIteratee.scala	/^object Traversable {$/;"	o
TreatCont0	Enumerator.scala	/^  trait TreatCont0[E]{$/;"	t
TreatCont1	Enumerator.scala	/^  trait TreatCont1[E,S]{$/;"	t
Tree	ScalaTemplateCompiler.scala	/^        type Tree = PresentationCompiler.global.Tree$/;"	T
TreeCreationMethods	ScalaTemplateCompiler.scala	/^      trait TreeCreationMethods {$/;"	t
TupleFlattener	Anorm.scala	/^case class TupleFlattener[F](f: F)$/;"	r
TupleFlattener	Anorm.scala	/^object TupleFlattener extends PriorityNine {$/;"	o
TupleReads	JsonValidSpec.scala	/^      implicit val TupleReads: Reads[(String, JsObject)] = ($/;"	V
Txt	Templates.scala	/^class Txt(text: String) extends Appendable[Txt] with Content with play.mvc.Content {$/;"	c
Txt	Templates.scala	/^object Txt {$/;"	o
TxtFormat	Templates.scala	/^object TxtFormat extends Format[Txt] {$/;"	o
TypeDef	ScalaTemplateCompiler.scala	/^        type TypeDef = PresentationCompiler.global.TypeDef$/;"	T
TypeDoesNotMatch	Anorm.scala	/^case class TypeDoesNotMatch(message: String) extends SqlRequestError$/;"	r
UNAUTHORIZED	StandardValues.scala	/^  val UNAUTHORIZED = 401$/;"	V
UNKNOWN	Evolutions.scala	/^    val UNKNOWN = "UNKNOWN"$/;"	V
UNLIMITED	ContentTypes.scala	/^    val UNLIMITED: Int = Integer.MAX_VALUE$/;"	V
UNPROCESSABLE_ENTITY	StandardValues.scala	/^  val UNPROCESSABLE_ENTITY = 422$/;"	V
UNSAFE_METHOD	csrf.scala	/^      def UNSAFE_METHOD = c.getStringList("csrf.unsafe.methods").map(_.asScala).getOrElse(List("POST")).mkString("|").r$/;"	m
UNSUPPORTED_MEDIA_TYPE	StandardValues.scala	/^  val UNSUPPORTED_MEDIA_TYPE = 415$/;"	V
UPGRADE	StandardValues.scala	/^  val UPGRADE = "Upgrade"$/;"	V
UPS	Evolutions.scala	/^    val UPS = "UPS"$/;"	V
USER_AGENT	StandardValues.scala	/^  val USER_AGENT = "User-Agent"$/;"	V
USE_PROXY	StandardValues.scala	/^  val USE_PROXY = 305$/;"	V
Unauthorized	Results.scala	/^  val Unauthorized = new Status(UNAUTHORIZED)$/;"	V
UndefinedMeta	ScalaTemplateCompiler.scala	/^      val UndefinedMeta = """([A-Z]+):""".r$/;"	V
UnexpectedException	Exceptions.scala	/^case class UnexpectedException(message: Option[String] = None, unexpected: Option[Throwable] = None) extends PlayException($/;"	r
UnexpectedException	PlayExceptions.scala	/^  case class UnexpectedException(message: Option[String] = None, unexpected: Option[Throwable] = None) extends PlayException($/;"	r
UnexpectedNullableFound	Anorm.scala	/^case class UnexpectedNullableFound(on: String) extends SqlRequestError$/;"	r
Unmatched	Iteratee.scala	/^  case class Unmatched[A](val content: A) extends MatchInfo[A]$/;"	r
UnprocessableEntity	Results.scala	/^  val UnprocessableEntity = new Status(UNPROCESSABLE_ENTITY)$/;"	V
UnsupportedMediaType	Results.scala	/^  val UnsupportedMediaType = new Status(UNSUPPORTED_MEDIA_TYPE)$/;"	V
UriTooLong	Results.scala	/^  val UriTooLong = new Status(REQUEST_URI_TOO_LONG)$/;"	V
UrlIdentifier	OpenID.scala	/^  case class UrlIdentifier(url: String) {$/;"	r
Useful	Anorm.scala	/^object Useful {$/;"	o
User	FormSpec.scala	/^   case class User(name: String, age: Int)$/;"	r
User	JsonExtensionSpec.scala	/^case class User(age: Int, name: String)$/;"	r
User	JsonSpec.scala	/^  case class User(id: Long, name: String, friends: List[User])$/;"	r
User	JsonValidSpec.scala	/^      case class User(email: String, phone: Option[String])$/;"	r
User	JsonValidSpec.scala	/^      case class User(id: Long, email: String, age: Int)$/;"	r
User	JsonValidSpec.scala	/^      case class User(id: Long, name: String, friend: Option[User] = None)$/;"	r
User	JsonValidSpec.scala	/^      case class User(name: String, email: String, phone: Option[String])$/;"	r
User	JsonValidSpec.scala	/^    case class User(name: String, age: Int)$/;"	r
User1	JsonExtensionSpec.scala	/^case class User1(name: String, friend: Option[User1] = None)$/;"	r
UserFail	JsonExtensionSpec.scala	/^case class UserFail(name: String, bd: Toto)$/;"	r
UserFormat	JsonSpec.scala	/^  implicit val UserFormat: Format[User] = ($/;"	V
UserFormat	JsonValidSpec.scala	/^      implicit val UserFormat = ($/;"	V
UserFormats	JsonValidSpec.scala	/^      implicit lazy val UserFormats: Format[User] = ($/;"	V
UserInfo	OpenID.scala	/^case class UserInfo(id: String, attributes: Map[String, String] = Map.empty)$/;"	r
UserInfo	OpenID.scala	/^object UserInfo {$/;"	o
UserInfoSpec	UserInfoSpec.scala	/^object UserInfoSpec extends Specification {$/;"	o
UserMap	JsonExtensionSpec.scala	/^case class UserMap(name: String, friends: Map[String, UserMap] = Map())$/;"	r
UserReads	JsPath.scala	/^    * implicit lazy val UserReads: Reads[User] = ($/;"	V
UserReads	JsonValidSpec.scala	/^      implicit lazy val UserReads: Reads[User] = ($/;"	V
UserReads	JsonValidSpec.scala	/^      implicit val UserReads = ($/;"	V
UserWrites	JsonValidSpec.scala	/^      implicit lazy val UserWrites: Writes[User] = ($/;"	V
UserWrites	JsonValidSpec.scala	/^      implicit val UserWrites = ($/;"	V
VARY	StandardValues.scala	/^  val VARY = "Vary"$/;"	V
VIA	StandardValues.scala	/^  val VIA = "Via"$/;"	V
ValidationError	Validation.scala	/^case class ValidationError(message: String, args: Any*)$/;"	r
ValidationSpec	ValidationSpec.scala	/^object ValidationSpec extends Specification {$/;"	o
Value	ScalaTemplateCompiler.scala	/^    case class Value(ident: PosString, block: Block) extends Positional$/;"	r
Var	Anorm.scala	/^  case class Var[T](var content: T)$/;"	r
WARNING	StandardValues.scala	/^  val WARNING = "Warning"$/;"	V
WS	WS.scala	/^object WS {$/;"	o
WSMock	WsMock.scala	/^class WSMock extends Mockito {$/;"	c
WSRequest	WS.scala	/^  class WSRequest(_method: String, _auth: Option[Tuple3[String, String, AuthScheme]], _calc: Option[SignatureCalculator]) extends RequestBuilderBase[WSRequest](classOf[WSRequest], _method, false) {$/;"	c
WSRequestAdapter	OAuth.scala	/^  class WSRequestAdapter(request: WSRequest) extends HttpRequest {$/;"	c
WSRequestHolder	WS.scala	/^  case class WSRequestHolder(url: String,$/;"	r
WSSpec	WSSpec.scala	/^object WSSpec extends Specification {$/;"	o
WWW_AUTHENTICATE	StandardValues.scala	/^  val WWW_AUTHENTICATE = "WWW-Authenticate"$/;"	V
Waiting	Concurrent.scala	/^      case class Waiting(p: scala.concurrent.Promise[Input[E]]) extends State$/;"	r
WebDriverFactory	Selenium.scala	/^object WebDriverFactory {$/;"	o
WebSocket	WebSocket.scala	/^case class WebSocket[A](f: RequestHeader => (Enumerator[A], Iteratee[A, Unit]) => Unit)(implicit val frameFormatter: WebSocket.FrameFormatter[A]) extends Handler {$/;"	r
WebSocket	WebSocket.scala	/^object WebSocket {$/;"	o
WebSocketHandshake	WebSocketHandshake.scala	/^object WebSocketHandshake {$/;"	o
WebSocketable	Server.scala	/^trait WebSocketable {$/;"	t
WithApplication	ResultsSpec.scala	/^  abstract class WithApplication(config: (String, Any)*) extends Around with Scope {$/;"	a
WithApplication	Specs.scala	/^abstract class WithApplication(val app: FakeApplication = FakeApplication()) extends Around with Scope {$/;"	a
WithBrowser	Specs.scala	/^abstract class WithBrowser[WEBDRIVER <: WebDriver]($/;"	a
WithDefaultConfiguration	Application.scala	/^trait WithDefaultConfiguration {$/;"	t
WithDefaultGlobal	Application.scala	/^trait WithDefaultGlobal {$/;"	t
WithDefaultPlugins	Application.scala	/^trait WithDefaultPlugins {$/;"	t
WithFilters	Filters.scala	/^class WithFilters(filters: EssentialFilter*) extends GlobalSettings {$/;"	c
WithFooDomain	ResultsSpec.scala	/^  abstract class WithFooDomain extends WithApplication("session.domain" -> ".foo.com")$/;"	a
WithFooPath	ResultsSpec.scala	/^  abstract class WithFooPath extends WithApplication("application.context" -> "\/foo")$/;"	a
WithSecureSession	ResultsSpec.scala	/^  abstract class WithSecureSession extends WithApplication("session.secure" -> true)$/;"	a
WithServer	Specs.scala	/^abstract class WithServer(val app: FakeApplication = FakeApplication(),$/;"	a
WrappedMapping	Form.scala	/^case class WrappedMapping[A, B](wrapped: Mapping[A], f1: A => B, f2: B => A, val additionalConstraints: Seq[Constraint[B]] = Nil) extends Mapping[B] {$/;"	r
WrappedRequest	Http.scala	/^  class WrappedRequest[A](request: Request[A]) extends Request[A] {$/;"	c
Writeable	Writeable.scala	/^case class Writeable[-A](transform: (A => Array[Byte]), contentType: Option[String]) {$/;"	r
Writeable	Writeable.scala	/^object Writeable extends DefaultWriteables {$/;"	o
Writes	Writes.scala	/^object Writes extends PathWrites with ConstraintWrites with DefaultWrites {$/;"	o
Writes	Writes.scala	/^trait Writes[-A] {$/;"	t
Writes._	JsonSpec.scala	/^      import Writes._$/;"	i
Writes._	JsonValidSpec.scala	/^      import Writes._$/;"	i
Writes.constraints._	JsonValidSpec.scala	/^      import Writes.constraints._$/;"	i
XML	StandardValues.scala	/^  def XML(implicit codec: Codec) = withCharset(MimeTypes.XML)$/;"	m
XML	StandardValues.scala	/^  val XML = "text\/xml"$/;"	V
X_FORWARDED_FOR	StandardValues.scala	/^  val X_FORWARDED_FOR = "X-Forwarded-For"$/;"	V
X_FORWARDED_HOST	StandardValues.scala	/^  val X_FORWARDED_HOST = "X-Forwarded-Host"$/;"	V
X_FORWARDED_PORT	StandardValues.scala	/^  val X_FORWARDED_PORT = "X-Forwarded-Port"$/;"	V
X_FORWARDED_PROTO	StandardValues.scala	/^  val X_FORWARDED_PROTO = "X-Forwarded-Proto"$/;"	V
Xml	RequestExtractors.scala	/^    val Xml = Accepting(MimeTypes.XML)$/;"	V
Xml	Templates.scala	/^class Xml(text: String) extends Appendable[Xml] with Content with play.mvc.Content {$/;"	c
Xml	Templates.scala	/^object Xml {$/;"	o
XmlFormat	Templates.scala	/^object XmlFormat extends Format[Xml] {$/;"	o
XrdsResolver	OpenID.scala	/^  class XrdsResolver extends Resolver {$/;"	c
_changed	PlayReloader.scala	/^          var _changed = true$/;"	v
_content	ScalaTemplateCompiler.scala	/^    var _content = ""$/;"	v
_currentApp	Play.scala	/^  private[play] var _currentApp: Application = _$/;"	v
_display_	FakeRuntime.scala	/^    def _display_(o: Any)(implicit m: Manifest[T]): T = {$/;"	m
_display_	ScalaTemplate.scala	/^    def _display_(o: Any)(implicit ct: ClassTag[T]): T = {$/;"	m
_nS	Routes.scala	/^             |var _nS = function(c,f,b){var e=c.split(f||"."),g=b||_root,d,a;for(d=0,a=e.length;d<a;d++){g=g[e[d]]=g[e[d]]||{}}return g}$/;"	v
_prefix	RoutesCompiler.scala	/^            |private var _prefix = "\/"$/;"	v
_qS	Routes.scala	/^             |var _qS = function(items){var qs = ''; for(var i=0;i<items.length;i++) {if(items[i]) qs += (qs ? '&' : '') + items[i]}; return qs ? ('?' + qs) : ''}$/;"	v
_render	Render.scala	/^    def _render(ms: Seq[MediaRange]): Result = ms match {$/;"	m
_root_.oauth.signpost.basic.DefaultOAuthConsumer	OAuth.scala	/^import _root_.oauth.signpost.basic.DefaultOAuthConsumer$/;"	i
_root_.oauth.signpost.commonshttp.CommonsHttpOAuthProvider	OAuth.scala	/^import _root_.oauth.signpost.commonshttp.CommonsHttpOAuthProvider$/;"	i
_root_.oauth.signpost.exception.OAuthException	OAuth.scala	/^import _root_.oauth.signpost.exception.OAuthException$/;"	i
_root_.oauth.signpost.http.HttpRequest	OAuth.scala	/^  import _root_.oauth.signpost.http.HttpRequest$/;"	i
_root_.oauth.signpost.{ OAuthConsumer, AbstractOAuthConsumer }	OAuth.scala	/^import _root_.oauth.signpost.{ OAuthConsumer, AbstractOAuthConsumer }$/;"	i
_root_.oauth.signpost.{ OAuthConsumer, OAuthProvider }	OAuth.scala	/^import _root_.oauth.signpost.{ OAuthConsumer, OAuthProvider }$/;"	i
_root_.sbt._	JUnitXmlTestListener.scala	/^import _root_.sbt._$/;"	i
_s	Routes.scala	/^             |var _s = function(p,s){return p+((s===true||(s&&s.secure))?'s':'')+':\/\/'}$/;"	v
_url	WS.scala	/^    protected var _url: String = null$/;"	v
_wA	Routes.scala	/^             |var _wA = function(r){return {%s method:r.method,url:r.url,absoluteURL: function(s){return _s('http',s)+'%s'+r.url},webSocketURL: function(s){return _s('ws',s)+'%s'+r.url}}}$/;"	v
a	ConcurrentSpec.scala	/^      val a = "FOO"$/;"	V
a	EnumeratorsSpec.scala	/^    val a = "FOO"$/;"	V
a	EnumeratorsSpec.scala	/^    val a = (0 to 10).toList$/;"	V
a	PlayDefaultUpstreamHandler.scala	/^            val a = EssentialAction(_ => Done(Results.BadRequest,Input.Empty))$/;"	V
a	PlayDefaultUpstreamHandler.scala	/^            val a = EssentialAction(_ => Done(e,Input.Empty))$/;"	V
a	PlayDefaultUpstreamHandler.scala	/^            val a = EssentialAction{ rh =>$/;"	V
a1	Form.scala	/^      val a1 = field1.unbind(v1)$/;"	V
a1	ObjectMappings.scala	/^      val a1 = field1.unbind(v1)$/;"	V
a10	ObjectMappings.scala	/^      val a10 = field10.unbind(v10)$/;"	V
a11	ObjectMappings.scala	/^      val a11 = field11.unbind(v11)$/;"	V
a12	ObjectMappings.scala	/^      val a12 = field12.unbind(v12)$/;"	V
a13	ObjectMappings.scala	/^      val a13 = field13.unbind(v13)$/;"	V
a14	ObjectMappings.scala	/^      val a14 = field14.unbind(v14)$/;"	V
a15	ObjectMappings.scala	/^      val a15 = field15.unbind(v15)$/;"	V
a16	ObjectMappings.scala	/^      val a16 = field16.unbind(v16)$/;"	V
a17	ObjectMappings.scala	/^      val a17 = field17.unbind(v17)$/;"	V
a18	ObjectMappings.scala	/^      val a18 = field18.unbind(v18)$/;"	V
a2	ObjectMappings.scala	/^      val a2 = field2.unbind(v2)$/;"	V
a3	ObjectMappings.scala	/^      val a3 = field3.unbind(v3)$/;"	V
a4	ObjectMappings.scala	/^      val a4 = field4.unbind(v4)$/;"	V
a5	ObjectMappings.scala	/^      val a5 = field5.unbind(v5)$/;"	V
a6	ObjectMappings.scala	/^      val a6 = field6.unbind(v6)$/;"	V
a7	ObjectMappings.scala	/^      val a7 = field7.unbind(v7)$/;"	V
a8	ObjectMappings.scala	/^      val a8 = field8.unbind(v8)$/;"	V
a9	ObjectMappings.scala	/^      val a9 = field9.unbind(v9)$/;"	V
abort	DB.scala	/^  def abort(executor: java.util.concurrent.Executor) {$/;"	m
absoluteMethod	RoutesCompiler.scala	/^    def absoluteMethod: Parser[List[String]] = namedError(javaIdent ~ "." ~ javaIdent ~ "." ~ rep1sep(javaIdent, ".") ^^ {$/;"	m
absoluteURL	Http.scala	/^    def absoluteURL(secure: Boolean = false)(implicit request: RequestHeader) = {$/;"	m
accept	FormSpec.scala	/^  def accept = List("text\/html").asJava$/;"	m
accept	Http.scala	/^    lazy val accept: Seq[String] = {$/;"	V
accept	JavaHelpers.scala	/^      def accept = req.accept.asJava$/;"	m
acceptLanguages	FormSpec.scala	/^  def acceptLanguages = new java.util.ArrayList[play.i18n.Lang]$/;"	m
acceptLanguages	Http.scala	/^    lazy val acceptLanguages: Seq[play.api.i18n.Lang] = {$/;"	V
acceptLanguages	JavaHelpers.scala	/^      def acceptLanguages = req.acceptLanguages.map(new play.i18n.Lang(_)).asJava$/;"	m
acceptedTypes	FormSpec.scala	/^  def acceptedTypes = List(play.api.http.MediaRange("text\/html")).asJava$/;"	m
acceptedTypes	Http.scala	/^    lazy val acceptedTypes: Seq[play.api.http.MediaRange] = {$/;"	V
acceptedTypes	JavaHelpers.scala	/^      def acceptedTypes = req.acceptedTypes.asJava$/;"	m
accepts	FormSpec.scala	/^  def accepts(mediaType: String) = false$/;"	m
accepts	Http.scala	/^    def accepts(mimeType: String): Boolean = {$/;"	m
accepts	JavaHelpers.scala	/^      def accepts(mediaType: String) = req.accepts(mediaType)$/;"	m
accepts	MediaRange.scala	/^  def accepts(mimeType: String): Boolean =$/;"	m
acceptsURL	ProxyDriver.scala	/^  def acceptsURL(url: String) = proxied.acceptsURL(url)$/;"	m
action	Helpers.scala	/^        val action = a.asInstanceOf[Action[T]]$/;"	V
action	JavaAction.scala	/^          val action = global.underlying.onRequest(javaContext.request, method)$/;"	V
action	JavaAction.scala	/^        val action = global.getControllerInstance(actionClass).asInstanceOf[play.mvc.Action[Object]]$/;"	V
actionMixins	JavaAction.scala	/^    val actionMixins = {$/;"	V
actualAlgorithm	FakeKeyStore.scala	/^    val actualAlgorithm = cert.get(X509CertImpl.SIG_ALG).asInstanceOf[AlgorithmId]$/;"	V
adapter	WebSocket.scala	/^  def adapter[A](f: RequestHeader => Enumeratee[A, A])(implicit frameFormatter: FrameFormatter[A]): WebSocket[A] = {$/;"	m
add1AndConsume	EnumerateesSpec.scala	/^      val add1AndConsume = Enumeratee.map[Int](i => List(i+1)) &>>  Iteratee.consume()$/;"	V
add1AndConsume	EnumerateesSpec.scala	/^      val add1AndConsume = Enumeratee.map[Int](i => i+1) ><> Enumeratee.map(i => List(i)) &>>  Iteratee.consume()$/;"	V
addBatch	Anorm.scala	/^  def addBatch(args: (String, ParameterValue[_])*): BatchSql = this.copy(params = (this.params) :+ args)$/;"	m
addBatchList	Anorm.scala	/^  def addBatchList(paramsMapList: TraversableOnce[Seq[(String, ParameterValue[_])]]): BatchSql = this.copy(params = (this.params) ++ paramsMapList)$/;"	m
addBatchParams	Anorm.scala	/^  def addBatchParams(args: ParameterValue[_]*): BatchSql = this.copy(params = (this.params) :+ sql.argsInitialOrder.zip(args))$/;"	m
addBatchParamsList	Anorm.scala	/^  def addBatchParamsList(paramsSeqList: TraversableOnce[Seq[ParameterValue[_]]]): BatchSql = this.copy(params = (this.params) ++ paramsSeqList.map(paramsSeq => sql.argsInitialOrder.zip(paramsSeq)))$/;"	m
addClassesManaged	PlayEclipse.scala	/^    lazy val addClassesManaged = new EclipseTransformerFactory[RewriteRule] {$/;"	V
addCookieToken	csrf.scala	/^       def addCookieToken(c: String): PlainResult = {$/;"	m
addCookieToken	csrf.scala	/^      def addCookieToken(c: String) = request.cookies.get(c)$/;"	m
addDefaultPropertiesIfNeeded	DB.scala	/^        val addDefaultPropertiesIfNeeded = MysqlCustomProperties.findFirstMatchIn(url).map(_ => "").getOrElse(defaultProperties)$/;"	V
addEvent	JUnitXmlTestListener.scala	/^    def addEvent(e: TEvent) = {$/;"	m
addJavaBuilder	PlayEclipse.scala	/^    lazy val addJavaBuilder = new EclipseTransformerFactory[RewriteRule] {$/;"	V
addOne	EnumerateesSpec.scala	/^      val addOne = Enumerator(1,2,3,4) &> Enumeratee.map(i => i+1) $/;"	V
addRequestToken	csrf.scala	/^    def addRequestToken(request: RequestHeader, token: Token): RequestHeader = {$/;"	m
addResponseToken	csrf.scala	/^    def addResponseToken(req: RequestHeader, r: PlainResult, token: Token): PlainResult = {$/;"	m
addResponseToken	csrf.scala	/^    def addResponseToken(req: RequestHeader, res: Result, token: Token): Result = res match {$/;"	m
addScalaLib	PlayEclipse.scala	/^    lazy val addScalaLib = new EclipseTransformerFactory[RewriteRule] {$/;"	V
addSessionToken	csrf.scala	/^       def addSessionToken: PlainResult = {$/;"	m
addSessionToken	csrf.scala	/^      def addSessionToken = request.session.get(TOKEN_NAME)$/;"	m
addSourcesManaged	PlayEclipse.scala	/^    lazy val addSourcesManaged = new EclipseTransformerFactory[RewriteRule] {$/;"	V
addValue	JsValue.scala	/^  def addValue(value: JsValue): DeserializerContext = ReadingMap(content :+ (fieldName -> value))$/;"	m
addValue	JsValue.scala	/^  def addValue(value: JsValue): DeserializerContext = throw new Exception("Cannot add a value on an object without a key, malformed JSON object!")$/;"	m
addValue	JsValue.scala	/^  def addValue(value: JsValue): DeserializerContext$/;"	m
addWatch	PlayReloader.scala	/^              def addWatch(directoryToWatch: String): Int = 0$/;"	m
addWatch	PlayReloader.scala	/^            def addWatch(directoryToWatch: String): Int = {$/;"	m
addWatchMethod	PlayReloader.scala	/^          val addWatchMethod = jnotifyClass.getMethod("addWatch", classOf[String], classOf[Int], classOf[Boolean], jnotifyListenerClass)$/;"	V
additionalClassPathEntry	ScalaTemplateCompiler.scala	/^        def additionalClassPathEntry: Option[String] = None$/;"	m
additionalClassPathEntry	TemplateCompilerSpec.scala	/^      def additionalClassPathEntry: Option[String] = Some($/;"	m
additionalConfiguration	Fakes.scala	/^    val additionalConfiguration: Map[String, _ <: Any] = Map.empty,$/;"	V
additionalConstraints	Form.scala	/^case class WrappedMapping[A, B](wrapped: Mapping[A], f1: A => B, f2: B => A, val additionalConstraints: Seq[Constraint[B]] = Nil) extends Mapping[B] {$/;"	V
additionalPlugins	Fakes.scala	/^    val additionalPlugins: Seq[String] = Nil,$/;"	V
additionalText	MimeTypes.scala	/^    lazy val additionalText =$/;"	V
akka.actor.Actor._	Server.scala	/^import akka.actor.Actor._$/;"	i
akka.actor.ActorSystem	Akka.scala	/^import akka.actor.ActorSystem$/;"	i
akka.actor._	Invoker.scala	/^import akka.actor._$/;"	i
akka.actor._	Server.scala	/^import akka.actor._$/;"	i
akka.pattern.Patterns.ask	Server.scala	/^import akka.pattern.Patterns.ask$/;"	i
akka.routing._	Server.scala	/^import akka.routing._$/;"	i
akka.util.Timeout	Server.scala	/^import akka.util.Timeout$/;"	i
akkaAsk	JavaPromise.scala	/^  def akkaAsk (actor: akka.actor.ActorRef, message: Any, timeout: akka.util.Timeout): scala.concurrent.Future[AnyRef] =$/;"	m
akkaFuture	JavaPromise.scala	/^  def akkaFuture[T](callable: java.util.concurrent.Callable[T]) = play.libs.Akka.asPromise(akka.dispatch.Futures.future(callable, play.libs.Akka.system.dispatcher))$/;"	m
algorithm	FakeKeyStore.scala	/^    val algorithm = new AlgorithmId(AlgorithmId.sha1WithRSAEncryption_oid)$/;"	V
algorithm	NettyServer.scala	/^        val algorithm = System.getProperty("https.keyStoreAlgorithm", KeyManagerFactory.getDefaultAlgorithm)$/;"	V
aliasedDictionary	Anorm.scala	/^  private lazy val aliasedDictionary: Map[String, (ColumnName, Boolean, String)] = {$/;"	V
all	Form.scala	/^    val all: Seq[Either[Seq[FormError], Seq[Any]]] = results.map(_.right.map(Seq(_)))$/;"	V
all	Iteratee.scala	/^          val all = rest ++ chunk$/;"	V
all	JavascriptCompiler.scala	/^    lazy val all = allSiblings(source)$/;"	V
all	Messages.scala	/^    val all = availables$/;"	V
all	PlayReloader.scala	/^        val all = extracted.runTask(playMonitoredFiles, state)._2.map( f => new File(f) )$/;"	V
allChannels	NettyServer.scala	/^  val allChannels = new DefaultChannelGroup$/;"	V
allDependencies	PlayProject.scala	/^    val allDependencies = (dependencies ++ Seq(jdbc, anorm, javaCore, javaJdbc, javaEbean )).toSet.toSeq$/;"	V
allErrorsOrItems	Form.scala	/^    val allErrorsOrItems: Seq[Either[Seq[FormError], T]] = RepeatedMapping.indexes(key, data).map(i => wrapped.withPrefix(key + "[" + i + "]").bind(data))$/;"	V
allHeaders	WS.scala	/^    def allHeaders: Map[String, Seq[String]] = {$/;"	m
allJars	PlayCommands.scala	/^        val allJars: Seq[Iterable[File]] = for {$/;"	V
allSettings	PlayProject.scala	/^    lazy val allSettings = settings ++ playSettings$/;"	V
allSettings	Project.scala	/^    lazy val allSettings = settings ++ playSettings$/;"	V
alreadyClean	PlayDefaultUpstreamHandler.scala	/^        val alreadyClean = new java.util.concurrent.atomic.AtomicBoolean(false)$/;"	V
alreadyStarted	Concurrent.scala	/^          val alreadyStarted = !started.single.compareAndSet(false, true)$/;"	V
andThen	Enumerator.scala	/^  def andThen(e: Enumerator[E]): Enumerator[E] = new Enumerator[E] {$/;"	m
andThen	Reads.scala	/^  def andThen[B](rb: Reads[B])(implicit witness: A <:< JsValue): Reads[B] = rb.compose(this.map(witness))$/;"	m
annotation.implicitNotFound	Application.scala	/^import annotation.implicitNotFound$/;"	i
annotation.target.field	Task.scala	/^import annotation.target.field$/;"	i
anorm	Anorm.scala	/^package anorm$/;"	p
anorm	PlayKeys.scala	/^  val anorm = "play" %% "anorm" % play.core.PlayVersion.current$/;"	V
anorm	SqlParser.scala	/^package anorm$/;"	p
anorm	SqlStatementParser.scala	/^package anorm$/;"	p
anorm	Utils.scala	/^package anorm$/;"	p
any	ScalaTemplateCompiler.scala	/^      def any = {$/;"	m
anyContent	ContentTypes.scala	/^    def anyContent: BodyParser[AnyContent] = BodyParser("anyContent") { request =>$/;"	m
anyContent	JavaParsers.scala	/^  def anyContent(maxLength: Int): BodyParser[RequestBody] = parse.maxLength(orDefault(maxLength), parse.anyContent).map {$/;"	m
anyData	FormSpec.scala	/^    val anyData = Map("email" -> "bob@gmail.com", "password" -> "123")$/;"	V
api	Cache.scala	/^  def api: CacheAPI$/;"	m
api	Cache.scala	/^  lazy val api = new CacheAPI {$/;"	V
api	DB.scala	/^  def api: DBApi = dbApi$/;"	m
api	DB.scala	/^  def api: DBApi$/;"	m
api	Evolutions.scala	/^    val api = app.plugin[DBPlugin].map(_.api).getOrElse(throw new Exception("there should be a database plugin registered at this point but looks like it's not available, so evolution won't work. Please make sure you register a db plugin properly"))$/;"	V
api	Messages.scala	/^  def api = messages$/;"	m
api	MessagesSpec.scala	/^  val api = new MessagesApi(testMessages)$/;"	V
apiDoc	ApplicationProvider.scala	/^    val apiDoc = """\/@documentation\/api\/(.*)""".r$/;"	V
app	JsResult.scala	/^    val app = a$/;"	V
app	Reads.scala	/^    val app = a$/;"	V
app	ResultsSpec.scala	/^    implicit lazy val app: Application =$/;"	V
app	Specs.scala	/^        val app: FakeApplication = FakeApplication(),$/;"	V
app	Specs.scala	/^abstract class WithApplication(val app: FakeApplication = FakeApplication()) extends Around with Scope {$/;"	V
app	Specs.scala	/^abstract class WithServer(val app: FakeApplication = FakeApplication(),$/;"	V
appName	Console.scala	/^          val appName = template._2$/;"	V
appProvider	NettyServer.scala	/^        val appProvider = new ReloadableApplication(sbtLink)$/;"	V
append	JsResult.scala	/^  def append(error: (JsPath, ValidationError) ): JsError = this.:+(error)$/;"	m
append	JsValue.scala	/^  def append(el: JsValue): JsArray = this.:+(el)$/;"	m
append	Reads.scala	/^    def append(a1: JsArray, a2: JsArray) = a1 ++ a2$/;"	m
append	Reads.scala	/^    def append(o1: JsObject, o2: JsObject) = o1 ++ o2$/;"	m
application	Application.scala	/^ * val application = Application(new File("."), this.getClass.getClassloader, None, Play.Mode.Dev)$/;"	V
application	ApplicationProvider.scala	/^  val application = new DefaultApplication(applicationPath, this.getClass.getClassLoader, None, Mode.Prod)$/;"	V
application	Evolutions.scala	/^    val application = applicationEvolutions(path, applicationClassloader, db)$/;"	V
application	Play.scala	/^  def application(implicit app: Application): Application = app$/;"	m
applicationEvolutions	Evolutions.scala	/^  def applicationEvolutions(path: File, applicationClassloader: ClassLoader, db: String): Seq[Evolution] = {$/;"	m
applicationLoader	PlayCommands.scala	/^      lazy val applicationLoader: ClassLoader = new java.net.URLClassLoader(classpath, commonLoader) {$/;"	V
applicationProvider	NettyServer.scala	/^  def applicationProvider = appProvider$/;"	m
applicationProvider	Server.scala	/^  def applicationProvider: ApplicationProvider$/;"	m
applicationSystem	Akka.scala	/^  lazy val applicationSystem: ActorSystem = {$/;"	V
applicationSystemEnabled	Akka.scala	/^  private var applicationSystemEnabled = false$/;"	v
applicationTypes	MimeTypes.scala	/^  def applicationTypes: Map[String, String] = play.api.Play.maybeApplication.flatMap { application =>$/;"	m
applicativeJsResult	JsResult.scala	/^  implicit val applicativeJsResult:Applicative[JsResult] = new Applicative[JsResult] {$/;"	V
applies	JsMacroImpl.scala	/^            val applies = s.asMethod.alternatives$/;"	V
apply	Action.scala	/^    def apply(ctx: Request[A]) = try {$/;"	m
apply	Action.scala	/^    def apply(request: RequestHeader) = self(request).flatMap {$/;"	m
apply	Action.scala	/^    def apply(request: RequestHeader) = self(request).map(_.right.map(f(_)))$/;"	m
apply	Action.scala	/^    def apply(rh: RequestHeader) = f(rh)$/;"	m
apply	Action.scala	/^  def apply() = this$/;"	m
apply	Action.scala	/^  def apply(block: => Result): Action[AnyContent] = apply(_ => block)$/;"	m
apply	Action.scala	/^  def apply(block: Request[AnyContent] => Result): Action[AnyContent] = apply(BodyParsers.parse.anyContent)(block)$/;"	m
apply	Action.scala	/^  def apply(f: RequestHeader => Iteratee[Array[Byte], Result]): EssentialAction = new EssentialAction {$/;"	m
apply	Action.scala	/^  def apply(request: Request[A]): Result$/;"	m
apply	Action.scala	/^  def apply(rh: RequestHeader): Iteratee[Array[Byte], Result] = parser(rh).mapM { parseResult =>$/;"	m
apply	Action.scala	/^  def apply[A](bodyParser: BodyParser[A])(block: Request[A] => Result): Action[A] = new Action[A] {$/;"	m
apply	Action.scala	/^  def apply[T](debugName: String)(f: Function1[RequestHeader, Iteratee[Array[Byte], Either[Result, T]]]): BodyParser[T] = new BodyParser[T] {$/;"	m
apply	Action.scala	/^  def apply[T](f: Function1[RequestHeader, Iteratee[Array[Byte], Either[Result, T]]]): BodyParser[T] = {$/;"	m
apply	Anorm.scala	/^    def apply(value: Any, meta: MetaDataItem): MayErr[SqlRequestError, A] = transformer(value, meta)$/;"	m
apply	Anorm.scala	/^  def apply()(implicit connection: java.sql.Connection) = Sql.resultSetToStream(resultSet())$/;"	m
apply	Anorm.scala	/^  def apply[A](transformer: ((Any, MetaDataItem) => MayErr[SqlRequestError, A])): Column[A] = new Column[A] {$/;"	m
apply	Anorm.scala	/^  def apply[B](a: String)(implicit c: Column[B]): B = get[B](a)(c).get$/;"	m
apply	Cached.scala	/^  def apply(request: Request[A]): Result = {$/;"	m
apply	Cached.scala	/^  def apply[A](key: RequestHeader => String)(action: Action[A])(implicit app: Application): Cached[A] = {$/;"	m
apply	Cached.scala	/^  def apply[A](key: String)(action: Action[A])(implicit app: Application): Cached[A] = {$/;"	m
apply	Cached.scala	/^  def apply[A](key: String, duration: Int)(action: Action[A])(implicit app: Application): Cached[A] = {$/;"	m
apply	Comet.scala	/^  def apply[E](callback: String, initialChunk: Html = Html(Array.fill[Char](5 * 1024)(' ').mkString + "<html><body>"))(implicit encoder: CometMessage[E]) = new Enumeratee[E, Html] {$/;"	m
apply	Concurrent.scala	/^        def apply[A](it: Iteratee[E, A]): Future[Iteratee[E, A]] = {$/;"	m
apply	Concurrent.scala	/^      def apply[A](it: Iteratee[E, A]): Future[Iteratee[E, A]] = {$/;"	m
apply	Concurrent.scala	/^    def apply[A](it: Iteratee[E, A]): Future[Iteratee[E, A]] = {$/;"	m
apply	Enumeratee.scala	/^    def apply[NE](f: E => Future[NE]): Enumeratee[E, NE] = mapInputM[E] {$/;"	m
apply	Enumeratee.scala	/^    def apply[NE](f: E => NE): Enumeratee[E, NE] = mapInput[E](in => in.map(f))$/;"	m
apply	Enumeratee.scala	/^    def apply[To](f: From => Enumerator[To]) = new CheckDone[From, To] {$/;"	m
apply	Enumeratee.scala	/^    def apply[To](f: From => Seq[Input[To]]) = mapFlatten[From](in => Enumerator.enumerateSeq2(f(in)))$/;"	m
apply	Enumeratee.scala	/^    def apply[To](f: From => Seq[To]) = mapFlatten[From](in => Enumerator.enumerateSeq1(f(in)))$/;"	m
apply	Enumeratee.scala	/^    def apply[To](f: Input[From] => Enumerator[To]) = new CheckDone[From, To] {$/;"	m
apply	Enumeratee.scala	/^    def apply[To](f: Input[From] => Future[Input[To]]) = new CheckDone[From, To] {$/;"	m
apply	Enumeratee.scala	/^    def apply[To](f: Input[From] => Input[To]) = new CheckDone[From, To] {$/;"	m
apply	Enumeratee.scala	/^    def apply[To](folder: Iteratee[From, To]): Enumeratee[From, To] = new CheckDone[From, To] {$/;"	m
apply	Enumeratee.scala	/^    def apply[To](seed: To)(f: (To, From) => To): Enumeratee[From, To] = new CheckDone[From, To] {$/;"	m
apply	Enumeratee.scala	/^    def apply[To](transformer: PartialFunction[From, To]): Enumeratee[From, To] = new CheckDone[From, To] {$/;"	m
apply	Enumeratee.scala	/^  def apply[A](inner: Iteratee[To, A]): Iteratee[From, Iteratee[To, A]] = applyOn[A](inner)$/;"	m
apply	Enumerator.scala	/^      def apply[A](iteratee: Iteratee[U, A]): Future[Iteratee[U, A]] = {$/;"	m
apply	Enumerator.scala	/^    def apply[A](i: Iteratee[E, A]): Future[Iteratee[E, A]] = enumerateSeq(in, i)$/;"	m
apply	Enumerator.scala	/^    def apply[A](i: Iteratee[E, A]): Future[Iteratee[E, A]] = parent.apply(i).flatMap(e.apply) \/\/bad implementation, should remove Input.EOF in the end of first$/;"	m
apply	Enumerator.scala	/^    def apply[A](i: Iteratee[E, A]): Future[Iteratee[E, A]] =$/;"	m
apply	Enumerator.scala	/^    def apply[A](i: Iteratee[To, A]): Future[Iteratee[To, A]] = {$/;"	m
apply	Enumerator.scala	/^    def apply[A](it: Iteratee[E, A]): Future[Iteratee[E, A]] = eventuallyEnum.flatMap(_.apply(it))$/;"	m
apply	Enumerator.scala	/^    def apply[A](it: Iteratee[E, A]): Future[Iteratee[E, A]] = {$/;"	m
apply	Enumerator.scala	/^    def apply[A](it: Iteratee[E2, A]): Future[Iteratee[E2, A]] = {$/;"	m
apply	Enumerator.scala	/^    def apply[A](it:Iteratee[E,A]):Future[Iteratee[E,A]] = parent.apply(it).map{ a => callback; a}$/;"	m
apply	Enumerator.scala	/^    def apply[A](loop: (Iteratee[E,A],S) => Future[Iteratee[E,A]], s:S, k: Input[E] => Iteratee[E,A]):Future[Iteratee[E,A]] = f(s) match {$/;"	m
apply	Enumerator.scala	/^    def apply[A](loop: (Iteratee[E,A],S) => Future[Iteratee[E,A]], s:S, k: Input[E] => Iteratee[E,A]):Future[Iteratee[E,A]] = f(s).flatMap {$/;"	m
apply	Enumerator.scala	/^    def apply[A](loop: (Iteratee[E,A],S) => Future[Iteratee[E,A]], s:S, k: Input[E] => Iteratee[E,A]):Future[Iteratee[E,A]]$/;"	m
apply	Enumerator.scala	/^    def apply[A](loop: (Iteratee[E,A],Seq[E]) => Future[Iteratee[E,A]], s:Seq[E], k: Input[E] => Iteratee[E,A]):Future[Iteratee[E,A]] =$/;"	m
apply	Enumerator.scala	/^    def apply[A](loop: (Iteratee[E,A],Seq[Input[E]]) => Future[Iteratee[E,A]], s:Seq[Input[E]], k: Input[E] => Iteratee[E,A]):Future[Iteratee[E,A]] =$/;"	m
apply	Enumerator.scala	/^    def apply[A](loop: Iteratee[E,A] => Future[Iteratee[E,A]], k: Input[E] => Iteratee[E,A]) = e.flatMap {$/;"	m
apply	Enumerator.scala	/^    def apply[A](loop: Iteratee[E,A] => Future[Iteratee[E,A]], k: Input[E] => Iteratee[E,A]) = e.flatMap(ee => loop(k(Input.El(ee))))$/;"	m
apply	Enumerator.scala	/^    def apply[A](loop: Iteratee[E,A] => Future[Iteratee[E,A]], k: Input[E] => Iteratee[E,A]) = loop(k(Input.El(e)))$/;"	m
apply	Enumerator.scala	/^    def apply[A](loop: Iteratee[E,A] => Future[Iteratee[E,A]], k: Input[E] => Iteratee[E,A]):Future[Iteratee[E,A]]$/;"	m
apply	Enumerator.scala	/^  def apply[A](i: Iteratee[E, A]): Future[Iteratee[E, A]]$/;"	m
apply	Enumerator.scala	/^  def apply[A](it: Iteratee[E, A]): Future[Iteratee[E, A]] = {$/;"	m
apply	Enumerator.scala	/^  def apply[E](in: E*): Enumerator[E] = new Enumerator[E] {$/;"	m
apply	EventSource.scala	/^  def apply[E]()(implicit encoder: Comet.CometMessage[E], eventNameExtractor: EventNameExtractor[E], eventIdExtractor: EventIdExtractor[E]) = Enumeratee.map[E] { chunk =>$/;"	m
apply	Fakes.scala	/^  def apply(): FakeRequest[AnyContentAsEmpty.type] = {$/;"	m
apply	Fakes.scala	/^  def apply(method: String, path: String): FakeRequest[AnyContentAsEmpty.type] = {$/;"	m
apply	Files.scala	/^    def apply(prefix: String = "", suffix: String = ""): TemporaryFile = {$/;"	m
apply	Filters.scala	/^      def apply(rh:RequestHeader):Iteratee[Array[Byte],Result] = {$/;"	m
apply	Filters.scala	/^    def apply(f:RequestHeader => Result)(rh:RequestHeader):Result = filter(f,rh)$/;"	m
apply	Filters.scala	/^    def apply(rh:RequestHeader):Iteratee[Array[Byte],Result] = {$/;"	m
apply	Filters.scala	/^  def apply(f:RequestHeader => Result)(rh:RequestHeader):Result$/;"	m
apply	Filters.scala	/^  def apply(filter:(RequestHeader => Result, RequestHeader) => Result): Filter = new Filter {$/;"	m
apply	Filters.scala	/^  def apply(h: EssentialAction, filters: EssentialFilter*) = h match {$/;"	m
apply	Filters.scala	/^  def apply(next: EssentialAction): EssentialAction = {$/;"	m
apply	Filters.scala	/^  def apply(next: EssentialAction): EssentialAction$/;"	m
apply	Filters.scala	/^  def apply[A](action:EssentialAction, filters: List[EssentialFilter]): EssentialAction = new EssentialAction {$/;"	m
apply	Form.scala	/^  def apply(key: String): Field = Field($/;"	m
apply	Form.scala	/^  def apply(key: String): Field = {$/;"	m
apply	Form.scala	/^  def apply[T](mapping: (String, Mapping[T])): Form[T] = Form(mapping._2.withPrefix(mapping._1), Map.empty, Nil, None)$/;"	m
apply	Form.scala	/^  def apply[T](mapping: Mapping[T]): Form[T] = Form(mapping, Map.empty, Nil, None)$/;"	m
apply	Format.scala	/^    def apply[A,B](fa: OFormat[A], fb: OFormat[B]): OFormat[A~B] = $/;"	m
apply	Format.scala	/^  def apply[A](fjs: Reads[A], tjs: Writes[A]): Format[A] = {$/;"	m
apply	Format.scala	/^  def apply[A](r: Reads[A], w: OWrites[A]):OFormat[A] = new OFormat[A] {$/;"	m
apply	Format.scala	/^  def apply[A](read: JsValue => JsResult[A], write: A => JsObject):OFormat[A] = new OFormat[A] {$/;"	m
apply	Http.scala	/^    def apply(header: Option[String]) = new Cookies {$/;"	m
apply	Http.scala	/^    def apply(key: String) = data(key)$/;"	m
apply	Http.scala	/^    def apply(key: String): String = get(key).getOrElse(scala.sys.error("Header doesn't exist"))$/;"	m
apply	Http.scala	/^    def apply(name: String): Cookie = get(name).getOrElse(scala.sys.error("Cookie doesn't exist"))$/;"	m
apply	Http.scala	/^    def apply[A](rh: RequestHeader, a: A) = new Request[A] {$/;"	m
apply	Iteratee.scala	/^    def apply[A, B](otherwise: B)(eofValue: A): Iteratee[E, Either[B, A]] = {$/;"	m
apply	Iteratee.scala	/^    def apply[B, That]()(implicit t: E => TraversableOnce[B], bf: scala.collection.generic.CanBuildFrom[E, B, That]): Iteratee[E, That] = {$/;"	m
apply	Iteratee.scala	/^  def apply[E, A](a: A, e: Input[E] = Input.Empty): Iteratee[E, A] = new Iteratee[E, A] {$/;"	m
apply	Iteratee.scala	/^  def apply[E, A](k: Input[E] => Iteratee[E, A]): Iteratee[E, A] = new Iteratee[E, A] {$/;"	m
apply	Iteratee.scala	/^  def apply[E](msg: String, e: Input[E]): Iteratee[E, Nothing] = new Iteratee[E, Nothing] {$/;"	m
apply	JavaAction.scala	/^            def apply(nothing: String) = finalAction.call(javaContext)$/;"	m
apply	JavaAction.scala	/^  def apply(req: Request[play.mvc.Http.RequestBody]): Result = {$/;"	m
apply	JavaHelpers.scala	/^  def apply(e:Either[A,B]): play.libs.F.Either[A,B] = e.fold(play.libs.F.Either.Left(_), play.libs.F.Either.Right(_))$/;"	m
apply	JsMacroImpl.scala	/^            val apply = applies.collectFirst{ $/;"	V
apply	JsPath.scala	/^  def apply(idx: Int): JsPath = JsPath(path :+ IdxPathNode(idx))$/;"	m
apply	JsPath.scala	/^  def apply(json: JsValue): List[JsValue] =  path.foldLeft(List(json))((s,p) => s.flatMap(p.apply))$/;"	m
apply	JsPath.scala	/^  def apply(json: JsValue): List[JsValue] = json match {$/;"	m
apply	JsPath.scala	/^  def apply(json: JsValue): List[JsValue]$/;"	m
apply	JsResult.scala	/^    def apply[A,B](mf:JsResult[A => B], ma: JsResult[A]):JsResult[B] = (mf, ma) match {$/;"	m
apply	JsResult.scala	/^  def apply(): JsError = JsError(Seq(JsPath() -> Seq()))$/;"	m
apply	JsResult.scala	/^  def apply(error: (JsPath, ValidationError)): JsError = JsError(Seq(error._1 -> Seq(error._2)))$/;"	m
apply	JsResult.scala	/^  def apply(error: String): JsError = JsError(ValidationError(error))$/;"	m
apply	JsResult.scala	/^  def apply(error: ValidationError): JsError = JsError(Seq(JsPath() -> Seq(error)))$/;"	m
apply	JsResult.scala	/^  def apply(path: JsPath, error: String): JsError = JsError(path -> ValidationError(error))$/;"	m
apply	JsResult.scala	/^  def apply(path: JsPath, error: ValidationError): JsError = JsError(path -> error)$/;"	m
apply	JsValue.scala	/^  def apply(idx: Int): JsValue = JsUndefined(this.toString + " is not an array")$/;"	m
apply	Logger.scala	/^  def apply(name: String): Logger = new Logger(LoggerFactory.getLogger(name))$/;"	m
apply	Logger.scala	/^  def apply[T](clazz: Class[T]): Logger = new Logger(LoggerFactory.getLogger(clazz))$/;"	m
apply	MediaRange.scala	/^  def apply(mediaRange: String) = {$/;"	m
apply	Messages.scala	/^  def apply(code: String): Lang = {$/;"	m
apply	Messages.scala	/^  def apply(key: String, args: Any*)(implicit lang: Lang): String = {$/;"	m
apply	NettyPromise.scala	/^  def apply(channelPromise: ChannelFuture) = new scala.concurrent.Future[Unit] {$/;"	m
apply	OpenID.scala	/^  def apply(queryString: Map[String, Seq[String]]): UserInfo = {$/;"	m
apply	PathParts.scala	/^  def apply(path: String): Option[Map[String, String]] = {$/;"	m
apply	PlayJvm.scala	/^  def apply(log: Logger, connectInput: Boolean) =$/;"	m
apply	PlayLogger.scala	/^  def apply(data: Settings[Scope], state: State, task: ScopedKey[_], to: java.io.PrintWriter): Logger = {$/;"	m
apply	PlayProject.scala	/^  def apply(name: String, applicationVersion: String = "1.0", dependencies: Seq[ModuleID] = Nil, path: File = file("."), mainLang: String = NONE, settings: => Seq[Setting[_]] = Defaults.defaultSettings): Project = {$/;"	m
apply	Project.scala	/^  def apply(name: String, applicationVersion: String = "1.0", dependencies: Seq[ModuleID] = Nil, path: File = file("."), settings: => Seq[Setting[_]] = Defaults.defaultSettings): sbt.Project = {$/;"	m
apply	Promise.scala	/^  def apply[A](): scala.concurrent.Promise[A] = scala.concurrent.Promise[A]()$/;"	m
apply	Promise.scala	/^  def apply[A](lazyA: => A): scala.concurrent.Future[A] = (try (scala.concurrent.Promise.successful(lazyA)) catch {$/;"	m
apply	Reads.scala	/^    def apply[A,B](mf:Reads[A => B], ma: Reads[A]):Reads[B] = new Reads[B]{ def reads(js: JsValue) = applicativeJsResult(mf.reads(js),ma.reads(js)) }$/;"	m
apply	Reads.scala	/^  def apply[A](f: JsValue => JsResult[A]): Reads[A] = new Reads[A] {$/;"	m
apply	Results.scala	/^    def apply[C](content: C)(implicit writeable: Writeable[C]): SimpleResult[C] = {$/;"	m
apply	Router.scala	/^          def apply(rh: RequestHeader) = action(rh)$/;"	m
apply	Router.scala	/^    def apply(method: String, pathPattern: PathPattern) = new ParamsExtractor {$/;"	m
apply	Router.scala	/^    def apply(router: Router.Routes) = new {$/;"	m
apply	Router.scala	/^  def apply(path: String): Option[Map[String, String]] = {$/;"	m
apply	RoutesCompiler.scala	/^      def apply(in: Input) = p(in) match {$/;"	m
apply	RoutesCompiler.scala	/^    def apply(bytes: Array[Byte]): String = {$/;"	m
apply	ScalaTemplateCompiler.scala	/^        def apply(in: Input) = {$/;"	m
apply	ScalaTemplateCompiler.scala	/^    def apply""" :+ Source(root.params.str, root.params.pos) :+ """:""" :+ resultType :+ """ = {$/;"	m
apply	ScalaTemplateCompiler.scala	/^    def apply(bytes: Array[Byte]): String = {$/;"	m
apply	Selenium.scala	/^      def apply(driver: WebDriver): T = {$/;"	m
apply	Selenium.scala	/^  def apply[D <: WebDriver](clazz: Class[D]): WebDriver = {$/;"	m
apply	SqlParser.scala	/^    def apply(row: Row): SqlResult[A] = f(row)$/;"	m
apply	SqlParser.scala	/^    def apply(rows: ResultSet): SqlResult[A] = f(rows)$/;"	m
apply	SqlParser.scala	/^  def apply[A](f: ResultSet => SqlResult[A]): ResultSetParser[A] = new ResultSetParser[A] { rows =>$/;"	m
apply	SqlParser.scala	/^  def apply[A](f: Row => SqlResult[A]): RowParser[A] = new RowParser[A] {$/;"	m
apply	Templates.scala	/^  def apply(text: String): Html = {$/;"	m
apply	Templates.scala	/^  def apply(text: String): Txt = {$/;"	m
apply	Templates.scala	/^  def apply(text: String): Xml = {$/;"	m
apply	TraversableIteratee.scala	/^    def apply[A](implicit p: E => scala.collection.TraversableLike[A, E]):Iteratee[E,Option[A]] = {$/;"	m
apply	Util.scala	/^  def apply[M[_], T](stuff: M[T]) = new LazyHelper[M, T] {$/;"	m
apply	Validation.scala	/^  def apply(error: String, args: Any*): Invalid = Invalid(Seq(ValidationError(error, args: _*)))$/;"	m
apply	Validation.scala	/^  def apply(error: ValidationError): Invalid = Invalid(Seq(error))$/;"	m
apply	Validation.scala	/^  def apply(t: T): ValidationResult = f(t)$/;"	m
apply	Validation.scala	/^  def apply[T](f: (T => ValidationResult)): Constraint[T] = apply(None, Nil)(f)$/;"	m
apply	Validation.scala	/^  def apply[T](name: String, args: Any*)(f: (T => ValidationResult)): Constraint[T] = apply(Some(name), args.toSeq)(f)$/;"	m
apply	WebSocket.scala	/^  def apply() = this$/;"	m
apply	WebSocketHandler.scala	/^      def apply[R](i: Iteratee[A, R]) = {$/;"	m
apply	Writeable.scala	/^  def apply[A](transform: A => Array[Byte])(implicit ct: ContentTypeOf[A]): Writeable[A] = Writeable(transform, ct.mimeType)$/;"	m
apply	Writes.scala	/^    def apply[A,B](wa: OWrites[A], wb: OWrites[B]):OWrites[A~B] = OWrites[A~B]{ case a ~ b => wa.writes(a) ++ wb.writes(b)}$/;"	m
apply	Writes.scala	/^  def apply[A](f: A => JsObject):OWrites[A] = new OWrites[A] {$/;"	m
apply	Writes.scala	/^  def apply[A](f: A => JsValue): Writes[A] = new Writes[A] {$/;"	m
apply	csrf.scala	/^      def apply(request: RequestHeader): Iteratee[Array[Byte], Result] = {$/;"	m
apply	csrf.scala	/^    def apply() = new CSRFFilter(CSRF.generate _)$/;"	m
apply	csrf.scala	/^    def apply(call: Call)(implicit token: play.filters.csrf.CSRF.Token): Call = {$/;"	m
apply	csrf.scala	/^    def apply(generator: () => CSRF.Token) = new CSRFFilter(generator)$/;"	m
apply	csrf.scala	/^    def apply(next: EssentialAction): EssentialAction = new EssentialAction {$/;"	m
applyEvolutions	Evolutions.scala	/^    val applyEvolutions = """\/@evolutions\/apply\/([a-zA-Z0-9_]+)""".r$/;"	V
applyFor	Evolutions.scala	/^  def applyFor(dbName: String, path: java.io.File = new java.io.File(".")) {$/;"	m
applyMethod	JsMacroImpl.scala	/^                    val applyMethod = Ident( companionSymbol.name )$/;"	V
applyOn	Comet.scala	/^    def applyOn[A](inner: Iteratee[Html, A]): Iteratee[E, Iteratee[Html, A]] = {$/;"	m
applyOn	Concurrent.scala	/^    def applyOn[A](inner: Iteratee[E, A]): Iteratee[E, Iteratee[E, A]] = {$/;"	m
applyOn	Concurrent.scala	/^    def applyOn[A](it: Iteratee[E, A]): Iteratee[E, Iteratee[E, A]] = {$/;"	m
applyOn	Enumeratee.scala	/^      def applyOn[A](iteratee: Iteratee[To, A]): Iteratee[From, Iteratee[To, A]] = {$/;"	m
applyOn	Enumeratee.scala	/^      def applyOn[A](iteratee: Iteratee[To2, A]): Iteratee[From, Iteratee[To2, A]] = {$/;"	m
applyOn	Enumeratee.scala	/^    def applyOn[A](inner: Iteratee[E, A]): Iteratee[E, Iteratee[E, A]] = {$/;"	m
applyOn	Enumeratee.scala	/^    def applyOn[A](it: Iteratee[To, A]): Iteratee[From, Iteratee[To, A]] =$/;"	m
applyOn	Enumeratee.scala	/^    def applyOn[A](it: Iteratee[To, A]): Iteratee[From, Iteratee[To,A]] = $/;"	m
applyOn	Enumeratee.scala	/^    def applyOn[A](it:Iteratee[E,A]): Iteratee[E, Iteratee[E,A]] = passAlong[E] &> Iteratee.flatten(es(it))$/;"	m
applyOn	Enumeratee.scala	/^    def applyOn[A](iteratee: Iteratee[E, A]): Iteratee[E, Iteratee[E, A]] = passAlong[E](iteratee).map(_.map { a => action(); a })$/;"	m
applyOn	Enumeratee.scala	/^  def applyOn[A](inner: Iteratee[To, A]): Iteratee[From, Iteratee[To, A]]$/;"	m
applyOn	Iteratee.scala	/^    def applyOn[A](inner: Iteratee[MatchInfo[Array[Byte]], A]): Iteratee[Array[Byte], Iteratee[MatchInfo[Array[Byte]], A]] = {$/;"	m
applyOn	TraversableIteratee.scala	/^    def applyOn[A](inner: Iteratee[M, A]): Iteratee[M, Iteratee[M, A]] = {$/;"	m
applyOn	TraversableIteratee.scala	/^    def applyOn[A](it: Iteratee[M, A]): Iteratee[M, Iteratee[M, A]] = {$/;"	m
applyScript	Evolutions.scala	/^  def applyScript(api: DBApi, db: String, script: Seq[Script]) {$/;"	m
applyScript	Evolutions.scala	/^  def applyScript(appPath: File, classloader: ClassLoader, dbName: String) {$/;"	m
applyTillLast	JsPath.scala	/^  def applyTillLast(json: JsValue): Either[JsError, JsResult[JsValue]] = {$/;"	m
applying	Evolutions.scala	/^    var applying = -1$/;"	v
applyp	RoutesCompiler.scala	/^        def applyp(in0: Input): ParseResult[List[T]] = p0(in0) match {$/;"	m
applyp	ScalaTemplateCompiler.scala	/^          def applyp(in0: Input): ParseResult[List[T]] = p0(in0) match {$/;"	m
argsMap	Anorm.scala	/^      val argsMap = Map(ps: _*)$/;"	V
argsMap	Anorm.scala	/^    val argsMap = Map(params: _*)$/;"	V
argument	OpenIDSpec.scala	/^      val argument = ArgumentCaptor.forClass(classOf[Params])$/;"	V
arr	Json.scala	/^  def arr(fields: JsValueWrapper*): JsArray = JsArray(fields.map(_.asInstanceOf[JsValueWrapperImpl].field))$/;"	m
as	Anorm.scala	/^  def as[T](parser: ResultSetParser[T])(implicit connection: java.sql.Connection): T = Sql.as[T](parser, resultSet())$/;"	m
as	Anorm.scala	/^  def as[T](parser: ResultSetParser[T], rs: java.sql.ResultSet): T =$/;"	m
as	Form.scala	/^  def as(binder: Formatter[T]): Mapping[T] = {$/;"	m
as	JsValue.scala	/^  def as[T](implicit fjs: Reads[T]): T = fjs.reads(this).fold($/;"	m
as	Results.scala	/^  def as(contentType: String): A$/;"	m
as	Results.scala	/^  def as(contentType: String): AsyncResult = {$/;"	m
as	Results.scala	/^  def as(contentType: String): PlainResult = withHeaders(CONTENT_TYPE -> contentType)$/;"	m
as	ScalaTemplateCompiler.scala	/^      def as[T](parser: Parser[T], error: String) = {$/;"	m
asBatch	Anorm.scala	/^  def asBatch[T]: BatchSql = BatchSql(this, Nil)$/;"	m
asBytes	ContentTypes.scala	/^  def asBytes(maxLength: Int = memoryThreshold): Option[Array[Byte]] = {$/;"	m
asBytes	JavaParsers.scala	/^          def asBytes = rawBuffer.asBytes().orNull$/;"	m
asBytes	JavaParsers.scala	/^          def asBytes(maxLength: Int) = rawBuffer.asBytes(maxLength).orNull$/;"	m
asEither	JsResult.scala	/^  def asEither = this match {$/;"	m
asFile	ContentTypes.scala	/^  def asFile: File = {$/;"	m
asFile	JavaParsers.scala	/^          def asFile = rawBuffer.asFile$/;"	m
asFormUrlEncoded	ContentTypes.scala	/^  def asFormUrlEncoded: Map[String, Seq[String]] = dataParts$/;"	m
asFormUrlEncoded	ContentTypes.scala	/^  def asFormUrlEncoded: Option[Map[String, Seq[String]]] = this match {$/;"	m
asFormUrlEncoded	JavaParsers.scala	/^          lazy val asFormUrlEncoded = {$/;"	V
asFormUrlEncoded	JavaParsers.scala	/^    override lazy val asFormUrlEncoded = {$/;"	V
asJson	ContentTypes.scala	/^  def asJson: Option[JsValue] = this match {$/;"	m
asJson	JavaParsers.scala	/^    override lazy val asJson = {$/;"	V
asList	Anorm.scala	/^  lazy val asList = data.zip(metaData.ms.map(_.nullable)).map(i => if (i._2) Option(i._1) else i._1)$/;"	V
asMap	Anorm.scala	/^  lazy val asMap: scala.collection.Map[String, Any] = metaData.ms.map(_.column.qualified).zip(asList).toMap$/;"	V
asMultipartFormData	ContentTypes.scala	/^  def asMultipartFormData: Option[MultipartFormData[TemporaryFile]] = this match {$/;"	m
asMultipartFormData	JavaParsers.scala	/^    override lazy val asMultipartFormData = {$/;"	V
asOpt	JsResult.scala	/^  def asOpt = this match {$/;"	m
asOpt	JsValue.scala	/^  def asOpt[T](implicit fjs: Reads[T]): Option[T] = fjs.reads(this).fold($/;"	m
asRaw	ContentTypes.scala	/^  def asRaw: Option[RawBuffer] = this match {$/;"	m
asSimple	Anorm.scala	/^  def asSimple: SimpleSql[Row] = SimpleSql(this, Nil, defaultParser)$/;"	m
asSimple	Anorm.scala	/^  def asSimple[T](parser: RowParser[T] = defaultParser): SimpleSql[T] = SimpleSql(this, Nil, parser)$/;"	m
asSingleJsResult	JsPath.scala	/^  def asSingleJsResult(json: JsValue): JsResult[JsValue] = this(json) match {$/;"	m
asSingleJson	JsPath.scala	/^  def asSingleJson(json: JsValue): JsValue = this(json) match {$/;"	m
asTableRow	PlayCommands.scala	/^        def asTableRow(module: Map[Symbol, Any]): Seq[(String, String, String, Boolean)] = {$/;"	m
asText	ContentTypes.scala	/^  def asText: Option[String] = this match {$/;"	m
asXml	ContentTypes.scala	/^  def asXml: Option[NodeSeq] = this match {$/;"	m
asXml	JavaParsers.scala	/^    override lazy val asXml = {$/;"	V
askParsedEntered	ScalaTemplateCompiler.scala	/^            def askParsedEntered(file: SourceFile, keepLoaded: Boolean, response: Response[global.Tree]): Unit$/;"	m
askType	ScalaTemplateCompiler.scala	/^            def askType(file: SourceFile, forceReload: Boolean, respone: Response[global.Tree]): Unit$/;"	m
assets	PlayCommands.scala	/^    val assets = inAllDependencies(ref, playAssetsDirectories, Project structure state).foldLeft(Seq.empty[File])(_ ++ _)$/;"	V
assetsMapping	PlayCommands.scala	/^    val assetsMapping = mappings ++ externalMappings$/;"	V
async	JavaResults.scala	/^  def async(p: scala.concurrent.Future[Result]) = AsyncResult(p)$/;"	m
async	WebSocket.scala	/^  def async[A](f: RequestHeader => Future[(Iteratee[A, _], Enumerator[A])])(implicit frameFormatter: FrameFormatter[A]): WebSocket[A] = {$/;"	m
asyncHttpConfig	WS.scala	/^      val asyncHttpConfig = new AsyncHttpClientConfig.Builder()$/;"	V
at	Assets.scala	/^  def at(path: String, file: String): Action[AnyContent] = Action { request =>$/;"	m
at	ExternalAssets.scala	/^  def at(rootPath: String, file: String): Action[AnyContent] = Action { request =>$/;"	m
at	JsConstraints.scala	/^  def at[A](path: JsPath)(implicit f:Format[A]): OFormat[A] = $/;"	m
at	JsConstraints.scala	/^  def at[A](path: JsPath)(implicit wrs:Writes[A]): OWrites[A] =$/;"	m
at	JsConstraints.scala	/^  def at[A](path:JsPath)(implicit reads: Reads[A]): Reads[A] =$/;"	m
at	ScalaTemplateCompiler.scala	/^      def at = "@"$/;"	m
attending	Enumerator.scala	/^      val attending: Ref[Option[(Boolean, Boolean)]] = Ref(Some(true, true))$/;"	V
attending	Enumerator.scala	/^      val attending: Ref[Option[Seq[Boolean]]] = Ref(Some(es.map(_ => true)))$/;"	V
ault	Router.scala	/^        default.map(d => Right(d)).getOrElse(Left("Missing parameter: " + key))$/;"	m
aultOptions	JavascriptCompiler.scala	/^      defaultOptions.closurePass = true$/;"	m
autocommit	DB.scala	/^    val autocommit = conf.getBoolean("autocommit").getOrElse(true)$/;"	V
availableColumns	Anorm.scala	/^  lazy val availableColumns: List[String] = ms.flatMap(i => i.column.qualified :: i.column.alias.toList)$/;"	V
availables	Messages.scala	/^  def availables(implicit app: Application): Seq[Lang] = {$/;"	m
await	Helpers.scala	/^  def await[T](p: scala.concurrent.Future[T]): T = await(p, 5000)$/;"	m
await	Helpers.scala	/^  def await[T](p: scala.concurrent.Future[T], timeout: Long, unit: java.util.concurrent.TimeUnit = java.util.concurrent.TimeUnit.MILLISECONDS): T = p.await(timeout, unit).get$/;"	m
await	Promise.scala	/^  def await(timeout: Long, unit: TimeUnit = TimeUnit.MILLISECONDS): NotWaiting[A] = {$/;"	m
await	Promise.scala	/^  def await: NotWaiting[A] = await(Promise.defaultTimeout)$/;"	m
axAttributes	OpenID.scala	/^    def axAttributes = params.foldLeft(Map[String, String]()) {$/;"	m
axOptionalParams	OpenID.scala	/^      val axOptionalParams = if (axOptional.isEmpty) Nil$/;"	V
axRequiredParams	OpenID.scala	/^      val axRequiredParams = if (axRequired.isEmpty) Nil$/;"	V
az	ContentTypes.scala	/^          val az = parts.collect { case Right(a) => a }$/;"	V
b	Codecs.scala	/^      val b = array(i) & 0xff$/;"	V
b	ConcurrentSpec.scala	/^      val b = "bar"$/;"	V
b	EnumeratorsSpec.scala	/^    val b = "bar"$/;"	V
backed	PlayLogger.scala	/^  val backed = defaultBacked()$/;"	V
backedByTemporaryFile	ContentTypes.scala	/^  private var backedByTemporaryFile: TemporaryFile = _$/;"	v
backingThreadFactory	NamedThreadFactory.scala	/^  val backingThreadFactory = Executors.defaultThreadFactory()$/;"	V
bad	ContentTypes.scala	/^          val bad = parts.collect { case Left(b @ BadPart(_)) => b }$/;"	V
badRequest	Router.scala	/^    def badRequest(error: String) = Action { request =>$/;"	m
bar	PlayCommands.scala	/^          def bar(length: Int) = (1 to length).map(_ => "-").mkString$/;"	m
base	Console.scala	/^              val base = new File(G8.normalize(appName))$/;"	V
baseAction	JavaAction.scala	/^    val baseAction = play.api.Play.maybeApplication.map { app =>$/;"	V
beans.BeanProperty	PartialValidationSpec.scala	/^import beans.BeanProperty$/;"	i
beforeStart	GlobalSettings.scala	/^  def beforeStart(app: Application) {$/;"	m
bigDecReads	Reads.scala	/^  implicit val bigDecReads = Reads[BigDecimal]( js => js match {$/;"	V
bigDecimal	Forms.scala	/^  def bigDecimal( precision : Int, scale: Int ): Mapping[BigDecimal] = of[BigDecimal] as bigDecimalFormat(Some(precision,scale))$/;"	m
bigDecimal	Forms.scala	/^  val bigDecimal: Mapping[BigDecimal] = of[BigDecimal]$/;"	V
binaryFrame	Frame.scala	/^  val binaryFrame = FrameFormatter[Array[Byte]]($/;"	V
bind	Binders.scala	/^    def bind(key: String, params: Map[String, Seq[String]]) = Some(Right(bindList[T](key, params)))$/;"	m
bind	Binders.scala	/^    def bind(key: String, params: Map[String, Seq[String]]) = Some(Right(bindList[T](key, params).asJava))$/;"	m
bind	Binders.scala	/^    def bind(key: String, params: Map[String, Seq[String]]) = params.get(key).flatMap(_.headOption).map { p =>$/;"	m
bind	Binders.scala	/^    def bind(key: String, params: Map[String, Seq[String]]) = params.get(key).flatMap(_.headOption).map(Right(_)) \/\/ No need to URL decode from query string since netty already does that$/;"	m
bind	Binders.scala	/^    def bind(key: String, params: Map[String, Seq[String]]) = {$/;"	m
bind	Binders.scala	/^    def bind(key: String, params: Map[String, Seq[String]]): Option[Either[String, B]] = {$/;"	m
bind	Binders.scala	/^    def bind(key: String, value: String) = {$/;"	m
bind	Binders.scala	/^    def bind(key: String, value: String): Either[String, A] = {$/;"	m
bind	Binders.scala	/^    def bind(key: String, value: String): Either[String, B] = self.bind(key, value).right.map(toB)$/;"	m
bind	Binders.scala	/^  def bind(key: String, params: Map[String, Seq[String]]): Option[Either[String, A]]$/;"	m
bind	Binders.scala	/^  def bind(key: String, value: String): Either[String, A]$/;"	m
bind	Form.scala	/^  def bind(data: Map[String, String]) = {$/;"	m
bind	Form.scala	/^  def bind(data: Map[String, String]): Either[Seq[FormError], B] = {$/;"	m
bind	Form.scala	/^  def bind(data: Map[String, String]): Either[Seq[FormError], List[T]] = {$/;"	m
bind	Form.scala	/^  def bind(data: Map[String, String]): Either[Seq[FormError], Option[T]] = {$/;"	m
bind	Form.scala	/^  def bind(data: Map[String, String]): Either[Seq[FormError], T] = {$/;"	m
bind	Form.scala	/^  def bind(data: Map[String, String]): Either[Seq[FormError], T]$/;"	m
bind	Form.scala	/^  def bind(data: Map[String, String]): Form[T] = mapping.bind(data).fold($/;"	m
bind	Form.scala	/^  def bind(data: play.api.libs.json.JsValue): Form[T] = bind(FormUtils.fromJson(js = data))$/;"	m
bind	ObjectMappings.scala	/^  def bind(data: Map[String, String]): Either[Seq[FormError], R] = {$/;"	m
bindFromRequest	Form.scala	/^  def bindFromRequest()(implicit request: play.api.mvc.Request[_]): Form[T] = {$/;"	m
bindFromRequest	Form.scala	/^  def bindFromRequest(data: Map[String, Seq[String]]): Form[T] = {$/;"	m
black	Color.scala	/^  def black(str: String): String = if (isANSISupported) (BLACK + str + RESET) else str$/;"	m
black	Console.scala	/^  def black(str: String): String = if (isANSISupported) (BLACK + str + RESET) else str$/;"	m
blankLine	Messages.scala	/^    def blankLine = ignoreWhiteSpace <~ newLine ^^ { case _ => Comment("") }$/;"	m
blankLine	RoutesCompiler.scala	/^    def blankLine: Parser[Unit] = ignoreWhiteSpace ~> newLine ^^ { case _ => () }$/;"	m
block	JsMacroImpl.scala	/^                      val block = Block( $/;"	V
block	JsMacroImpl.scala	/^                      val block = Block($/;"	V
block	JsMacroImpl.scala	/^                      val block = Select($/;"	V
block	ScalaTemplateCompiler.scala	/^      def block: Parser[Block] = {$/;"	m
blockArgs	ScalaTemplateCompiler.scala	/^      def blockArgs: Parser[PosString] = positioned( (not("=>" | newLine) ~> any *) ~ "=>" ^^ { case args ~ arrow => PosString(args.mkString + arrow) } )$/;"	m
blue	Color.scala	/^  def blue(str: String): String = if (isANSISupported) (BLUE + str + RESET) else str$/;"	m
blue	Console.scala	/^  def blue(str: String): String = if (isANSISupported) (BLUE + str + RESET) else str$/;"	m
bobby	JsonValidSpec.scala	/^      val bobby = User("bobby", 54)$/;"	V
body	Content.scala	/^  def body: String$/;"	m
body	FormSpec.scala	/^  def body() = new Http.RequestBody {$/;"	m
body	Http.scala	/^      lazy val body = f(self.body)$/;"	V
body	Http.scala	/^      val body = a$/;"	V
body	Http.scala	/^    def body = request.body$/;"	m
body	Http.scala	/^    def body: A$/;"	m
body	JavaHelpers.scala	/^      def body = null$/;"	m
body	JavaHelpers.scala	/^      def body = req.body$/;"	m
body	PlayDefaultUpstreamHandler.scala	/^              val body = {$/;"	V
body	Templates.scala	/^  def body = toString$/;"	m
body	Templates.scala	/^  def body: String = toString$/;"	m
body	WS.scala	/^    protected var body: Option[String] = None$/;"	v
body	WS.scala	/^  lazy val body: String = {$/;"	V
bodyEnumerator	PlayDefaultUpstreamHandler.scala	/^            lazy val bodyEnumerator = {$/;"	V
bodyGenerator	WS.scala	/^      val bodyGenerator = new FileBodyGenerator(body);$/;"	V
bodyIteratee	PlayDefaultUpstreamHandler.scala	/^                  val bodyIteratee = {$/;"	V
bodyIteratee	PlayDefaultUpstreamHandler.scala	/^                val bodyIteratee = {$/;"	V
bodyParserTimeout	Server.scala	/^  val bodyParserTimeout = {$/;"	V
bodySize	Action.scala	/^   * val bodySize = BodyParser { request =>$/;"	V
bodySize	Action.scala	/^   * val bodySize = BodyParser("Body size") { request =>$/;"	V
book	ApplicationProvider.scala	/^    val book = """\/@documentation\/Book""".r$/;"	V
bool	SqlParser.scala	/^  def bool(columnName: String): RowParser[Boolean] = get[Boolean](columnName)(implicitly[Column[Boolean]])$/;"	m
boolean	Forms.scala	/^  val boolean: Mapping[Boolean] = of[Boolean]$/;"	V
bootClasspath	PlayJvm.scala	/^ * val bootClasspath = "-Xbootclasspath\/a:" + scalaClasspath$/;"	V
bootstrap	NettyServer.scala	/^    val bootstrap = newBootstrap$/;"	V
brackets	RoutesCompiler.scala	/^    def brackets: Parser[String] = {$/;"	m
brackets	ScalaTemplateCompiler.scala	/^      def brackets: Parser[String] = {$/;"	m
breakE	Enumeratee.scala	/^  def breakE[E](p: E => Boolean) = new Enumeratee[E, E] {$/;"	m
broadcast	Concurrent.scala	/^  def broadcast[E](e: Enumerator[E], interestIsDownToZero: Broadcaster => Unit = _ => ()): (Enumerator[E], Broadcaster) = { lazy val h: Hub[E] = hub(e, () => interestIsDownToZero(h)); (h.getPatchCord(), h) }$/;"	m
broadcast	Concurrent.scala	/^  def broadcast[E]: (Enumerator[E], Channel[E]) = {$/;"	m
browser	Helpers.scala	/^    var browser: TestBrowser = null$/;"	v
browser	Specs.scala	/^  lazy val browser: TestBrowser = TestBrowser.of(webDriver, Some("http:\/\/localhost:" + port))$/;"	V
buffer	Concurrent.scala	/^  def buffer[E](maxBuffer: Int): Enumeratee[E, E] = buffer[E](maxBuffer, length = (_: Input[E]) => 1)$/;"	m
buffer	Concurrent.scala	/^  def buffer[E](maxBuffer: Int, length: Input[E] => Int): Enumeratee[E, E] = new Enumeratee[E, E] {$/;"	m
buffer	ContentTypes.scala	/^          val buffer = new Array[Byte](size.toInt)$/;"	V
buffer	ContentTypes.scala	/^      val buffer = RawBuffer(memoryThreshold)$/;"	V
buffer	Enumerator.scala	/^      val buffer = new Array[Byte](chunkSize)$/;"	V
buffer	PlayJvm.scala	/^      val buffer = new Array[Byte](BufferSize)$/;"	V
buffer	PlayLogger.scala	/^  private val buffer = mutable.ArrayBuffer[(Level.Value, String)]()$/;"	V
buffer	TemplateCompilerSpec.scala	/^    val buffer = new StringBuilder(text)$/;"	V
buffer	TemplateUtilsSpec.scala	/^          val buffer = new StringBuilder(text)$/;"	V
buffer	Templates.scala	/^  private val buffer = new StringBuilder(text)$/;"	V
buffer	Templates.scala	/^class Html(val buffer: StringBuilder) extends Appendable[Html] with Content with play.mvc.Content {$/;"	V
buildDesc	PlayCommands.scala	/^    val buildDesc = crossTarget \/ "classes" \/ "public" \/ buildDescName$/;"	V
buildDescName	PlayCommands.scala	/^    val buildDescName = "app.build.js"$/;"	V
buildRequire	PlayCommands.scala	/^  val buildRequire = TaskKey[Seq[(JFile, JFile)]]("play-build-require-assets")$/;"	V
buildRequireTask	PlayCommands.scala	/^  val buildRequireTask = (copyResources in Compile, crossTarget, requireJs, requireJsFolder, requireJsShim, requireNativePath, streams) map { (cr, crossTarget, requireJs, requireJsFolder, requireJsShim, requireNativePath,  s) =>$/;"	V
buildSubPath	JsPath.scala	/^    def buildSubPath(path: JsPath, value: JsValue) = {$/;"	m
builder	Iteratee.scala	/^        val builder = bf()$/;"	V
builder	PlayCommands.scala	/^          val builder = new JProcessBuilder(Seq($/;"	V
builder	PlayCommands.scala	/^    val builder = new JProcessBuilder(args: _*)$/;"	V
builder	PlayJvm.scala	/^ * val builder = new JProcessBuilder(command: _*)$/;"	V
builder	Reads.scala	/^          val builder = bf()$/;"	V
busy	Concurrent.scala	/^    val busy = scala.concurrent.stm.Ref(false)$/;"	V
byteArrayFrame	WebSocket.scala	/^    implicit val byteArrayFrame: FrameFormatter[Array[Byte]] = play.core.server.websocket.Frames.binaryFrame$/;"	V
byteCount	PlayJvm.scala	/^        val byteCount = in.read(buffer)$/;"	V
bytes	PlayDefaultUpstreamHandler.scala	/^                val bytes = new Array[Byte](cBuffer.readableBytes())$/;"	V
bytes	RequestBodyHandler.scala	/^            val bytes = new Array[Byte](cBuffer.readableBytes())$/;"	V
bytes	csrf.scala	/^      val bytes = new Array[Byte](10)$/;"	V
c	EnumeratorsSpec.scala	/^    val c = Iteratee.fold[Int,Int](0){(s,i) => s+1}$/;"	V
c	Evolutions.scala	/^      val c = ds.getConnection$/;"	V
c	Evolutions.scala	/^    val c = Configuration.load(appPath).getConfig("db").get$/;"	V
c	JsonSpec.scala	/^      val c = Car(1, Map("ford" -> "1954 model"))$/;"	V
c	JsonValidSpec.scala	/^      \/*val c = java.util.Calendar.getInstance()$/;"	V
c	ScalaTemplateCompiler.scala	/^      for (pos <- meta("LINES").split('|'); val c = pos.split("->"))$/;"	V
c	ScalaTemplateCompiler.scala	/^      for (pos <- meta("MATRIX").split('|'); val c = pos.split("->"))$/;"	V
c	csrf.scala	/^      def c = Play.configuration$/;"	m
c.universe._	JsMacroImpl.scala	/^    import c.universe._$/;"	i
c1Size	PlayCommands.scala	/^          val c1Size = modules.flatten.map(_._1.size).max$/;"	V
c2Reads1	JsonExtensionSpec.scala	/^      \/\/val c2Reads1 = Json.reads[C2]$/;"	V
c2Size	PlayCommands.scala	/^          val c2Size = modules.flatten.map(_._2.size).max$/;"	V
c3Size	PlayCommands.scala	/^          val c3Size = modules.flatten.map(_._3.size).max$/;"	V
cBuffer	PlayDefaultUpstreamHandler.scala	/^                val cBuffer = nettyHttpRequest.getContent()$/;"	V
cBuffer	RequestBodyHandler.scala	/^            val cBuffer = chunk.getContent()$/;"	V
cacheFile	PlayAssetsCompiler.scala	/^      val cacheFile = cache \/ name$/;"	V
cacheFile	PlayCommands.scala	/^    val cacheFile = c \/ "copy-assets"$/;"	V
cachedResponse	Assets.scala	/^                val cachedResponse = lastModifiedResponse.withHeaders(CACHE_CONTROL -> {$/;"	V
calculateTimestamps	PlayReloader.scala	/^      def calculateTimestamps = monitoredFiles.map( f => f.getAbsolutePath -> f.lastModified ).toMap$/;"	m
calculator	WS.scala	/^    protected var calculator: Option[SignatureCalculator] = _calc$/;"	v
call	JavaAction.scala	/^      def call(ctx: JContext): JResult = invocation$/;"	m
call	Router.scala	/^      def call(call: => A, handler: HandlerDef): Handler = call$/;"	m
call	Router.scala	/^      def call(call: => play.mvc.Result, handler: HandlerDef) = {$/;"	m
call	Router.scala	/^      def call(call: => play.mvc.WebSocket[Array[Byte]], handler: HandlerDef): Handler = play.core.j.JavaWebSocket.ofBytes(call)$/;"	m
call	Router.scala	/^      def call(call: => play.mvc.WebSocket[String], handler: HandlerDef): Handler = play.core.j.JavaWebSocket.ofString(call)$/;"	m
call	Router.scala	/^      def call(call: => play.mvc.WebSocket[org.codehaus.jackson.JsonNode], handler: HandlerDef): Handler = play.core.j.JavaWebSocket.ofJson(call)$/;"	m
call	Router.scala	/^    def call(call: => T, handler: HandlerDef): Handler$/;"	m
call	Router.scala	/^    def call(generator: => Handler): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6], pa7: Param[A7], pa8: Param[A8], pa9: Param[A9], pa10: Param[A10], pa11: Param[A11], pa12: Param[A12], pa13: Param[A13], pa14: Param[A14], pa15: Param[A15], pa16: Param[A16], pa17: Param[A17], pa18: Param[A18], pa19: Param[A19], pa20: Param[A20], pa21: Param[A21])(generator: Function21[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, A21, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6], pa7: Param[A7], pa8: Param[A8], pa9: Param[A9], pa10: Param[A10], pa11: Param[A11], pa12: Param[A12], pa13: Param[A13], pa14: Param[A14], pa15: Param[A15], pa16: Param[A16], pa17: Param[A17], pa18: Param[A18], pa19: Param[A19], pa20: Param[A20])(generator: Function20[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, A20, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6], pa7: Param[A7], pa8: Param[A8], pa9: Param[A9], pa10: Param[A10], pa11: Param[A11], pa12: Param[A12], pa13: Param[A13], pa14: Param[A14], pa15: Param[A15], pa16: Param[A16], pa17: Param[A17], pa18: Param[A18], pa19: Param[A19])(generator: Function19[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, A19, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6], pa7: Param[A7], pa8: Param[A8], pa9: Param[A9], pa10: Param[A10], pa11: Param[A11], pa12: Param[A12], pa13: Param[A13], pa14: Param[A14], pa15: Param[A15], pa16: Param[A16], pa17: Param[A17], pa18: Param[A18])(generator: Function18[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6], pa7: Param[A7], pa8: Param[A8], pa9: Param[A9], pa10: Param[A10], pa11: Param[A11], pa12: Param[A12], pa13: Param[A13], pa14: Param[A14], pa15: Param[A15], pa16: Param[A16], pa17: Param[A17])(generator: Function17[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6], pa7: Param[A7], pa8: Param[A8], pa9: Param[A9], pa10: Param[A10], pa11: Param[A11], pa12: Param[A12], pa13: Param[A13], pa14: Param[A14], pa15: Param[A15], pa16: Param[A16])(generator: Function16[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6], pa7: Param[A7], pa8: Param[A8], pa9: Param[A9], pa10: Param[A10], pa11: Param[A11], pa12: Param[A12], pa13: Param[A13], pa14: Param[A14], pa15: Param[A15])(generator: Function15[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6], pa7: Param[A7], pa8: Param[A8], pa9: Param[A9], pa10: Param[A10], pa11: Param[A11], pa12: Param[A12], pa13: Param[A13], pa14: Param[A14])(generator: Function14[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6], pa7: Param[A7], pa8: Param[A8], pa9: Param[A9], pa10: Param[A10], pa11: Param[A11], pa12: Param[A12], pa13: Param[A13])(generator: Function13[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6], pa7: Param[A7], pa8: Param[A8], pa9: Param[A9], pa10: Param[A10], pa11: Param[A11], pa12: Param[A12])(generator: Function12[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6], pa7: Param[A7], pa8: Param[A8], pa9: Param[A9], pa10: Param[A10], pa11: Param[A11])(generator: Function11[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6], pa7: Param[A7], pa8: Param[A8], pa9: Param[A9], pa10: Param[A10])(generator: Function10[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6, A7, A8, A9](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6], pa7: Param[A7], pa8: Param[A8], pa9: Param[A9])(generator: Function9[A1, A2, A3, A4, A5, A6, A7, A8, A9, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6, A7, A8](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6], pa7: Param[A7], pa8: Param[A8])(generator: Function8[A1, A2, A3, A4, A5, A6, A7, A8, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6, A7](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6], pa7: Param[A7])(generator: Function7[A1, A2, A3, A4, A5, A6, A7, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5, A6](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5], pa6: Param[A6])(generator: Function6[A1, A2, A3, A4, A5, A6, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4, A5](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4], pa5: Param[A5])(generator: Function5[A1, A2, A3, A4, A5, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3, A4](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3], pa4: Param[A4])(generator: Function4[A1, A2, A3, A4, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2, A3](pa1: Param[A1], pa2: Param[A2], pa3: Param[A3])(generator: Function3[A1, A2, A3, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[A1, A2](pa1: Param[A1], pa2: Param[A2])(generator: Function2[A1, A2, Handler]): Handler = {$/;"	m
call	Router.scala	/^    def call[P](pa: Param[P])(generator: (P) => Handler): Handler = {$/;"	m
call	RoutesCompiler.scala	/^    def call: Parser[HandlerCall] = opt("@") ~ absoluteMethod ~ opt(parameters) ^^ {$/;"	m
canBuild	JsMacroImpl.scala	/^                    val canBuild = namedImplicits.map {$/;"	V
canEqual	JsValue.scala	/^  def canEqual(other: Any): Boolean = other.isInstanceOf[JsObject]$/;"	m
caseExpression	ScalaTemplateCompiler.scala	/^      def caseExpression: Parser[ScalaExp] = {$/;"	m
catFormat	JsonExtensionSpec.scala	/^      implicit val catFormat = Json.format[Cat]$/;"	V
catReads	JsonExtensionSpec.scala	/^      implicit val catReads = Json.reads[Cat]$/;"	V
catWrites	JsonExtensionSpec.scala	/^      implicit val catWrites = Json.writes[Cat]$/;"	V
catalog	DB.scala	/^    val catalog = conf.getString("defaultCatalog")$/;"	V
category	PlayReloader.scala	/^                def category = ""$/;"	m
category	PlayReloader.scala	/^            def category = ""$/;"	m
cert	FakeKeyStore.scala	/^        val cert = createSelfSignedCertificate(keyPair)$/;"	V
cert	FakeKeyStore.scala	/^    val cert = new X509CertImpl(certInfo)$/;"	V
certInfo	FakeKeyStore.scala	/^    val certInfo = new X509CertInfo()$/;"	V
certs	Fakes.scala	/^  def certs = Promise.pure(IndexedSeq.empty)$/;"	m
ch.qos.logback.classic._	Logger.scala	/^      import ch.qos.logback.classic._$/;"	i
ch.qos.logback.classic._	Logger.scala	/^    import ch.qos.logback.classic._$/;"	i
ch.qos.logback.classic._	Logger.scala	/^  import ch.qos.logback.classic._$/;"	i
ch.qos.logback.classic.joran._	Logger.scala	/^      import ch.qos.logback.classic.joran._$/;"	i
ch.qos.logback.classic.joran._	Logger.scala	/^    import ch.qos.logback.classic.joran._$/;"	i
ch.qos.logback.classic.pattern._	Logger.scala	/^  import ch.qos.logback.classic.pattern._$/;"	i
ch.qos.logback.classic.spi._	Logger.scala	/^  import ch.qos.logback.classic.spi._$/;"	i
ch.qos.logback.core.util._	Logger.scala	/^      import ch.qos.logback.core.util._$/;"	i
ch.qos.logback.core.util._	Logger.scala	/^    import ch.qos.logback.core.util._$/;"	i
chain	Filters.scala	/^      val chain = filters.reverse.foldLeft(action){ (a, i) => i(a) }$/;"	V
chainedMethods	ScalaTemplateCompiler.scala	/^      def chainedMethods: Parser[Simple] = {$/;"	m
changed	PlayReloader.scala	/^              def changed(): Unit = ()$/;"	m
changed	PlayReloader.scala	/^            def changed() { _changed = true }$/;"	m
changedFiles	PlayAssetsCompiler.scala	/^        lazy val changedFiles: Seq[File] = currentInfos.filter(e => !previousInfo.get(e._1).isDefined || previousInfo(e._1).lastModified < e._2.lastModified).map(_._1).toSeq ++ previousInfo.filter(e => !currentInfos.get(e._1).isDefined).map(_._1).toSeq$/;"	V
channel	NettyServer.scala	/^    val channel = bootstrap.bind(new InetSocketAddress(address, port))$/;"	V
channelBuffer	PlayDefaultUpstreamHandler.scala	/^                  val channelBuffer = ChannelBuffers.dynamicBuffer(512)$/;"	V
channelBuffer	PlayDefaultUpstreamHandler.scala	/^                val channelBuffer = ChannelBuffers.dynamicBuffer(512)$/;"	V
charset	Helpers.scala	/^  def charset(of: Result): Option[String] = header(CONTENT_TYPE, of) match {$/;"	m
charset	Http.scala	/^    lazy val charset: Option[String] = headers.get(play.api.http.HeaderNames.CONTENT_TYPE).flatMap(_.split(';').tail.headOption).map(_.toLowerCase.trim).filter(_.startsWith("charset=")).flatMap(_.split('=').tail.headOption)$/;"	V
charset	Results.scala	/^case class Codec(val charset: String)(val encode: String => Array[Byte], val decode: Array[Byte] => String)$/;"	V
charset	WS.scala	/^    val charset = Option(AsyncHttpProviderUtils.parseCharset(contentType)).getOrElse {$/;"	V
chatClient1	Concurrent.scala	/^   * val chatClient1 = Iteratee.foreach[String](m => println("Client 1: " + m))$/;"	V
chatClient2	Concurrent.scala	/^   * val chatClient2 = Iteratee.foreach[String](m => println("Client 2: " + m))$/;"	V
check	Server.scala	/^  def check: Boolean$/;"	m
check	WebSocketHandler.scala	/^    def check =$/;"	m
checkClientTrusted	NettyServer.scala	/^  def checkClientTrusted(x509Certificates: Array[X509Certificate], s: String) {}$/;"	m
checkContinue0	Enumerator.scala	/^  def checkContinue0[E](inner:TreatCont0[E]) = new Enumerator[E] {$/;"	m
checkContinue1	Enumerator.scala	/^  def checkContinue1[E,S](s:S)(inner:TreatCont1[E,S]) = new Enumerator[E] {$/;"	m
checkDone	Enumeratee.scala	/^    def checkDone(x: Option[Either[(String, Input[E]), (A, Input[E])]], y: Option[Either[(String, Input[E]), (B, Input[E])]]): Either[(String, Input[E]), Option[Either[Either[A, B], ((A, B), Input[E])]]] =$/;"	m
checkEvolutionsState	Evolutions.scala	/^  def checkEvolutionsState(api: DBApi, db: String) {$/;"	m
checkFormUrlEncodedBody	csrf.scala	/^    def checkFormUrlEncodedBody = checkBody[Map[String, Seq[String]]](tolerantFormUrlEncoded, identity) _$/;"	m
checkMultipart	csrf.scala	/^    def checkMultipart = checkBody[MultipartFormData[TemporaryFile]](multipartFormData, _.dataParts) _$/;"	m
checkRequest	csrf.scala	/^    def checkRequest(request: RequestHeader, body: Option[Map[String, Seq[String]]] = None): Either[PlainResult, RequestHeader] = {$/;"	m
checkServerTrusted	NettyServer.scala	/^  def checkServerTrusted(x509Certificates: Array[X509Certificate], s: String) {}$/;"	m
checkTextBody	csrf.scala	/^    def checkTextBody(request: RequestHeader, token: Token, next: EssentialAction): Iteratee[Array[Byte], Result] = {$/;"	m
checkTokens	csrf.scala	/^    def checkTokens(paramToken: Token, sessionToken: Token) = paramToken == sessionToken$/;"	m
checked	Forms.scala	/^  def checked(msg: String): Mapping[Boolean] = boolean verifying (msg, _ == true)$/;"	m
chunk	Enumerator.scala	/^      val chunk = input.read(buffer) match {$/;"	V
chunkLength	Concurrent.scala	/^          val chunkLength = length(other)$/;"	V
chunked	JavaResults.scala	/^  def chunked(file: java.io.File, chunkSize: Int) = Enumerator.fromFile(file, chunkSize)$/;"	m
chunked	JavaResults.scala	/^  def chunked(stream: java.io.InputStream, chunkSize: Int): Enumerator[Array[Byte]] = Enumerator.fromStream(stream, chunkSize)$/;"	m
chunked	JavaResults.scala	/^  def chunked[A](onDisconnected: () => Unit) = play.api.libs.iteratee.Enumerator.imperative[A](onComplete = onDisconnected)$/;"	m
cipher	Crypto.scala	/^    val cipher = Cipher.getInstance("AES")$/;"	V
cl	PlayCommands.scala	/^        val cl = ClassLoader.getSystemClassLoader$/;"	V
claimedId	OpenID.scala	/^    val claimedId = discovery.normalizeIdentifier(openID)$/;"	V
claimedId	OpenIDSpec.scala	/^  val claimedId = "http:\/\/example.com\/openid?id=C123"$/;"	V
claimedId	UserInfoSpec.scala	/^  val claimedId = "http:\/\/example.com\/openid?id=C123"$/;"	V
classFiles	PlayReloader.scala	/^        val classFiles = newAnalysis.stamps.allProducts ++ watchFiles$/;"	V
classLoader	JsValue.scala	/^  private[this]  val classLoader = Thread.currentThread().getContextClassLoader$/;"	V
classLoaderVersion	PlayReloader.scala	/^      private val classLoaderVersion = new java.util.concurrent.atomic.AtomicInteger(0)$/;"	V
className	RoutesCompiler.scala	/^          val className = classAndMethod(0)$/;"	V
classPathTransformers	PlayEclipse.scala	/^    val classPathTransformers = if (mainLang == SCALA) Seq(addSourcesManaged) else Seq(addClassesManaged, addScalaLib)$/;"	V
classloader	Application.scala	/^  def classloader: ClassLoader$/;"	m
classloader	Application.scala	/^  override val classloader: ClassLoader,$/;"	V
classloader	Fakes.scala	/^    override val classloader: ClassLoader = classOf[FakeApplication].getClassLoader,$/;"	V
classloader	Play.scala	/^  def classloader(implicit app: Application): ClassLoader = app.classloader$/;"	m
classloader	TemplateCompilerSpec.scala	/^    val classloader = new URLClassLoader(Array(generatedClasses.toURI.toURL), Class.forName("play.templates.ScalaTemplateCompiler").getClassLoader)$/;"	V
classpath	PlayCommands.scala	/^          val classpath = dependencies.map(_.data).map(_.getCanonicalPath).reduceLeft(_ + java.io.File.pathSeparator + _)$/;"	V
classpath	PlayCommands.scala	/^      val classpath = dependencies.map(_.data.toURI.toURL).filter(_.toString.endsWith(".jar")).toArray$/;"	V
classpath	PlayCommands.scala	/^    val classpath = (deps.map(_.data.getAbsolutePath).toArray :+ classes.getAbsolutePath).mkString(java.io.File.pathSeparator)$/;"	V
classpathCommand	PlayCommands.scala	/^  val classpathCommand = Command.command("classpath") { state: State =>$/;"	V
clean	Files.scala	/^    def clean(): Boolean = {$/;"	m
cleanFlashCookie	PlayDefaultUpstreamHandler.scala	/^        def cleanFlashCookie(r:PlainResult):Result = {$/;"	m
cleanup	PlayDefaultUpstreamHandler.scala	/^    val cleanup = ctx.getAttachment$/;"	V
client	WS.scala	/^  def client =$/;"	m
clientHolder	WS.scala	/^  private var clientHolder: Option[AsyncHttpClient] = None$/;"	v
closeFlag	Concurrent.scala	/^    var closeFlag = false$/;"	v
closed	Concurrent.scala	/^        def closed() = isClosed$/;"	m
closed	Concurrent.scala	/^      def closed() = closeFlag$/;"	m
closed	Concurrent.scala	/^    def closed(): Boolean$/;"	m
closureCompilerOptions	PlayKeys.scala	/^  val closureCompilerOptions = SettingKey[Seq[String]]("play-closure-compiler-options")$/;"	V
closureCompilerSettings	PlaySettings.scala	/^  def closureCompilerSettings(optionCompilerOptions: com.google.javascript.jscomp.CompilerOptions) = Seq[Setting[_]]($/;"	m
code	Console.scala	/^  case class Exit(val code: Int) extends xsbti.Exit$/;"	V
code	Messages.scala	/^  lazy val code = language + Option(country).filterNot(_.isEmpty).map("-" + _).getOrElse("")$/;"	V
coffee	CoffeescriptCompiler.scala	/^    val coffee = scope.get("CoffeeScript", scope).asInstanceOf[NativeObject]$/;"	V
coffeeCode	CoffeescriptCompiler.scala	/^      val coffeeCode = Path(source).string.replace("\\r", "")$/;"	V
coffeescriptEntryPoints	PlayKeys.scala	/^  val coffeescriptEntryPoints = SettingKey[PathFinder]("play-coffeescript-entry-points")$/;"	V
coffeescriptOptions	PlayKeys.scala	/^  val coffeescriptOptions = SettingKey[Seq[String]]("play-coffeescript-options")$/;"	V
collect	Enumeratee.scala	/^  def collect[From] = new {$/;"	m
collect	JsResult.scala	/^  def collect[B](otherwise:ValidationError)(p:PartialFunction[A,B]): JsResult[B] = flatMap {$/;"	m
collect	Reads.scala	/^  def collect[B](error:ValidationError)(f: PartialFunction[A,B]) =$/;"	m
collect	SqlParser.scala	/^  def collect[B](otherwise: String)(f: PartialFunction[A, B]): RowParser[B] = RowParser(row => parent(row).flatMap(a => if (f.isDefinedAt(a)) Success(f(a)) else Error(SqlMappingError(otherwise))))$/;"	m
collectHeaders	ContentTypes.scala	/^            val collectHeaders = maxHeaderBuffer.map { buffer =>$/;"	V
collection.JavaConverters._	Assets.scala	/^import collection.JavaConverters._$/;"	i
collection.JavaConverters._	JavaHelpers.scala	/^  import collection.JavaConverters._$/;"	i
collection.JavaConverters._	PlayCommands.scala	/^        import collection.JavaConverters._$/;"	i
collection.TraversableOnce	Anorm.scala	/^import collection.TraversableOnce$/;"	i
collection.immutable.TreeMap	Fakes.scala	/^import collection.immutable.TreeMap$/;"	i
collection.immutable.TreeMap	Http.scala	/^      import collection.immutable.TreeMap$/;"	i
collection.immutable.TreeMap	WS.scala	/^import collection.immutable.TreeMap$/;"	i
column	Anorm.scala	/^      val column = m.column.qualified.split('.').last;$/;"	V
columnCount	Anorm.scala	/^  lazy val columnCount = ms.size$/;"	V
columnUpper	Anorm.scala	/^    val columnUpper = aliasName.toUpperCase()$/;"	V
columnUpper	Anorm.scala	/^    val columnUpper = columnName.toUpperCase()$/;"	V
columns	Anorm.scala	/^    val columns = List.range(1, rsMetaData.columnCount + 1)$/;"	V
com.avaje.ebean.enhance.agent._	PlayCommands.scala	/^        import com.avaje.ebean.enhance.agent._$/;"	i
com.avaje.ebean.enhance.ant._	PlayCommands.scala	/^        import com.avaje.ebean.enhance.ant._$/;"	i
com.google.common.base.Function	Selenium.scala	/^import com.google.common.base.Function$/;"	i
com.google.javascript.jscomp.ProcessCommonJSModules	JavascriptCompiler.scala	/^import com.google.javascript.jscomp.ProcessCommonJSModules$/;"	i
com.google.javascript.jscomp.{ Compiler, CompilerOptions, JSSourceFile, CompilationLevel }	JavascriptCompiler.scala	/^  import com.google.javascript.jscomp.{ Compiler, CompilerOptions, JSSourceFile, CompilationLevel }$/;"	i
com.google.javascript.rhino.Node	JavascriptCompiler.scala	/^import com.google.javascript.rhino.Node$/;"	i
com.jolbox.bonecp._	DB.scala	/^import com.jolbox.bonecp._$/;"	i
com.jolbox.bonecp.hooks._	DB.scala	/^import com.jolbox.bonecp.hooks._$/;"	i
com.ning.http.client.AsyncCompletionHandler	WS.scala	/^      import com.ning.http.client.AsyncCompletionHandler$/;"	i
com.ning.http.client.AsyncHandler	WS.scala	/^      import com.ning.http.client.AsyncHandler$/;"	i
com.ning.http.client.AsyncHandler.STATE	WS.scala	/^        import com.ning.http.client.AsyncHandler.STATE$/;"	i
com.ning.http.client.Realm.{ AuthScheme, RealmBuilder }	WS.scala	/^  import com.ning.http.client.Realm.{ AuthScheme, RealmBuilder }$/;"	i
com.ning.http.client.generators.FileBodyGenerator	WS.scala	/^      import com.ning.http.client.generators.FileBodyGenerator$/;"	i
com.ning.http.client.{	WS.scala	/^import com.ning.http.client.{$/;"	i
com.ning.http.util.AsyncHttpProviderUtils	WS.scala	/^import com.ning.http.util.AsyncHttpProviderUtils$/;"	i
com.typesafe.config._	Akka.scala	/^import com.typesafe.config._$/;"	i
com.typesafe.config._	Configuration.scala	/^import com.typesafe.config._$/;"	i
com.typesafe.config._	Invoker.scala	/^import com.typesafe.config._$/;"	i
com.typesafe.config._	PlayCommands.scala	/^        import com.typesafe.config._$/;"	i
com.typesafe.sbteclipse.core.EclipsePlugin._	PlayEclipse.scala	/^    import com.typesafe.sbteclipse.core.EclipsePlugin._$/;"	i
com.typesafe.sbteclipse.core.Validation	PlayEclipse.scala	/^    import com.typesafe.sbteclipse.core.Validation$/;"	i
com.typesafe.sbteclipse.core._	PlayEclipse.scala	/^    import com.typesafe.sbteclipse.core._$/;"	i
com.typesafe.sbtidea.SbtIdeaPlugin	PlayCommands.scala	/^    import com.typesafe.sbtidea.SbtIdeaPlugin$/;"	i
cometStream	Comet.scala	/^ * val cometStream = Enumerator("A", "B", "C") &> Comet(callback = "console.log")$/;"	V
command	PlayJvm.scala	/^ * val command = (java :: options.toList).toArray$/;"	V
comment	Messages.scala	/^    def comment = """#.*""".r ^^ { case s => Comment(s) }$/;"	m
comment	RoutesCompiler.scala	/^    def comment: Parser[Comment] = "#" ~> ".*".r ^^ {$/;"	m
comment	ScalaTemplateCompiler.scala	/^      def comment: Parser[Comment] = {$/;"	m
commitDone	Concurrent.scala	/^      val commitDone: Ref[List[Int]] = Ref(List())$/;"	V
commitReady	Concurrent.scala	/^      val commitReady: Ref[List[(Int, (Iteratee[E, _], Promise[Iteratee[E, _]]))]] = Ref(List())$/;"	V
commonClassLoader	PlayCommands.scala	/^  private[this] var commonClassLoader: ClassLoader = _$/;"	v
commonJars	PlayCommands.scala	/^    lazy val commonJars: PartialFunction[java.io.File, java.net.URL] = {$/;"	V
commonLoader	PlayCommands.scala	/^      val commonLoader = Project.runTask(playCommonClassloader, state).get._2.toEither.right.get$/;"	V
commonLoader	PlayCommands.scala	/^    val commonLoader = commonLoaderEither.right.toOption.getOrElse {$/;"	V
commonLoaderEither	PlayCommands.scala	/^    def commonLoaderEither = Project.runTask(playCommonClassloader, state).get._2.toEither$/;"	m
companionSymbol	JsMacroImpl.scala	/^    val companionSymbol = companioned.companionSymbol$/;"	V
companionType	JsMacroImpl.scala	/^    val companionType = companionSymbol.typeSignature$/;"	V
companioned	JsMacroImpl.scala	/^    val companioned = weakTypeOf[A].typeSymbol$/;"	V
compare	CaseInstensitiveOrdered.scala	/^  def compare(x: String, y: String): Int = x.compareToIgnoreCase(y)$/;"	m
compare	MediaRange.scala	/^    def compare(a: play.api.http.MediaRange, b: play.api.http.MediaRange) = {$/;"	m
compile	CoffeescriptCompiler.scala	/^  def compile(source: File, options: Seq[String]): String = {$/;"	m
compile	JavascriptCompiler.scala	/^  def compile(source: File, simpleCompilerOptions: Seq[String], fullCompilerOptions: Option[CompilerOptions]): (String, Option[String], Seq[File]) = {$/;"	m
compile	LessCompiler.scala	/^                var compile = function(source) {$/;"	v
compile	LessCompiler.scala	/^  def compile(source: File): (String, Option[String], Seq[File]) = {$/;"	m
compile	RoutesCompiler.scala	/^  def compile(file: File, generatedDir: File, additionalImports: Seq[String]) {$/;"	m
compile	ScalaTemplateCompiler.scala	/^    def compile(source: File, sourceDirectory: File, generatedDirectory: File, resultType: String, formatterType: String, additionalImports: String = "") = {$/;"	m
compile	TemplateCompilerSpec.scala	/^    def compile[T](templateName: String, className: String): T = {$/;"	m
compileVirtual	ScalaTemplateCompiler.scala	/^    def compileVirtual(content: String, source: File, sourceDirectory: File, resultType: String, formatterType: String, additionalImports: String = "") = {$/;"	m
compiler	CoffeescriptCompiler.scala	/^  private lazy val compiler = {$/;"	V
compiler	JavascriptCompiler.scala	/^    val compiler = new Compiler()$/;"	V
compiler	ScalaTemplateCompiler.scala	/^          val compiler = new Global(settings, new ConsoleReporter(settings) {$/;"	V
compiler	ScalaTemplateCompiler.scala	/^        lazy val compiler = {$/;"	V
compiler	TemplateCompilerSpec.scala	/^      val compiler = new Global(settings, new ConsoleReporter(settings) {$/;"	V
compiler	TemplateCompilerSpec.scala	/^    val compiler = {$/;"	V
compilerFunction	CoffeescriptCompiler.scala	/^    val compilerFunction = coffee.get("compile", scope).asInstanceOf[Function]$/;"	V
compilerFunction	LessCompiler.scala	/^    val compilerFunction = scope.get("compile", scope).asInstanceOf[Function]$/;"	V
compilerPath	ScalaTemplateCompiler.scala	/^            val compilerPath = Class.forName("scala.tools.nsc.Interpreter").getProtectionDomain.getCodeSource.getLocation.getFile$/;"	V
compilerPath	TemplateCompilerSpec.scala	/^        val compilerPath = Class.forName("scala.tools.nsc.Interpreter").getProtectionDomain.getCodeSource.getLocation$/;"	V
complete.Parser	PlayCommands.scala	/^import complete.Parser$/;"	i
completed	ConcurrentSpec.scala	/^      val completed = Promise[String]$/;"	V
complexExpr	ScalaTemplateCompiler.scala	/^        val complexExpr = positioned(parentheses ^^ { expr => (Simple(expr)) }) ^^ { List(_) }$/;"	V
component	PlayKeys.scala	/^  def component(id: String) = "play" %% id % play.core.PlayVersion.current$/;"	m
compose	Enumeratee.scala	/^  def compose[To2](other: Enumeratee[To, To2]): Enumeratee[From, To2] = {$/;"	m
compose	JsPath.scala	/^  def compose(other: JsPath) = JsPath(path ++ other.path)$/;"	m
compose	Reads.scala	/^  def compose[B <: JsValue](rb: Reads[B]): Reads[A] = $/;"	m
composeConcat	Enumeratee.scala	/^  def composeConcat[X](other: Enumeratee[To, To])(implicit p: To => scala.collection.TraversableLike[X, To], bf: scala.collection.generic.CanBuildFrom[To, X, To]): Enumeratee[From, To] = {$/;"	m
computeDependencies	PlayCommands.scala	/^  val computeDependencies = TaskKey[Seq[Map[Symbol, Any]]]("ivy-dependencies")$/;"	V
computeDependenciesCommand	PlayCommands.scala	/^  val computeDependenciesCommand = Command.command("dependencies") { state: State =>$/;"	V
computeDependenciesTask	PlayCommands.scala	/^  val computeDependenciesTask = (deliverLocal, ivySbt, streams, organizationName, moduleName, version, scalaBinaryVersion) map { (_, ivySbt, s, org, id, version, scalaVersion) =>$/;"	V
concurrent.Await	ParsingSpec.scala	/^import concurrent.Await$/;"	i
concurrent._	ConcurrentSpec.scala	/^import concurrent._$/;"	i
concurrent.duration.Duration	ConcurrentSpec.scala	/^import concurrent.duration.Duration$/;"	i
concurrent.duration.Duration	EnumeratorsSpec.scala	/^import concurrent.duration.Duration$/;"	i
concurrent.duration.Duration	ParsingSpec.scala	/^import concurrent.duration.Duration$/;"	i
concurrent.{Promise, Future, Await}	EnumeratorsSpec.scala	/^import concurrent.{Promise, Future, Await}$/;"	i
confDirectory	PlayKeys.scala	/^  val confDirectory = SettingKey[File]("play-conf")$/;"	V
config	Configuration.scala	/^   * val config = Configuration.load()$/;"	V
config	Configuration.scala	/^ * val config = Configuration.load()$/;"	V
config	Invoker.scala	/^    val config = Play.maybeApplication.map(_.configuration.underlying).getOrElse {$/;"	V
config	PlayCommands.scala	/^        val config = ConfigFactory.load(ConfigFactory.parseFileAnySyntax(new File("conf\/application.conf")))$/;"	V
config	WS.scala	/^        val config = new PerRequestConfig()$/;"	V
configuration	Application.scala	/^  def configuration: Configuration = fullConfiguration$/;"	m
configuration	Application.scala	/^  def configuration: Configuration$/;"	m
configuration	Configuration.scala	/^   * val configuration = Configuration.load()$/;"	V
configuration	GlobalSettings.scala	/^  def configuration: Configuration = Configuration.empty$/;"	m
configuration	Play.scala	/^  def configuration(implicit app: Application): Configuration = app.configuration$/;"	m
configuration	ResultsSpec.scala	/^        override lazy val configuration = Configuration.from(Map("application.secret" -> "pass",$/;"	V
configurator	Logger.scala	/^        val configurator = new JoranConfigurator$/;"	V
configure	Logger.scala	/^  def configure(properties: Map[String, String] = Map.empty, levels: Map[String, ch.qos.logback.classic.Level] = Map.empty, mode: Mode.Value) {$/;"	m
conn	DB.scala	/^ * val conn = DB.getConnection("customers")$/;"	V
connect	ProxyDriver.scala	/^  def connect(user: String, properties: java.util.Properties) = proxied.connect(user, properties)$/;"	m
connectSystemIn	PlayJvm.scala	/^  def connectSystemIn(out: OutputStream) = transfer(System.in, out)$/;"	m
connection	DB.scala	/^    val connection = getDataSource(name).getConnection$/;"	V
connection	DB.scala	/^    val connection = new AutoCleanConnection(getConnection(name))$/;"	V
connection	Evolutions.scala	/^    implicit val connection = api.getConnection(db, autocommit = true)$/;"	V
consoleReader	Console.scala	/^  val consoleReader = new jline.ConsoleReader$/;"	V
consoleReader	PlayCommands.scala	/^  private val consoleReader = new jline.ConsoleReader$/;"	V
constraints	Form.scala	/^  val constraints: Map[String, Seq[(String, Seq[Any])]] = mapping.mappings.map { m =>$/;"	V
constraints	Form.scala	/^  val constraints: Seq[Constraint[B]] = wrapped.constraints.map { constraintOfT =>$/;"	V
constraints	Form.scala	/^  val constraints: Seq[Constraint[T]]$/;"	V
constraints	Form.scala	/^case class OptionalMapping[T](wrapped: Mapping[T], val constraints: Seq[Constraint[Option[T]]] = Nil) extends Mapping[Option[T]] {$/;"	V
constraints	Format.scala	/^  val constraints: ConstraintFormat = this$/;"	V
constraints	Reads.scala	/^  val constraints: ConstraintReads = this$/;"	V
constraints	Writes.scala	/^  val constraints: ConstraintWrites = this$/;"	V
consume	Iteratee.scala	/^  def consume[E] = new {$/;"	m
consumer	OAuth.scala	/^    val consumer = new DefaultOAuthConsumer(info.key.key, info.key.secret)$/;"	V
cont	Iteratee.scala	/^      def cont: Iteratee[E, Either[B, A]] = Cont((in: Input[E]) => {$/;"	m
cont	Iteratee.scala	/^    def cont: Iteratee[E, Unit] = Cont {$/;"	m
contains	SqlParser.scala	/^  def contains[TT: Column, T <: TT](columnName: String, t: T): RowParser[Unit] =$/;"	m
content	Anorm.scala	/^  case class Var[T](var content: T)$/;"	v
content	Evolutions.scala	/^  def content = script$/;"	m
content	Iteratee.scala	/^    def content: A$/;"	m
content	Iteratee.scala	/^  case class Matched[A](val content: A) extends MatchInfo[A]$/;"	V
content	Iteratee.scala	/^  case class Unmatched[A](val content: A) extends MatchInfo[A]$/;"	V
content	PlayCommands.scala	/^      val content =  """({appDir: """" + jsFolder + """",$/;"	V
content	ScalaTemplateCompiler.scala	/^    def content = Path(file).string$/;"	m
content	ScalaTemplateCompiler.scala	/^    def content = _content$/;"	m
content	ScalaTemplateCompiler.scala	/^    def content: String$/;"	m
contentAsBytes	Helpers.scala	/^  def contentAsBytes(of: Content): Array[Byte] = of.body.getBytes$/;"	m
contentAsBytes	Helpers.scala	/^  def contentAsBytes(of: Result): Array[Byte] = of match {$/;"	m
contentAsString	Helpers.scala	/^  def contentAsString(of: Content): String = of.body$/;"	m
contentAsString	Helpers.scala	/^  def contentAsString(of: Result): String = new String(contentAsBytes(of), charset(of).getOrElse("utf-8"))$/;"	m
contentType	Content.scala	/^  def contentType: String$/;"	m
contentType	Helpers.scala	/^  def contentType(of: Content): String = of.contentType$/;"	m
contentType	Helpers.scala	/^  def contentType(of: Result): Option[String] = header(CONTENT_TYPE, of).map(_.split(";").take(1).mkString.trim)$/;"	m
contentType	Http.scala	/^    lazy val contentType: Option[String] = headers.get(play.api.http.HeaderNames.CONTENT_TYPE).flatMap(_.split(';').headOption).map(_.toLowerCase)$/;"	V
contentType	Templates.scala	/^  def contentType = "text\/plain"$/;"	m
contentType	Templates.scala	/^  def contentType = "text\/xml"$/;"	m
contentType	Templates.scala	/^  def contentType: String = "text\/html"$/;"	m
contentType	WS.scala	/^    val contentType = Option(ahcResponse.getContentType).getOrElse("application\/octet-stream")$/;"	V
contentTypeOfBytes	JavaResults.scala	/^  def contentTypeOfBytes(mimeType: String): ContentTypeOf[Array[Byte]] = ContentTypeOf(Option(mimeType).orElse(Some("application\/octet-stream")))$/;"	m
context	LessCompiler.scala	/^                    var context = [source];$/;"	v
continue	Enumeratee.scala	/^              def continue[A](k: K[To, A]) =$/;"	m
continue	Enumeratee.scala	/^      def continue[A](k: K[To, A]) = Cont(step(folder)(k))$/;"	m
continue	Enumeratee.scala	/^      def continue[A](k: K[To, A]) = Cont(step(k))$/;"	m
continue	Enumeratee.scala	/^      def continue[A](k: K[To, A]) = Cont(step(seed)(k))$/;"	m
continue	Enumeratee.scala	/^    def continue[A](k: Input[To] => Iteratee[To, A]): Iteratee[From, Iteratee[To, A]]$/;"	m
continue	Enumeratee.scala	/^    def continue[A](k: K[E, A]) = Cont(step(count)(k))$/;"	m
continue	Enumeratee.scala	/^    def continue[A](k: K[E, A]) = Cont(step(k))$/;"	m
continue	Enumeratee.scala	/^    def continue[A](k: K[M, A]) = Cont(step(k))$/;"	m
continue	PlayDefaultUpstreamHandler.scala	/^                val continue = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE)$/;"	V
continue	RequestBodyHandler.scala	/^      def continue(it: Iteratee[Array[Byte], Result]) {$/;"	m
continue	RoutesCompiler.scala	/^      def continue(in: Input): ParseResult[List[T]] = {$/;"	m
continue	ScalaTemplateCompiler.scala	/^        def continue(in: Input): ParseResult[List[T]] = {$/;"	m
continue	TraversableIteratee.scala	/^      def continue[A](k: K[M, A]) = Cont(step(k))$/;"	m
continueLogging	PlayLogger.scala	/^  def continueLogging(level: Level.Value, message: String, log: (Level.Value, => String) => Unit) {$/;"	m
contramap	Writes.scala	/^    def contramap[A,B](wa:OWrites[A], f: B => A):OWrites[B] = OWrites[B]( b => wa.writes(f(b)) )$/;"	m
contramap	Writes.scala	/^    def contramap[A,B](wa:Writes[A], f: B => A):Writes[B] = Writes[B]( b => wa.writes(f(b)) )$/;"	m
contravariantfunctorOWrites	Writes.scala	/^  implicit val contravariantfunctorOWrites:ContravariantFunctor[OWrites] = new ContravariantFunctor[OWrites] {$/;"	V
contravariantfunctorWrites	Writes.scala	/^  \/*implicit val contravariantfunctorWrites:ContravariantFunctor[Writes] = new ContravariantFunctor[Writes] {$/;"	V
control	PlayJvm.scala	/^  def control(event: ControlEvent.Value, message: => String) = log(Level.Info, message)$/;"	m
controller	JavaAction.scala	/^  def controller: Class[_]$/;"	m
controller	Router.scala	/^          def controller = javaAction.controller$/;"	m
controller	Router.scala	/^          lazy val controller = handler.ref.getClass.getClassLoader.loadClass(handler.controller)$/;"	V
controllerAnnotations	JavaAction.scala	/^    val controllerAnnotations = play.api.libs.Collections.unfoldLeft[Seq[java.lang.annotation.Annotation], Option[Class[_]]](Option(controller)) { clazz =>$/;"	V
controllerCall	RoutesCompiler.scala	/^                    val controllerCall = if (route.call.instantiate) {$/;"	V
controllers	Assets.scala	/^package controllers$/;"	p
controllers	Default.scala	/^package controllers$/;"	p
controllers	ExternalAssets.scala	/^package controllers$/;"	p
convert	Logger.scala	/^    def convert(event: ILoggingEvent): String = {$/;"	m
cookie	Http.scala	/^      val cookie = encode(serialize(data))$/;"	V
cookies	FormSpec.scala	/^  def cookies() = new play.mvc.Http.Cookies {$/;"	m
cookies	Helpers.scala	/^  def cookies(of: Result): Cookies = Cookies(header(SET_COOKIE, of))$/;"	m
cookies	Http.scala	/^      lazy val cookies: Map[String, Cookie] = header.map(Cookies.decode(_)).getOrElse(Seq.empty).groupBy(_.name).mapValues(_.head)$/;"	V
cookies	Http.scala	/^    lazy val cookies: Cookies = Cookies(headers.get(play.api.http.HeaderNames.COOKIE))$/;"	V
cookies	JavaHelpers.scala	/^      def cookies = new JCookies {$/;"	m
cookies	ResultsSpec.scala	/^      val cookies = Cookies.decode(Ok.discardingCookies("foo", "bar").header.headers("Set-Cookie")).map(_.name)$/;"	V
cookies	csrf.scala	/^           val cookies = Cookies(r.header.headers.get("Set-Cookie"))$/;"	V
cookiesHeader	csrf.scala	/^          lazy val cookiesHeader = request.headers.get(HeaderNames.COOKIE).map { cookies =>$/;"	V
copyFile	Files.scala	/^  def copyFile(from: File, to: File, copyAttributes: Boolean = true, replaceExisting: Boolean = true): Path = {$/;"	m
copyFrom	JsPath.scala	/^    def copyFrom[A <: JsValue](reads: Reads[A]): Reads[JsObject] = Reads.jsCopyTo(self)(reads)$/;"	m
copyRecursively	Console.scala	/^    def copyRecursively(from: Path, target: Path) {$/;"	m
coreSettings	PlayEclipse.scala	/^    val coreSettings = new File(settingsDir.toString + java.io.File.separator + "org.eclipse.core.resources.prefs")$/;"	V
count	Anorm.scala	/^    var count = n$/;"	v
count	EnumeratorsSpec.scala	/^    val count = hub.getPatchCord() |>>> c$/;"	V
count	JUnitXmlTestListener.scala	/^    def count(): (Int, Int, Int) = {$/;"	m
counter	Configuration.scala	/^   * val counter = configuration.getNumber("foo.counter")$/;"	V
counter	RequestBodyHandler.scala	/^    val counter = Ref(0)$/;"	V
cp	PlayCommands.scala	/^        val cp = deps.map(_.data.toURI.toURL).toArray :+ classes.toURI.toURL$/;"	V
createArrayOf	DB.scala	/^  def createArrayOf(typeName: String, elements: scala.Array[AnyRef]) = connection.createArrayOf(typeName, elements)$/;"	m
createBlob	DB.scala	/^  def createBlob() = connection.createBlob()$/;"	m
createClob	DB.scala	/^  def createClob() = connection.createClob()$/;"	m
createDirectory	Files.scala	/^  def createDirectory(path: File): Path = Path(path).createDirectory(failIfExists = false)$/;"	m
createJavaContext	JavaHelpers.scala	/^  def createJavaContext(req: RequestHeader): JContext = {$/;"	m
createJavaContext	JavaHelpers.scala	/^  def createJavaContext(req: Request[RequestBody]): JContext = {$/;"	m
createJavaRequest	JavaHelpers.scala	/^  def createJavaRequest(req: RequestHeader): JRequest = {$/;"	m
createLockTableIfNecessary	Evolutions.scala	/^  def createLockTableIfNecessary(c: Connection, s: Statement) {$/;"	m
createMockWithValidOpDiscoveryAndVerification	OpenIDSpec.scala	/^  def createMockWithValidOpDiscoveryAndVerification = {$/;"	m
createNClob	DB.scala	/^  def createNClob() = connection.createNClob()$/;"	m
createObj	JsPath.scala	/^  def createObj(pathValues: (JsPath, JsValue)*) = {$/;"	m
createResult	JavaHelpers.scala	/^  def createResult(javaContext: JContext, javaResult: play.mvc.Result): Result = javaResult.getWrappedResult match {$/;"	m
createSQLXML	DB.scala	/^  def createSQLXML() = connection.createSQLXML()$/;"	m
createSelfSignedCertificate	FakeKeyStore.scala	/^  def createSelfSignedCertificate(keyPair: KeyPair): X509Certificate = {$/;"	m
createServer	NettyServer.scala	/^  def createServer(applicationPath: File): Option[NettyServer] = {$/;"	m
createStatement	DB.scala	/^  def createStatement() = registering(connection.createStatement())$/;"	m
createStatement	DB.scala	/^  def createStatement(resultSetType: Int, resultSetConcurrency: Int) = registering(connection.createStatement(resultSetType, resultSetConcurrency))$/;"	m
createStatement	DB.scala	/^  def createStatement(resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int) = registering(connection.createStatement(resultSetType, resultSetConcurrency, resultSetHoldability))$/;"	m
createStruct	DB.scala	/^  def createStruct(typeName: String, attributes: scala.Array[AnyRef]) = connection.createStruct(typeName, attributes)$/;"	m
css	LessCompiler.scala	/^      val css = ScriptableObject.getProperty(result, "css").asInstanceOf[String]$/;"	V
ctx	CoffeescriptCompiler.scala	/^    val ctx = Context.enter; ctx.setOptimizationLevel(-1)$/;"	V
ctx	JavascriptCompiler.scala	/^    val ctx = Context.enter; ctx.setOptimizationLevel(-1)$/;"	V
ctx	LessCompiler.scala	/^    val ctx = Context.enter$/;"	V
ctx	Logger.scala	/^        val ctx = LoggerFactory.getILoggerFactory.asInstanceOf[LoggerContext]$/;"	V
ctx	Logger.scala	/^    val ctx = LoggerFactory.getILoggerFactory.asInstanceOf[LoggerContext]$/;"	V
current	Concurrent.scala	/^        val current = ref.single.swap(Iteratee.flatten(next.future))$/;"	V
current	Concurrent.scala	/^        val current: Iteratee[E, Unit] = mainIteratee.single.swap(Done((), Input.Empty))$/;"	V
current	Concurrent.scala	/^        val current: Iteratee[E, Unit] = mainIteratee.single.swap(Iteratee.flatten(itPromise.future))$/;"	V
current	PlayLogger.scala	/^  private var current: Option[(File, Int, String)] = None$/;"	v
current	RequestBodyHandler.scala	/^      val current = atomic { implicit txn =>$/;"	V
current	WebSocketHandler.scala	/^        val current = iterateeRef.single.swap(Iteratee.flatten(eventuallyNext.future))$/;"	V
currentAnalysis	PlayReloader.scala	/^      var currentAnalysis = Option.empty[sbt.inc.Analysis]$/;"	v
currentApplicationClassLoader	PlayReloader.scala	/^      var currentApplicationClassLoader: Option[ClassLoader] = None$/;"	v
currentCl	ThreadsSpec.scala	/^        val currentCl = Thread.currentThread.getContextClassLoader$/;"	V
currentInfos	PlayAssetsCompiler.scala	/^      val currentInfos = watch(src).get.map(f => f -> FileInfo.lastModified(f)).toMap$/;"	V
currentMode	Configuration.scala	/^      val currentMode = Play.maybeApplication.map(_.mode).getOrElse(mode)$/;"	V
currentProducts	PlayReloader.scala	/^      var currentProducts = Map.empty[java.io.File, Long]$/;"	v
customConfig	PlayCommands.scala	/^    val customConfig = Option(System.getProperty("config.file"))$/;"	V
customConfigFile	PlayCommands.scala	/^      val customConfigFile = new File(location)$/;"	V
customFileName	PlayCommands.scala	/^    val customFileName = customConfig.map(f => Some((new File(f)).getName)).getOrElse(None)$/;"	V
cyan	Color.scala	/^  def cyan(str: String): String = if (isANSISupported) (CYAN + str + RESET) else str$/;"	m
cyan	Console.scala	/^  def cyan(str: String): String = if (isANSISupported) (CYAN + str + RESET) else str$/;"	m
d	Assets.scala	/^      val d = dfp.parseDateTime(date.replace(parsableTimezoneCode, "")).toDate$/;"	V
d	JsonValidSpec.scala	/^      val d = (new java.util.Date()).getTime()$/;"	V
d	JsonValidSpec.scala	/^      val d = new java.util.Date()$/;"	V
d	PlaySettings.scala	/^      val d = "play" %% "play" % play.core.PlayVersion.current$/;"	V
data	Anorm.scala	/^    def data(rs: java.sql.ResultSet) = columns.map(nb => rs.getObject(nb))$/;"	m
data	Anorm.scala	/^  protected[anorm] val data: List[Any]$/;"	V
data	ContentTypes.scala	/^          val data = parts.collect { case Left(DataPart(key, value)) => (key, value) }.groupBy(_._1).mapValues(_.map(_._2))$/;"	V
data	Fakes.scala	/^case class FakeHeaders(val data: Seq[(String, Seq[String])] = Seq.empty) extends Headers$/;"	V
data	FormSpec.scala	/^    val data = Map("date" -> "2012-01-01")$/;"	V
data	FormSpec.scala	/^    val data = Map("date" -> "30\/1\/2012")$/;"	V
data	FormatSpec.scala	/^      val data = Map("date" -> "00:00")$/;"	V
data	ParsingSpec.scala	/^      val data = Enumerator(List("xx", "kxckikixcki", "k", "kicockik", "isdkikodskikisd", "ksdlokiikik", "i").map(_.getBytes): _*)$/;"	V
data	ParsingSpec.scala	/^      val data = Enumerator(List("xx", "kxckikixckikio", "cockik", "isdodskikisd", "ksdloii").map(_.getBytes): _*)$/;"	V
data	ResultsSpec.scala	/^      val data = Map("user" -> "alice")$/;"	V
data	ResultsSpec.scala	/^      val data = Map("user" -> "kiki", "bad:key" -> "yop", "langs" -> "fr:en:de")$/;"	V
data	csrf.scala	/^            def data = toMap.toSeq$/;"	m
dataFormat	JsonValidSpec.scala	/^      implicit val dataFormat: Format[(String, Int)] = ($/;"	V
dataReads	JsonValidSpec.scala	/^      implicit val dataReads: Reads[(String, Int)] = ($/;"	V
dataReads	JsonValidSpec.scala	/^      implicit val dataReads: Reads[(String, Int)] = { import Reads.path._$/;"	V
dataWrites	JsonValidSpec.scala	/^      implicit val dataWrites: Writes[(String, Int)] = ($/;"	V
database	Evolutions.scala	/^    val database = databaseEvolutions(api, db)$/;"	V
databaseEvolutions	Evolutions.scala	/^  def databaseEvolutions(api: DBApi, db: String): Seq[Evolution] = {$/;"	m
datasource	DB.scala	/^    val datasource = new BoneCPDataSource$/;"	V
datasources	DB.scala	/^  val datasources: List[(DataSource, String)]$/;"	V
datasources	DB.scala	/^  val datasources: List[Tuple2[DataSource, String]] = dbNames.map { dbName =>$/;"	V
date	Forms.scala	/^  def date(pattern: String, timeZone: java.util.TimeZone = java.util.TimeZone.getDefault): Mapping[java.util.Date] = of[java.util.Date] as dateFormat(pattern, timeZone)$/;"	m
date	Forms.scala	/^  val date: Mapping[java.util.Date] = of[java.util.Date]$/;"	V
date	SqlParser.scala	/^  def date(columnName: String): RowParser[Date] = get[Date](columnName)(implicitly[Column[Date]])$/;"	m
dateForm	FormSpec.scala	/^    val dateForm = Form(("date" -> jodaDate("dd\/MM\/yyyy")))$/;"	V
dateForm	FormSpec.scala	/^    val dateForm = Form(("date" -> jodaDate))$/;"	V
dateForm	FormSpec.scala	/^    val dateForm = Form(("date" -> jodaLocalDate("dd\/MM\/yyyy")))$/;"	V
dateFormat	JsonSpec.scala	/^  val dateFormat = "yyyy-MM-dd'T'HH:mm:ss'Z'" \/\/ Iso8601 format (forgot timezone stuff)$/;"	V
dateParser	JsonSpec.scala	/^  val dateParser = new SimpleDateFormat(dateFormat)$/;"	V
dateReads	Reads.scala	/^  def dateReads(pattern: String, corrector: String => String = identity): Reads[java.util.Date] = new Reads[java.util.Date] {$/;"	m
dateToStatement	Anorm.scala	/^  implicit val dateToStatement = new ToStatement[java.util.Date] {$/;"	V
dateWrites	Writes.scala	/^  def dateWrites(pattern: String): Writes[java.util.Date] = new Writes[java.util.Date] {$/;"	m
dbApi	DB.scala	/^  private lazy val dbApi: DBApi = new BoneCPApi(dbConfig, app.classloader)$/;"	V
dbApi	Evolutions.scala	/^    lazy val dbApi = new BoneCPApi(app.configuration.getConfig("db").get, app.classloader)$/;"	V
dbApi	Evolutions.scala	/^    val dbApi = new BoneCPApi(c, classloader)$/;"	V
dbConfig	DB.scala	/^  lazy val dbConfig = app.configuration.getConfig("db").getOrElse(Configuration.empty)$/;"	V
dbNames	DB.scala	/^  private val dbNames = configuration.subKeys$/;"	V
dbPlugin	Application.scala	/^   * val dbPlugin = application.plugin(classOf[DBPlugin])$/;"	V
dbPlugin	Application.scala	/^   * val dbPlugin = application.plugin[DBPlugin].map(_.api).getOrElse(sys.error("problem with the plugin"))$/;"	V
dd	JsonValidSpec.scala	/^      val dd = df.parse(df.format(d))$/;"	V
ddj	JsonValidSpec.scala	/^      val ddj = org.joda.time.DateTime.parse(dfj.print(dj), dfj)$/;"	V
debug	LessCompiler.scala	/^      val debug = debugCompiler(source)$/;"	V
debug	Logger.scala	/^  def debug(message: => String) {$/;"	m
debug	Logger.scala	/^  def debug(message: => String, error: => Throwable) {$/;"	m
debugCompiler	LessCompiler.scala	/^  private lazy val debugCompiler = compiler(false)$/;"	V
decode	Http.scala	/^    def decode(cookieHeader: String): Seq[Cookie] = {$/;"	m
decode	Http.scala	/^    def decode(data: String): Map[String, String] = {$/;"	m
decodeFromCookie	Http.scala	/^    def decodeFromCookie(cookie: Option[Cookie]): T = {$/;"	m
decodedCookies	ResultsSpec.scala	/^      val decodedCookies = Cookies.decode(setCookieHeader).map(c => c.name -> c).toMap$/;"	V
decodedSession	ResultsSpec.scala	/^      val decodedSession = Session.decode(encodedSession)$/;"	V
decodedSession	ResultsSpec.scala	/^      val decodedSession = Session.decode(maliciousSession)$/;"	V
decryptAES	Crypto.scala	/^  def decryptAES(value: String): String = {$/;"	m
decryptAES	Crypto.scala	/^  def decryptAES(value: String, privateKey: String): String = {$/;"	m
deepMerge	JsValue.scala	/^  def deepMerge(other: JsObject): JsObject = {$/;"	m
default	Forms.scala	/^  def default[A](mapping: Mapping[A], value:A): Mapping[A] = OptionalMapping(mapping).transform(_.getOrElse(value), Some(_))$/;"	m
default	PlayLogger.scala	/^  def default(playPositionMapper: Position => Option[Position])(extra: ScopedKey[_] => Seq[AbstractLogger]) =$/;"	m
default	Selenium.scala	/^  def default(baseUrl: Option[String] = None) = of(classOf[HtmlUnitDriver], baseUrl)$/;"	m
defaultBacked	PlayLogger.scala	/^  def defaultBacked(useColor: Boolean = ConsoleLogger.formatEnabled): java.io.PrintWriter => ConsoleLogger =$/;"	m
defaultCharSet	Assets.scala	/^  private lazy val defaultCharSet = Play.configuration.getString("default.charset").getOrElse("utf-8")$/;"	V
defaultJavaSettings	PlaySettings.scala	/^  lazy val defaultJavaSettings = Seq[Setting[_]]($/;"	V
defaultLang	Messages.scala	/^  implicit lazy val defaultLang = {$/;"	V
defaultLocale	Messages.scala	/^    val defaultLocale = java.util.Locale.getDefault$/;"	V
defaultName	Console.scala	/^    val defaultName = path.getName$/;"	V
defaultOptions	JavascriptCompiler.scala	/^      val defaultOptions = new CompilerOptions()$/;"	V
defaultPrefix	RoutesCompiler.scala	/^            |lazy val defaultPrefix = { if(Routes.prefix.endsWith("\/")) "" else "\/" } $/;"	V
defaultProperties	DB.scala	/^        val defaultProperties = """?useUnicode=yes&characterEncoding=UTF-8&connectionCollation=utf8_general_ci"""$/;"	V
defaultScalaSettings	PlaySettings.scala	/^  lazy val defaultScalaSettings = Seq[Setting[_]]($/;"	V
defaultScreen	PlayLogger.scala	/^  def defaultScreen: AbstractLogger = ConsoleLogger()$/;"	m
defaultSettings	PlaySettings.scala	/^  lazy val defaultSettings = Seq[Setting[_]]($/;"	V
defaultSigned	OpenIDSpec.scala	/^  val defaultSigned = "op_endpoint,claimed_id,identity,return_to,response_nonce,assoc_handle"$/;"	V
defaultSigned	UserInfoSpec.scala	/^  val defaultSigned = "op_endpoint,claimed_id,identity,return_to,response_nonce,assoc_handle"$/;"	V
defaultTimeout	Promise.scala	/^  private[concurrent] lazy val defaultTimeout =$/;"	V
defaultTypes	MimeTypes.scala	/^  lazy val defaultTypes =$/;"	V
defaultUpStreamHandler	NettyServer.scala	/^  val defaultUpStreamHandler = new PlayDefaultUpstreamHandler(this, allChannels)$/;"	V
defaultValuesForm	FormSpec.scala	/^    val defaultValuesForm = Form($/;"	V
defineArguments	JavascriptCompiler.scala	/^      val defineArguments = """arguments = ['-o', '""" + source.getAbsolutePath + "']"$/;"	V
defining	FakeRuntime.scala	/^    def defining[T](t: T)(handler: T => Any) = {$/;"	m
defining	ScalaTemplate.scala	/^    def defining[T](t: T)(handler: T => Any) = {$/;"	m
definitions	OpenID.scala	/^      val definitions = (axRequired ++ axOptional).map(attribute => ("openid.ax.type." + attribute._1 -> attribute._2))$/;"	V
defs	ScalaTemplateCompiler.scala	/^      val defs = (template.sub ++ template.defs).map { i =>$/;"	V
delegate	OpenID.scala	/^        val delegate: Option[String] = localidRegex.findFirstIn(response.body)$/;"	V
delegateRegex	OpenID.scala	/^    private val delegateRegex = new Regex( """<link[^>]+openid[.]delegate[^>]+>""")$/;"	V
delete	WS.scala	/^    def delete(): Future[Response] = prepare("DELETE").execute$/;"	m
dependencies	LessCompiler.scala	/^                    var dependencies = [source];$/;"	v
dependencies	LessCompiler.scala	/^      val dependencies = ScriptableObject.getProperty(result, "dependencies").asInstanceOf[NativeArray]$/;"	V
dependencies	PlayAssetsCompiler.scala	/^        val dependencies = previousRelation.filter((original, compiled) => changedFiles.contains(original))._2s$/;"	V
deps	PlayCommands.scala	/^      val deps: Seq[Map[Symbol, Any]] = (report \\ "dependencies" \\ "module").flatMap { module =>$/;"	V
deps	PlayCommands.scala	/^    def deps(ref: ProjectRef): Seq[ProjectRef] =$/;"	m
describeResult	RoutesCompilerSpec.scala	/^      def describeResult[T](result: parser.ParseResult[T]) = result match {$/;"	m
deserialize	Http.scala	/^    def deserialize(data: Map[String, String]) = new Flash(data)$/;"	m
deserialize	Http.scala	/^    def deserialize(data: Map[String, String]) = new Session(data)$/;"	m
deserialize	JsValue.scala	/^  def deserialize(jp: JsonParser, ctxt: DeserializationContext): JsValue = {$/;"	m
devSettings	ApplicationProvider.scala	/^                lazy val devSettings: Map[String,String] = sbtLink.settings.asScala.toMap$/;"	V
devSettings	ApplicationProvider.scala	/^  def devSettings: Map[String,String]$/;"	m
devSettings	PlayKeys.scala	/^  val devSettings = SettingKey[Seq[(String,String)]]("play-dev-settings")$/;"	V
df	Assets.scala	/^  private val df: DateTimeFormatter =$/;"	V
df	JsonValidSpec.scala	/^      val df = new java.text.SimpleDateFormat("yyyy-MM-dd")$/;"	V
df	Reads.scala	/^      val df = new java.text.SimpleDateFormat(pattern)$/;"	V
df	Reads.scala	/^    val df = if (pattern == "") ISODateTimeFormat.localDateParser else DateTimeFormat.forPattern(pattern)$/;"	V
df	Reads.scala	/^    val df = org.joda.time.format.DateTimeFormat.forPattern(pattern)$/;"	V
dfj	JsonValidSpec.scala	/^      val dfj = org.joda.time.format.DateTimeFormat.forPattern("yyyy-MM-dd")$/;"	V
dfp	Assets.scala	/^  private val dfp: DateTimeFormatter =$/;"	V
dictionary	Anorm.scala	/^  private lazy val dictionary: Map[String, (ColumnName, Boolean, String)] =$/;"	V
dictionary2	Anorm.scala	/^  private lazy val dictionary2: Map[String, (ColumnName, Boolean, String)] = {$/;"	V
digest	Codecs.scala	/^    val digest = MessageDigest.getInstance("MD5")$/;"	V
digest	Codecs.scala	/^    val digest = MessageDigest.getInstance("SHA-1")$/;"	V
digest	RoutesCompiler.scala	/^      val digest = MessageDigest.getInstance("SHA-1")$/;"	V
digest	ScalaTemplateCompiler.scala	/^      val digest = MessageDigest.getInstance("SHA-1")$/;"	V
directories	JavascriptCompiler.scala	/^    val directories = dir.listFiles(new FileFilter {$/;"	V
discard	Http.scala	/^    def discard = DiscardingCookie(COOKIE_NAME, path, domain, secure)$/;"	m
discardingCookies	Results.scala	/^  def discardingCookies(cookies: DiscardingCookie*): A$/;"	m
discardingCookies	Results.scala	/^  def discardingCookies(cookies: DiscardingCookie*): AsyncResult = {$/;"	m
discardingCookies	Results.scala	/^  def discardingCookies(cookies: DiscardingCookie*): PlainResult = {$/;"	m
discardingCookies	Results.scala	/^  def discardingCookies(name: String, names: String*): A = discardingCookies((name :: names.toList).map(n => DiscardingCookie(n)):_*)$/;"	m
discardingErrors	Form.scala	/^  def discardingErrors: Form[T] = this.copy(errors = Seq.empty)$/;"	m
discoverServer	OpenID.scala	/^  def discoverServer(openID:String): Future[OpenIDServer] = {$/;"	m
discovery	DiscoverySpec.scala	/^    val discovery = new Discovery(ws.url)$/;"	V
discovery	OpenID.scala	/^  val discovery = new Discovery(ws)$/;"	V
discoveryUrl	OpenID.scala	/^    val discoveryUrl = normalizeIdentifier(openID)$/;"	V
display	PlayCommands.scala	/^        def display(modules: Seq[Seq[(String, String, String, Boolean)]]) {$/;"	m
dist	PlayCommands.scala	/^  val dist = TaskKey[File]("dist", "Build the standalone application package")$/;"	V
distDirectory	PlayKeys.scala	/^  val distDirectory = SettingKey[File]("play-dist")$/;"	V
distExcludes	PlayKeys.scala	/^  val distExcludes = SettingKey[Seq[String]]("dist-excludes")$/;"	V
distTask	PlayCommands.scala	/^  val distTask = (distDirectory, baseDirectory, playPackageEverything, dependencyClasspath in Runtime, target, normalizedName, version) map { (dist, root, packaged, dependencies, target, id, version) =>$/;"	V
dj	JsonValidSpec.scala	/^      val dj = new org.joda.time.DateTime()$/;"	V
doFilter	GlobalSettings.scala	/^  def doFilter(a: EssentialAction): EssentialAction = a$/;"	m
documentation	ApplicationProvider.scala	/^    val documentation = """\/@documentation\/?""".r$/;"	V
documentation	Router.scala	/^    def documentation: Seq[(String, String, String)]$/;"	m
documentationHome	ApplicationProvider.scala	/^    val documentationHome = Option(System.getProperty("play.home")).map(ph => new java.io.File(ph + "\/..\/documentation"))$/;"	V
dogFormat	JsonExtensionSpec.scala	/^      implicit val dogFormat = Json.format[Dog]$/;"	V
dogReads	JsonExtensionSpec.scala	/^      implicit val dogReads = Json.reads[Dog]$/;"	V
dogWrites	JsonExtensionSpec.scala	/^      implicit val dogWrites = Json.writes[Dog]$/;"	V
domain	Http.scala	/^    def domain: Option[String] = None$/;"	m
domain	Http.scala	/^    lazy val domain: String = host.split(':').head$/;"	V
done	NettyPromise.scala	/^      val done = (channelPromise.await(atMost.toMillis))$/;"	V
done	Task.scala	/^  var done: Boolean = true$/;"	v
doneOrError	WS.scala	/^      var doneOrError = false$/;"	v
dontAllowMissingConfig	Configuration.scala	/^  private[this] lazy val dontAllowMissingConfig = ConfigFactory.load(dontAllowMissingConfigOptions)$/;"	V
dontAllowMissingConfigOptions	Configuration.scala	/^  private[this] lazy val dontAllowMissingConfigOptions = ConfigParseOptions.defaults().setAllowMissing(false)$/;"	V
downToZero	Concurrent.scala	/^        val downToZero = atomic { implicit txn =>$/;"	V
downs	Evolutions.scala	/^    val downs = (nonConflictingDowns ++ conflictingDowns).map(e => DownScript(e, e.sql_down))$/;"	V
downsMarker	Evolutions.scala	/^    val downsMarker = """^#.*!Downs.*$""".r$/;"	V
drain	PlayLogger.scala	/^  def drain(log: (Level.Value, => String) => Unit) {$/;"	m
driver	DB.scala	/^      val driver = drivers.nextElement$/;"	V
driver	DB.scala	/^    val driver = configuration.getString(dbName + ".driver").getOrElse(error(dbName, "Missing configuration [db." + dbName + ".driver]"))$/;"	V
driver	Selenium.scala	/^    val driver = clazz.newInstance$/;"	V
drivers	DB.scala	/^    val drivers = DriverManager.getDrivers()$/;"	V
drop	Anorm.scala	/^  def drop[A](these: Var[Stream[A]], n: Int): Stream[A] = {$/;"	m
drop	Enumeratee.scala	/^  def drop[E](count: Int): Enumeratee[E, E] = new CheckDone[E, E] {$/;"	m
drop	TraversableIteratee.scala	/^  def drop[M](count: Int)(implicit p: M => scala.collection.TraversableLike[_, M]): Enumeratee[M, M] = new Enumeratee[M, M] {$/;"	m
drop3AndConsume	EnumerateesSpec.scala	/^      val drop3AndConsume = Enumeratee.dropWhile[String](_ != "4") &>>  Iteratee.consume[String]()$/;"	V
drop3AndConsume	EnumerateesSpec.scala	/^      val drop3AndConsume = Enumeratee.drop[String](3) &>>  Iteratee.consume[String]()$/;"	V
dropInputIfNotReady	Concurrent.scala	/^  def dropInputIfNotReady[E](duration: Long, unit: java.util.concurrent.TimeUnit = java.util.concurrent.TimeUnit.MILLISECONDS): Enumeratee[E, E] = new Enumeratee[E, E] {$/;"	m
dropWhile	Enumeratee.scala	/^  def dropWhile[E](p: E => Boolean): Enumeratee[E, E] = new CheckDone[E, E] {$/;"	m
ds	JsonValidSpec.scala	/^      val ds = new java.sql.Date(dd.getTime())$/;"	V
dt	JsonValidSpec.scala	/^      val dt = (new java.util.Date).getTime()$/;"	V
dueDate	Task.scala	/^  var dueDate: Date = _$/;"	v
dur	DiscoverySpec.scala	/^  val dur = Duration(10, TimeUnit.SECONDS)$/;"	V
dur	OpenIDSpec.scala	/^  val dur = Duration(10, TimeUnit.SECONDS)$/;"	V
duration	Configuration.scala	/^   * val duration = configuration.getLong("timeout.duration")$/;"	V
duration	JUnitXmlTestListener.scala	/^      val duration = end - start$/;"	V
duration	PlayCommands.scala	/^              val duration = System.currentTimeMillis - start$/;"	V
dynamic	RoutesCompiler.scala	/^          val dynamic = !instantiate.isEmpty$/;"	V
dynamic	RoutesCompiler.scala	/^    val dynamic = if (instantiate) "@" else ""$/;"	V
e	EnumeratorsSpec.scala	/^      val e = e1 interleave e2$/;"	V
e	EnumeratorsSpec.scala	/^    val e = Concurrent.patchPanel[Int](p => pp.redeem(p))$/;"	V
e	EnumeratorsSpec.scala	/^    val e = Enumerator.pushee[Int]((p => pp =p ))$/;"	V
e	EnumeratorsSpec.scala	/^    val e = for {$/;"	V
e	PlayTestListener.scala	/^                  val e = Option(te.error).getOrElse(new RuntimeException("some unexpected error occurred during test execution"))$/;"	V
e1	EnumeratorsSpec.scala	/^      val e1 = Enumerator(List(1),List(3),List(5),List(7)) >>> Enumerator.enumInput(Input.EOF)$/;"	V
e1	EnumeratorsSpec.scala	/^      val e1 = Enumerator(List(1),List(3),List(5),List(7))$/;"	V
e1	EnumeratorsSpec.scala	/^    val e1 = Enumerator(1, 2, 3, 4).onDoneEnumerating(firstDone.success(Unit))$/;"	V
e2	EnumeratorsSpec.scala	/^      val e2 = Enumerator(List(2),List(4),List(6),List(8))  >>> Enumerator.enumInput(Input.EOF)$/;"	V
e2	EnumeratorsSpec.scala	/^      val e2 = Enumerator(List(2),List(4),List(6),List(8))$/;"	V
e2	EnumeratorsSpec.scala	/^    val e2 = Enumerator.unfoldM[Boolean, Int](true) { first => if (first) firstDone.future.map(_ => Some(false, 5)) else Future.successful(None)}$/;"	V
eRegex	CoffeescriptCompiler.scala	/^      val eRegex = """.*Parse error on line (\\d+):.*""".r$/;"	V
eRegex	JavascriptCompiler.scala	/^      val eRegex = """.*Parse error on line (\\d+):.*""".r$/;"	V
eToScript	Comet.scala	/^      val eToScript = Enumeratee.map[E](data => Html("""<script type="text\/javascript">""" + callback + """(""" + encoder.toJavascriptMessage(data) + """);<\/script>"""))$/;"	V
ebeanEnabled	PlayKeys.scala	/^  val ebeanEnabled = SettingKey[Boolean]("play-ebean-enabled")$/;"	V
echo	Action.scala	/^   * val echo = Action { request =>$/;"	V
echo	Action.scala	/^   * val echo = Action(parse.anyContent) { request =>$/;"	V
echo	Action.scala	/^ * val echo = Action { request =>$/;"	V
eclipseCommandSettings	PlayEclipse.scala	/^  def eclipseCommandSettings(mainLang: String) = {$/;"	m
element	Cache.scala	/^      val element = new Element(key, value)$/;"	V
elems	RoutesCompiler.scala	/^      val elems = new ListBuffer[T]$/;"	V
elems	ScalaTemplateCompiler.scala	/^        val elems = new ListBuffer[T]$/;"	V
elseCall	ScalaTemplateCompiler.scala	/^      def elseCall: Parser[Simple] = {$/;"	m
email	Forms.scala	/^  val email: Mapping[String] = of[String] verifying Constraints.pattern($/;"	V
email	JsConstraints.scala	/^  def email(implicit reads:Reads[String]) : Reads[String] = $/;"	m
emailForm	FormSpec.scala	/^    val emailForm = Form($/;"	V
empty	Configuration.scala	/^  def empty = Configuration(ConfigFactory.empty())$/;"	m
empty	ContentTypes.scala	/^    def empty: BodyParser[Option[Any]] = BodyParser("empty") { request =>$/;"	m
empty	JavaResults.scala	/^  def empty = Results.EmptyContent()$/;"	m
empty	JsResult.scala	/^    def empty:JsResult[Nothing] = JsError(Seq())   $/;"	m
empty	Reads.scala	/^    def empty:Reads[Nothing] = new Reads[Nothing] { def reads(js: JsValue) = JsError(Seq()) }$/;"	m
empty	Templates.scala	/^  def empty = new Txt("")$/;"	m
empty	Templates.scala	/^  def empty = new Xml("")$/;"	m
empty	Templates.scala	/^  def empty: Html = new Html(new StringBuilder)$/;"	m
emptyCookie	Http.scala	/^    def emptyCookie: T$/;"	m
emptyCookie	Http.scala	/^    val emptyCookie = new Flash$/;"	V
emptyCookie	Http.scala	/^    val emptyCookie = new Session$/;"	V
emptyHeaders	JavaResults.scala	/^  def emptyHeaders = Map.empty[String, String]$/;"	m
enRef	Concurrent.scala	/^              val enRef = ref()$/;"	V
enabled	Cache.scala	/^  override lazy val enabled = {$/;"	V
enabled	Evolutions.scala	/^  override lazy val enabled = app.configuration.getConfig("db").isDefined && {$/;"	V
enabled	Plugins.scala	/^  def enabled: Boolean = true$/;"	m
encode	Http.scala	/^    def encode(cookies: Seq[Cookie]): String = {$/;"	m
encode	Http.scala	/^    def encode(data: Map[String, String]): String = {$/;"	m
encodeAsCookie	Http.scala	/^    def encodeAsCookie(data: T): Cookie = {$/;"	m
encoded	Http.scala	/^      val encoded = java.net.URLEncoder.encode(data.filterNot(_._1.contains(":")).map(d => d._1 + ":" + d._2).mkString("\\u0000"), "UTF-8")$/;"	V
encodedSession	ResultsSpec.scala	/^      val encodedSession = Session.encode(data)$/;"	V
encoder	Http.scala	/^      val encoder = new CookieEncoder(true)$/;"	V
encoder	csrf.scala	/^    val encoder = new Hex$/;"	V
encryptAES	Crypto.scala	/^  def encryptAES(value: String): String = {$/;"	m
encryptAES	Crypto.scala	/^  def encryptAES(value: String, privateKey: String): String = {$/;"	m
end	Concurrent.scala	/^        def end(e: Throwable) {$/;"	m
end	Concurrent.scala	/^      def end(e: Throwable) {$/;"	m
end	Concurrent.scala	/^    def end(e: Throwable)$/;"	m
end	JUnitXmlTestListener.scala	/^    var end = System.currentTimeMillis$/;"	v
end	Messages.scala	/^    def end = """\\s*""".r$/;"	m
end	RoutesCompiler.scala	/^    def end: util.matching.Regex = """\\s*""".r$/;"	m
endEveryone	Concurrent.scala	/^        def endEveryone() = {$/;"	m
engineConfig	Configuration.scala	/^   * val engineConfig = configuration.getSub("engine")$/;"	V
engineConfigs	Configuration.scala	/^   * val engineConfigs = configuration.getConfigList("engine")$/;"	V
engineProperties	Configuration.scala	/^   * val engineProperties = configuration.getObject("engine.properties")$/;"	V
engineProperties	Configuration.scala	/^   * val engineProperties = configuration.getObjectList("engine.properties")$/;"	V
ensureMatchedBrackets	ScalaTemplateCompiler.scala	/^      def ensureMatchedBrackets[T](p: Parser[T]): Parser[T] = Parser { in =>$/;"	m
entrySet	Configuration.scala	/^  def entrySet: Set[(String, ConfigValue)] = underlying.entrySet().asScala.map(e => e.getKey -> e.getValue).toSet$/;"	m
enum	WebSocket.scala	/^      val enum = Enumerator.flatten(p.map(_._2)(internalContext))$/;"	V
enumInput	Enumerator.scala	/^  def enumInput[E](e: Input[E]) = new Enumerator[E] {$/;"	m
enumerate	Enumerator.scala	/^  def enumerate[E](traversable : TraversableOnce[E])(implicit ctx:scala.concurrent.ExecutionContext): Enumerator[E]  = {$/;"	m
enumerator	Concurrent.scala	/^    val enumerator = new Enumerator[E] {$/;"	V
enumerator	ConcurrentSpec.scala	/^      val enumerator = Concurrent.unicast[String] { c =>$/;"	V
enumerator	ConcurrentSpec.scala	/^      val enumerator = Concurrent.unicast[String](onStart = { c =>$/;"	V
enumerator	EnumerateesSpec.scala	/^      val enumerator = Enumerator("One","Two","Three","Four", "Five", "Six")  $/;"	V
enumerator	EnumerateesSpec.scala	/^      val enumerator = Enumerator("One","Two","Three","Four", "Five", "Six")$/;"	V
enumerator	EnumerateesSpec.scala	/^      val enumerator = Enumerator("he","ybbb","bbb")  $/;"	V
enumerator	EnumerateesSpec.scala	/^      val enumerator = Enumerator(1,2,3,4)  $/;"	V
enumerator	EnumerateesSpec.scala	/^      val enumerator = Enumerator(1,2,3,4,5,6,7,8,9)$/;"	V
enumerator	EnumerateesSpec.scala	/^      val enumerator = Enumerator(Range(1,20).map(_.toString) :_*)  $/;"	V
enumerator	EnumerateesSpec.scala	/^      val enumerator = Enumerator(Range(1,20).map(_.toString) :_*)$/;"	V
enumerator	Enumerator.scala	/^   *   val enumerator: Enumerator[String] = Enumerator("kiki", "foo", "bar")$/;"	V
enumerator	Enumerator.scala	/^   *  val enumerator: Enumerator[String] = Enumerator( scala.io.Source.fromFile("myfile.txt").getLines ) $/;"	V
enumerator	EnumeratorsSpec.scala	/^    val enumerator = Enumerator.generateM(Future(if(it.hasNext) Some(it.next()) else None)) >>> Enumerator(12)$/;"	V
enumerator	EnumeratorsSpec.scala	/^    val enumerator = Enumerator.generateM(Future(if(it.hasNext) Some(it.next()) else None))$/;"	V
enumerator	EnumeratorsSpec.scala	/^    val enumerator = Enumerator.outputStream { outputStream =>$/;"	V
enumerator	EnumeratorsSpec.scala	/^    val enumerator = Enumerator.outputStream(o => os = o)$/;"	V
enumerator	EnumeratorsSpec.scala	/^    val enumerator = Enumerator.unfoldM[Int,Int](0)( s => Future(if(s > 10) None else Some((s+1,s+1)))) >>> Enumerator(12)$/;"	V
enumerator	JavaWebSocket.scala	/^      val enumerator = Enumerator.imperative[A]()$/;"	V
enumerator	PlayDefaultUpstreamHandler.scala	/^              val enumerator = websocketHandshake(ctx, nettyHttpRequest, e)(ws.frameFormatter)$/;"	V
enumerator	WebSocketHandler.scala	/^    val enumerator = new Enumerator[A] {$/;"	V
env	JNDI.scala	/^    val env = new java.util.Hashtable[String, String]$/;"	V
eof	Enumerator.scala	/^  def eof[A] = enumInput[A](Input.EOF)$/;"	m
eof	ScalaTemplateCompiler.scala	/^      def eof = """\\Z""".r$/;"	m
eofOrElse	Iteratee.scala	/^  def eofOrElse[E] = new {$/;"	m
equal	Http.scala	/^          var equal = 0$/;"	v
err	CoffeescriptCompiler.scala	/^    var err = List[String]()$/;"	v
err	JavascriptCompiler.scala	/^    var err = List[String]()$/;"	v
err	PlayEclipse.scala	/^    def err(node: Node) = throw new RuntimeException("error proccessing " + Node)$/;"	m
errReverse	CoffeescriptCompiler.scala	/^      val errReverse = err.reverse$/;"	V
errReverse	JavascriptCompiler.scala	/^      val errReverse = err.reverse$/;"	V
error	CoffeescriptCompiler.scala	/^        val error = e.getValue.asInstanceOf[Scriptable]$/;"	V
error	ConcurrentSpec.scala	/^      val error = Promise[String]$/;"	V
error	ContentTypes.scala	/^    def error[A](result: Result): BodyParser[A] = BodyParser("error, result=" + result) { request =>$/;"	m
error	Default.scala	/^  def error: Action[AnyContent] = Action {$/;"	m
error	Evolutions.scala	/^        val error = problem.getString("last_problem")$/;"	V
error	Form.scala	/^  def error(key: String): Option[FormError] = errors.find(_.key == key)$/;"	m
error	Form.scala	/^  lazy val error: Option[FormError] = errors.headOption$/;"	V
error	JavascriptCompiler.scala	/^        val error = compiler.getErrors().head$/;"	V
error	JavascriptCompiler.scala	/^      val error = "error in: " + in + " \\n" + errReverse.mkString("\\n")$/;"	V
error	LessCompiler.scala	/^        val error = e.getValue.asInstanceOf[Scriptable]$/;"	V
error	Logger.scala	/^  def error(message: => String) {$/;"	m
error	Logger.scala	/^  def error(message: => String, error: => Throwable) {$/;"	m
errorFile	JavascriptCompiler.scala	/^        val errorFile = all.find(f => f.getAbsolutePath() == error.sourceName)$/;"	V
errorResponse	OpenIDSpec.scala	/^      val errorResponse = (openIdResponse - "openid.mode") + ("openid.mode" -> Seq("error"))$/;"	V
errors	Form.scala	/^    val errors = collectErrors(value)$/;"	V
errors	Form.scala	/^  def errors(key: String): Seq[FormError] = errors.filter(_.key == key)$/;"	m
errorsAsJson	Form.scala	/^  def errorsAsJson(implicit lang: play.api.i18n.Lang): play.api.libs.json.JsValue = {$/;"	m
escape	FakeRuntime.scala	/^    def escape(text: String): T$/;"	m
escape	ScalaTemplate.scala	/^    def escape(text: String): T$/;"	m
escape	TemplateCompilerSpec.scala	/^    def escape(text: String) = Html(text.replace("<", "&lt;"))$/;"	m
escape	TemplateUtilsSpec.scala	/^          def escape(text: String) = Html(text.replace("<", "&lt;"))$/;"	m
escape	TemplateUtilsSpec.scala	/^          def escape(text: String) = Text(text)$/;"	m
escape	Templates.scala	/^  def escape(text: String) = Txt(text)$/;"	m
escape	Templates.scala	/^  def escape(text: String) = Xml(org.apache.commons.lang3.StringEscapeUtils.escapeXml(text))$/;"	m
escape	Templates.scala	/^  def escape(text: String): Html = {$/;"	m
escapedAt	ScalaTemplateCompiler.scala	/^      def escapedAt = at ~> at$/;"	m
etags	Assets.scala	/^  private val etags = (new java.util.concurrent.ConcurrentHashMap[String, String]()).asScala$/;"	V
eu.henkelmann.sbt	JUnitXmlTestListener.scala	/^package eu.henkelmann.sbt$/;"	p
events	JUnitXmlTestListener.scala	/^    val events: ListBuffer[TEvent] = new ListBuffer()$/;"	V
eventuallyBodyParser	PlayDefaultUpstreamHandler.scala	/^          val eventuallyBodyParser = scala.concurrent.Future(filteredAction(requestHeader))(play.api.libs.concurrent.Execution.defaultContext)$/;"	V
eventuallyEither	csrf.scala	/^          val eventuallyEither = Enumerator(b).run(parser(request))$/;"	V
eventuallyIter	Enumeratee.scala	/^      val eventuallyIter =$/;"	V
eventuallyIteratee	WebSocketHandler.scala	/^      val eventuallyIteratee = Promise[Iteratee[A, Any]]()$/;"	V
eventuallyNext	Concurrent.scala	/^          val eventuallyNext = Promise[Option[Input[E] => Iteratee[E,A]]]()$/;"	V
eventuallyNext	WebSocketHandler.scala	/^        val eventuallyNext = Promise[Iteratee[A, Any]]()$/;"	V
eventuallyResult	PlayDefaultUpstreamHandler.scala	/^          val eventuallyResult = eventuallyResultIteratee.flatMap(it => it.run)$/;"	V
eventuallyResultIteratee	PlayDefaultUpstreamHandler.scala	/^          val eventuallyResultIteratee = if (nettyHttpRequest.isChunked) {$/;"	V
evolution	Evolutions.scala	/^  val evolution: Evolution$/;"	V
evolution	ScriptSpec.scala	/^    override val evolution = Evolution(0, "", "")$/;"	V
evolutionScript	Evolutions.scala	/^  def evolutionScript(api: DBApi, path: File, applicationClassloader: ClassLoader, db: String): Seq[Product with Serializable with Script] = {$/;"	m
evolutions	Evolutions.scala	/^    val evolutions = application.getFile("conf\/evolutions\/" + db + "\/" + revision + ".sql");$/;"	V
exampleConfig	ConfigurationSpec.scala	/^  def exampleConfig = Configuration.from(Map("foo.bar1" -> "value1", "foo.bar2" -> "value2", "blah" -> "value3"))$/;"	m
execute	Anorm.scala	/^  def execute()(implicit connection: java.sql.Connection): Array[Int] = getFilledStatement(connection).executeBatch()$/;"	m
execute	Anorm.scala	/^  def execute()(implicit connection: java.sql.Connection): Boolean = getFilledStatement(connection).execute()$/;"	m
execute	WS.scala	/^    def execute(method: String): Future[Response] = prepare(method).execute$/;"	m
execute1	Anorm.scala	/^  def execute1(getGeneratedKeys: Boolean = false)(implicit connection: java.sql.Connection): (java.sql.PreparedStatement, Int) = {$/;"	m
executeInsert	Anorm.scala	/^  def executeInsert[A](generatedKeysParser: ResultSetParser[A] = scalar[Long].singleOpt)(implicit connection: java.sql.Connection): A = {$/;"	m
executeNativeCompiler	JavascriptCompiler.scala	/^  def executeNativeCompiler(in: String, source: File): String = {$/;"	m
executeUpdate	Anorm.scala	/^  def executeUpdate()(implicit connection: java.sql.Connection): Int =$/;"	m
executionContext	Invoker.scala	/^  val executionContext: scala.concurrent.ExecutionContext = system.dispatcher$/;"	V
exit	CoffeescriptCompiler.scala	/^    val exit = qb ! ProcessLogger((s) => out ::= s, (s) => err ::= s)$/;"	V
exit	JavascriptCompiler.scala	/^    val exit = qb ! ProcessLogger((s) => out ::= s, (s) => err ::= s)$/;"	V
expectedJson	JsonSpec.scala	/^      val expectedJson = JsArray(List(JsNull))$/;"	V
expectedJson	JsonSpec.scala	/^      val expectedJson = JsObject(List("foo" -> JsNull))$/;"	V
expectedJson	JsonSpec.scala	/^      val expectedJson = JsObject(List($/;"	V
expectedPost	JsonSpec.scala	/^      val expectedPost = Post("foobar", None)$/;"	V
expectedPost	JsonSpec.scala	/^      val expectedPost = Post("foobar", Some(dateParser.parse("2011-04-22T13:33:48Z")))$/;"	V
expression	RoutesCompiler.scala	/^    def expression: Parser[String] = (multiString | string | parentheses | brackets | """[^),?=\\n]""".r +) ^^ {$/;"	m
expression	ScalaTemplateCompiler.scala	/^      def expression: Parser[Display] = {$/;"	m
expressionPart	ScalaTemplateCompiler.scala	/^      def expressionPart: Parser[ScalaExpPart] = {$/;"	m
extend	Promise.scala	/^  def extend[B](k: Function1[Future[A], B])(implicit ec: ExecutionContext): Future[B] = {$/;"	m
extend1	Promise.scala	/^  def extend1[B](k: Function1[NotWaiting[A], B])(implicit ec: ExecutionContext): Future[B] = extend[B](p => k(p.value.get match { case scala.util.Failure(e) => Thrown(e); case scala.util.Success(a) => Redeemed(a) }))(ec)$/;"	m
extension	PlayCommands.scala	/^        val extension = p.name.split('.').last$/;"	V
externalMappings	PlayCommands.scala	/^    val externalMappings = externals.map {$/;"	V
extra	ScalaTemplateCompiler.scala	/^      val extra = TemplateAsFunctionCompiler.getFunctionMapping($/;"	V
extraConfig	DB.scala	/^    val extraConfig = configuration.getConfig(dbName).getOrElse(error(dbName, "Missing configuration [db." + dbName + "]"))$/;"	V
extractAxAttribute	OpenID.scala	/^    val extractAxAttribute: PartialFunction[String, (String, String)] = {$/;"	V
extracted	PlayCommands.scala	/^    val extracted = Project.extract(state)$/;"	V
extracted	PlayReloader.scala	/^    val extracted = Project.extract(state)$/;"	V
extracted._	PlayCommands.scala	/^    import extracted._$/;"	i
extractor	OpenID.scala	/^    val extractor = new UserInfoExtractor(queryString)$/;"	V
exts	PlayCommands.scala	/^        val exts = templateTypes(extension)$/;"	V
f	JsonSpec.scala	/^      val f = toJson(Map("k"->"v"))$/;"	V
f	PlayDefaultUpstreamHandler.scala	/^                      val f = e.getChannel.write(nettyResponse)$/;"	V
f	PlayDefaultUpstreamHandler.scala	/^                    val f = e.getChannel.write(HttpChunk.LAST_CHUNK);$/;"	V
f	PlayDefaultUpstreamHandler.scala	/^                val f = e.getChannel.write(nettyResponse)$/;"	V
f	PlayEclipse.scala	/^    val f = java.io.File.separator$/;"	V
f	ScalaTemplateCompiler.scala	/^        val f = "def f:%s = %s => apply%s".format($/;"	V
f	Selenium.scala	/^    val f = new Function[WebDriver, T]() {$/;"	V
f1	FormSpec.scala	/^        val f1 = ScalaForms.form.bind(Map("foo"->"0"))$/;"	V
f1	FormSpec.scala	/^        val f1 = ScalaForms.form.fillAndValidate(0)$/;"	V
f1	FormSpec.scala	/^      val f1 = ScalaForms.longNumberForm.fillAndValidate(0);$/;"	V
f1	FormSpec.scala	/^    val f1 = ScalaForms.defaultValuesForm.bindFromRequest( Map("pos" -> Seq("abc")) )$/;"	V
f2	FormSpec.scala	/^        val f2 = ScalaForms.form.bind(Map("foo"->"3"))$/;"	V
f2	FormSpec.scala	/^        val f2 = ScalaForms.form.fillAndValidate(3)$/;"	V
f2	FormSpec.scala	/^      val f2 = ScalaForms.longNumberForm.fillAndValidate(9000);$/;"	V
f3	FormSpec.scala	/^        val f3 = ScalaForms.form.bind(Map("foo"->"50"))$/;"	V
f3	FormSpec.scala	/^        val f3 = ScalaForms.form.fillAndValidate(50)$/;"	V
f3	FormSpec.scala	/^      val f3 = ScalaForms.longNumberForm.fillAndValidate(10);$/;"	V
f4	FormSpec.scala	/^        val f4 = ScalaForms.form.bind(Map("foo"->"333"))$/;"	V
f4	FormSpec.scala	/^        val f4 = ScalaForms.form.fillAndValidate(333)$/;"	V
f4	FormSpec.scala	/^      val f4 = ScalaForms.longNumberForm.fillAndValidate(42);$/;"	V
f5	FormSpec.scala	/^      val f5 = ScalaForms.emailForm.fillAndValidate("john@", "John")$/;"	V
f6	FormSpec.scala	/^      val f6 = ScalaForms.emailForm.fillAndValidate("john@zen.....com", "John")$/;"	V
f7	FormSpec.scala	/^      val f7 = ScalaForms.emailForm.fillAndValidate("john@zen.com", "John")$/;"	V
f8	FormSpec.scala	/^      val f8 = ScalaForms.emailForm.fillAndValidate("john@zen.museum", "John")$/;"	V
f9	FormSpec.scala	/^      val f9 = ScalaForms.emailForm.fillAndValidate("john@mail.zen.com", "John")$/;"	V
factory	WebSocketHandshake.scala	/^    val factory = new WebSocketServerHandshakerFactory(getWebSocketLocation(req),$/;"	V
failAt	TemplateParserSpec.scala	/^    def failAt(message: String, line: Int, column: Int): PartialFunction[parser.ParseResult[ScalaTemplateCompiler.Template], Boolean] = {$/;"	m
fakeApp	SpecsSpec.scala	/^  def fakeApp[A](elems: (String, String)*) = FakeApplication(additionalConfiguration = Map(elems:_*))$/;"	m
fastEnumerator	ConcurrentSpec.scala	/^      val fastEnumerator = Enumerator[Long](1,2,3,4,5,6,7,8,9,10) >>> Enumerator.eof$/;"	V
fastEnumerator	ConcurrentSpec.scala	/^      val fastEnumerator = Enumerator[Long](1,2,3,4,5,6,7,8,9,10)$/;"	V
fed	Iteratee.scala	/^              val fed = result.filter(!_.content.isEmpty).foldLeft(Future.successful(Array[Byte](), Cont(k))) { (p, m) =>$/;"	V
fedWithInitialChunk	Comet.scala	/^      val fedWithInitialChunk = Iteratee.flatten(Enumerator(initialChunk) |>> inner)$/;"	V
feed	Iteratee.scala	/^  def feed[AA >: A](in: Input[E]): Future[Iteratee[E, AA]] = {$/;"	m
feed	Results.scala	/^    def feed[C](content: Enumerator[C])(implicit writeable: Writeable[C]): SimpleResult[C] = {$/;"	m
field1	Form.scala	/^  val field1 = f1._2.withPrefix(f1._1).withPrefix(key)$/;"	V
field1	ObjectMappings.scala	/^  val field1 = f1._2.withPrefix(f1._1).withPrefix(key)$/;"	V
field10	ObjectMappings.scala	/^  val field10 = f10._2.withPrefix(f10._1).withPrefix(key)$/;"	V
field11	ObjectMappings.scala	/^  val field11 = f11._2.withPrefix(f11._1).withPrefix(key)$/;"	V
field12	ObjectMappings.scala	/^  val field12 = f12._2.withPrefix(f12._1).withPrefix(key)$/;"	V
field13	ObjectMappings.scala	/^  val field13 = f13._2.withPrefix(f13._1).withPrefix(key)$/;"	V
field14	ObjectMappings.scala	/^  val field14 = f14._2.withPrefix(f14._1).withPrefix(key)$/;"	V
field15	ObjectMappings.scala	/^  val field15 = f15._2.withPrefix(f15._1).withPrefix(key)$/;"	V
field16	ObjectMappings.scala	/^  val field16 = f16._2.withPrefix(f16._1).withPrefix(key)$/;"	V
field17	ObjectMappings.scala	/^  val field17 = f17._2.withPrefix(f17._1).withPrefix(key)$/;"	V
field18	ObjectMappings.scala	/^  val field18 = f18._2.withPrefix(f18._1).withPrefix(key)$/;"	V
field2	ObjectMappings.scala	/^  val field2 = f2._2.withPrefix(f2._1).withPrefix(key)$/;"	V
field3	ObjectMappings.scala	/^  val field3 = f3._2.withPrefix(f3._1).withPrefix(key)$/;"	V
field4	ObjectMappings.scala	/^  val field4 = f4._2.withPrefix(f4._1).withPrefix(key)$/;"	V
field5	ObjectMappings.scala	/^  val field5 = f5._2.withPrefix(f5._1).withPrefix(key)$/;"	V
field6	ObjectMappings.scala	/^  val field6 = f6._2.withPrefix(f6._1).withPrefix(key)$/;"	V
field7	ObjectMappings.scala	/^  val field7 = f7._2.withPrefix(f7._1).withPrefix(key)$/;"	V
field8	ObjectMappings.scala	/^  val field8 = f8._2.withPrefix(f8._1).withPrefix(key)$/;"	V
field9	ObjectMappings.scala	/^  val field9 = f9._2.withPrefix(f9._1).withPrefix(key)$/;"	V
fieldSet	JsValue.scala	/^  def fieldSet: Set[(String, JsValue)] = fields.toSet$/;"	m
fieldSysPath	PlayReloader.scala	/^          val fieldSysPath = classOf[ClassLoader].getDeclaredField("sys_paths")$/;"	V
fields	OpenID.scala	/^    val fields = (queryString - "openid.mode" + ("openid.mode" -> Seq("check_authentication")))$/;"	V
file	Configuration.scala	/^      val file = {$/;"	V
file	ContentTypes.scala	/^    def file(to: File): BodyParser[File] = BodyParser("file, to=" + to) { request =>$/;"	m
file	ContentTypes.scala	/^  def file(key: String): Option[FilePart[A]] = files.find(_.key == key)$/;"	m
file	LessCompiler.scala	/^        val file = new File(filename)$/;"	V
file	NettyServer.scala	/^        val file = new File(path)$/;"	V
file	PlayLogger.scala	/^    val file = new File(filename)$/;"	V
file	ScalaTemplateCompiler.scala	/^          val file = new BatchSourceFile(randomFileName(), src)$/;"	V
fileChanged	PlayReloader.scala	/^        val fileChanged = fileTimestamps.get(f.getAbsolutePath).map { timestamp =>$/;"	V
filePrefix	RoutesCompiler.scala	/^    val filePrefix = namespace.map(_ + "\/").getOrElse("") + "\/routes"$/;"	V
fileTimestamps	PlayReloader.scala	/^      var fileTimestamps = calculateTimestamps$/;"	v
fileToServe	ExternalAssets.scala	/^        val fileToServe = rootPath match {$/;"	V
filename	LessCompiler.scala	/^        val filename = ScriptableObject.getProperty(error, "filename").asInstanceOf[String]$/;"	V
filename	PlayCommands.scala	/^        val filename = for {$/;"	V
fill	Form.scala	/^  def fill(value: T): Form[T] = {$/;"	m
fillAndValidate	Form.scala	/^  def fillAndValidate(value: T): Form[T] = {$/;"	m
filledStatement	Anorm.scala	/^  def filledStatement(implicit connection: java.sql.Connection) = getFilledStatement(connection)$/;"	m
filter	Enumeratee.scala	/^  def filter[E](predicate: E => Boolean): Enumeratee[E, E] = new CheckDone[E, E] {$/;"	m
filter	JsConstraints.scala	/^  def filter[A](otherwise: ValidationError)(p:A => Boolean)(implicit reads:Reads[A]) = $/;"	m
filter	JsResult.scala	/^  def filter(otherwise:ValidationError)(p: A => Boolean): JsResult[A] =$/;"	m
filter	JsResult.scala	/^  def filter(p: A => Boolean): JsResult[A] =$/;"	m
filter	PlayLogger.scala	/^  def filter(level: Level.Value, message: String)(log: (Level.Value, => String) => Unit) {$/;"	m
filter	Promise.scala	/^  def filter(p: A => Boolean): Future[A] = null$/;"	m
filter	Reads.scala	/^  def filter(error:ValidationError)(f: A => Boolean): Reads[A] =$/;"	m
filter	Reads.scala	/^  def filter(f: A => Boolean):Reads[A] =$/;"	m
filter	Utils.scala	/^  def filter[EE >: E](p: A => Boolean, error: EE): MayErr[EE, A] = MayErr(e.right.filter(p).getOrElse(Left(error)))$/;"	m
filterAnnoyingErrorMessages	PlayExceptions.scala	/^  def filterAnnoyingErrorMessages(message: String): String = {$/;"	m
filterNot	Enumeratee.scala	/^  def filterNot[E](predicate: E => Boolean): Enumeratee[E, E] = filter(e => !predicate(e))$/;"	m
filterNot	JsConstraints.scala	/^  def filterNot[A](error:ValidationError)(p:A => Boolean)(implicit reads:Reads[A]) = $/;"	m
filterNot	JsResult.scala	/^  def filterNot(error:ValidationError)(p: A => Boolean): JsResult[A] =$/;"	m
filterNot	JsResult.scala	/^  def filterNot(p: A => Boolean): JsResult[A] =$/;"	m
filterNot	Reads.scala	/^  def filterNot(error:ValidationError)(f: A => Boolean): Reads[A] =$/;"	m
filterNot	Reads.scala	/^  def filterNot(f: A => Boolean): Reads[A] =$/;"	m
filterPathNode	JsPath.scala	/^    def filterPathNode(json: JsObject, node: PathNode, value: JsValue): JsResult[JsObject] = {$/;"	m
filterType	ScalaTemplateCompiler.scala	/^        def filterType(t: String) = t match {$/;"	m
filtered	PlayLogger.scala	/^      def filtered(message: String) = {$/;"	m
filteredAction	PlayDefaultUpstreamHandler.scala	/^          val filteredAction = app.map(_.global).getOrElse(DefaultGlobal).doFilter(a)$/;"	V
filters	PlayKeys.scala	/^  val filters = "play" %% "filters-helpers" % play.core.PlayVersion.current$/;"	V
finalAction	JavaAction.scala	/^    val finalAction = actionMixins.foldLeft[JAction[_ <: Any]](baseAction) {$/;"	V
finalSource	ScalaTemplateCompiler.scala	/^    def finalSource(absolutePath: String, contents: Array[Byte], generatedTokens: Seq[Any]): String = {$/;"	m
finalSource	ScalaTemplateCompiler.scala	/^    def finalSource(template: File, generatedTokens: Seq[Any]): String = {$/;"	m
finalTree	JsMacroImpl.scala	/^                    val finalTree = if(params.length > 1) {$/;"	V
findResource	PlayCommands.scala	/^          val findResource = classOf[ClassLoader].getDeclaredMethod("findResource", classOf[String])$/;"	V
findResources	PlayCommands.scala	/^          val findResources = classOf[ClassLoader].getDeclaredMethod("findResources", classOf[String])$/;"	V
findSideBar	ApplicationProvider.scala	/^              lazy val findSideBar: (Option[Path] => Option[Path]) = _ match {$/;"	V
findSignature	ScalaTemplateCompiler.scala	/^        def findSignature(tree: Tree): Option[DefDef] = {$/;"	m
findSource	PlayReloader.scala	/^      def findSource(className: String, line: java.lang.Integer): Array[java.lang.Object] = {$/;"	m
finish	RequestBodyHandler.scala	/^      def finish(it: Iteratee[Array[Byte], Result]) {$/;"	m
finished	Concurrent.scala	/^          val finished = atomic { implicit txn =>$/;"	V
finished	Concurrent.scala	/^        val finished = atomic { implicit txn =>$/;"	V
firefox	Selenium.scala	/^  def firefox(baseUrl: Option[String] = None) = of(classOf[FirefoxDriver], baseUrl)$/;"	m
first	PlayReloader.scala	/^              var first: (Option[(String, String, String)], Option[Int]) = (None, None)$/;"	v
firstDone	EnumeratorsSpec.scala	/^    val firstDone = Promise[Unit]$/;"	V
fixeds	RoutesCompiler.scala	/^                        val fixeds = routes.map(_.call.parameters.get(i).fixed).distinct$/;"	V
flash	Helpers.scala	/^  def flash(of: Result): Flash = Flash.decodeFromCookie(cookies(of).get(Flash.COOKIE_NAME))$/;"	m
flash	Http.scala	/^    lazy val flash: Flash = Flash.decodeFromCookie(cookies.get(Flash.COOKIE_NAME))$/;"	V
flashCookie	PlayDefaultUpstreamHandler.scala	/^          val flashCookie = {$/;"	V
flashing	Results.scala	/^  def flashing(flash: Flash): A$/;"	m
flashing	Results.scala	/^  def flashing(flash: Flash): AsyncResult = {$/;"	m
flashing	Results.scala	/^  def flashing(flash: Flash): PlainResult = {$/;"	m
flashing	Results.scala	/^  def flashing(values: (String, String)*): A$/;"	m
flashing	Results.scala	/^  def flashing(values: (String, String)*): AsyncResult = {$/;"	m
flashing	Results.scala	/^  def flashing(values: (String, String)*): PlainResult = flashing(Flash(values.toMap))$/;"	m
flatFold	Iteratee.scala	/^  def flatFold[B, C](done: (A, Input[E]) => Future[Iteratee[B, C]],$/;"	m
flatJson	JsonValidSpec.scala	/^      val flatJson = Json.obj($/;"	V
flatMap	Action.scala	/^  def flatMap[B](f: A => BodyParser[B]): BodyParser[B] = new BodyParser[B] {$/;"	m
flatMap	Anorm.scala	/^  def flatMap[B](f: ID => Option[B]) = toOption.flatMap(f)$/;"	m
flatMap	Enumerator.scala	/^  def flatMap[U](f: E => Enumerator[U]): Enumerator[U] = {$/;"	m
flatMap	Iteratee.scala	/^  def flatMap[B](f: A => Iteratee[E, B]): Iteratee[E, B] = self.pureFlatFold {$/;"	m
flatMap	JsResult.scala	/^    def flatMap[B](f: A => JsResult[B]): JsResult[B] = self match {$/;"	m
flatMap	JsResult.scala	/^  def flatMap[X](f: A => JsResult[X]): JsResult[X] = this match {$/;"	m
flatMap	Reads.scala	/^  def flatMap[B](f:A => Reads[B]):Reads[B] = Reads[B] { json =>$/;"	m
flatMap	SqlParser.scala	/^  def flatMap[B](k: A => RowParser[B]): RowParser[B] = RowParser(row => parent(row).flatMap(a => k(a)(row)))$/;"	m
flatMap	SqlParser.scala	/^  def flatMap[B](k: A => SqlResult[B]): SqlResult[B] = self match {$/;"	m
flatMap	Utils.scala	/^  def flatMap[B, EE >: E](f: A => MayErr[EE, B]): MayErr[EE, B] = {$/;"	m
flatMapInput	Iteratee.scala	/^  def flatMapInput[B](f: Step[E, A] => Iteratee[E, B]): Iteratee[E, B] = self.pureFlatFold(f)$/;"	m
flatMapM	Iteratee.scala	/^  def flatMapM[B](f: A => Future[Iteratee[E, B]]): Iteratee[E, B] = for {$/;"	m
flatMapTraversable	Iteratee.scala	/^  def flatMapTraversable[B, X](f: A => Iteratee[E, B])(implicit p: E => scala.collection.TraversableLike[X, E], bf: scala.collection.generic.CanBuildFrom[E, X, E]): Iteratee[E, B] = self.pureFlatFold {$/;"	m
flatten	Enumeratee.scala	/^  def flatten[From, To](futureOfEnumeratee: Future[Enumeratee[From, To]]) = new Enumeratee[From, To] {$/;"	m
flatten	Enumerator.scala	/^  def flatten[E](eventuallyEnum: Future[Enumerator[E]]): Enumerator[E] = new Enumerator[E] {$/;"	m
flatten	Iteratee.scala	/^  def flatten[E, A](i: Future[Iteratee[E, A]]): Iteratee[E, A] = new Iteratee[E, A] {$/;"	m
flatten	SqlParser.scala	/^  def flatten[T1, T2, R](implicit f: anorm.TupleFlattener[(T1 ~ T2) => R]): ((T1 ~ T2) => R) = f.f$/;"	m
flavor	PlayEclipse.scala	/^    val flavor = if (mainLang == SCALA) EclipseProjectFlavor.Scala else EclipseProjectFlavor.Java$/;"	V
fmap	Reads.scala	/^    def fmap[A, B](reads: Reads[A], f: A => B): Reads[B] = a.map(reads, f)$/;"	m
fold	Form.scala	/^  def fold[R](hasErrors: Form[T] => R, success: T => R): R = value.map(success(_)).getOrElse(hasErrors(this))$/;"	m
fold	Iteratee.scala	/^    def fold[B](folder: Step[E, A] => Future[B]): Future[B] = folder(Step.Cont(k))$/;"	m
fold	Iteratee.scala	/^    def fold[B](folder: Step[E, A] => Future[B]): Future[B] = folder(Step.Done(a, e))$/;"	m
fold	Iteratee.scala	/^    def fold[B](folder: Step[E, A] => Future[B]): Future[B] = i.flatMap(_.fold(folder))$/;"	m
fold	Iteratee.scala	/^    def fold[B](folder: Step[E, Nothing] => Future[B]): Future[B] = folder(Step.Error(msg, e))$/;"	m
fold	Iteratee.scala	/^  def fold[B](folder: Step[E, A] => Future[B]): Future[B]$/;"	m
fold	Iteratee.scala	/^  def fold[E, A](state: A)(f: (A, E) => A): Iteratee[E, A] = {$/;"	m
fold	JsResult.scala	/^  def fold[X](invalid: Seq[(JsPath, Seq[ValidationError])] => X, valid: A => X): X = this match {$/;"	m
fold	Promise.scala	/^  def fold[B](onError: Throwable => B, onSuccess: A => B): B = this match {$/;"	m
fold1	Iteratee.scala	/^  def fold1[B](done: (A, Input[E]) => Future[B],$/;"	m
fold1	Iteratee.scala	/^  def fold1[E, A](state: Future[A])(f: (A, E) => Future[A]): Iteratee[E, A] = {$/;"	m
fold2	Iteratee.scala	/^  def fold2[E, A](state: A)(f: (A, E) => Future[(A, Boolean)]): Iteratee[E, A] = {$/;"	m
foldM	Iteratee.scala	/^  def foldM[E, A](state: A)(f: (A, E) => Future[A]): Iteratee[E, A] = {$/;"	m
folder	Enumerator.scala	/^        val folder = Iteratee.fold2[E, Iteratee[U, A]](iteratee)((it, e) => f(e)(it).flatMap(newIt => Iteratee.isDoneOrError(newIt).map((newIt, _))))$/;"	V
folderIteratee	EnumerateesSpec.scala	/^      val folderIteratee = $/;"	V
foo	Configuration.scala	/^ * val foo = config.getString("foo").getOrElse("boo")$/;"	V
fooStream	Json.scala	/^   *   val fooStream: Enumerator[Foo] = ???$/;"	V
fooStream	Json.scala	/^   *   val fooStream: Enumerator[Foo] = jsonStream &> Json.fromJson$/;"	V
forExpression	ScalaTemplateCompiler.scala	/^      def forExpression: Parser[Display] = {$/;"	m
forExtension	MimeTypes.scala	/^  def forExtension(ext: String): Option[String] = types.get(ext)$/;"	m
forField	Form.scala	/^  def forField[R](key: String)(handler: Field => R): R = handler(this(key))$/;"	m
forFileName	MimeTypes.scala	/^  def forFileName(name: String) = name.split('.').takeRight(1).headOption.flatMap(forExtension(_))$/;"	m
foreach	Anorm.scala	/^  def foreach(f: ID => Unit) = toOption.foreach(f)$/;"	m
foreach	Iteratee.scala	/^  def foreach[E](f: E => Unit): Iteratee[E, Unit] = fold[E, Unit](())((_, e) => f(e))$/;"	m
foreach	JsResult.scala	/^    def foreach(f: A => Unit): Unit = self match {$/;"	m
foreach	JsResult.scala	/^  def foreach(f: A => Unit): Unit = this match {$/;"	m
form	DynamicFormSpec.scala	/^      val form = new DynamicForm().bindFromRequest(new DummyRequest(Map("foo" -> Array("bar"))))$/;"	V
form	DynamicFormSpec.scala	/^      val form = new DynamicForm().bindFromRequest(new DummyRequest(Map()))$/;"	V
form	DynamicFormSpec.scala	/^      val form = new DynamicForm().fill(Map("foo" -> "bar"))$/;"	V
form	Form.scala	/^case class Field(private val form: Form[_], name: String, constraints: Seq[(String, Seq[Any])], format: Option[(String, Seq[Any])], errors: Seq[FormError], value: Option[String]) {$/;"	V
form	FormSpec.scala	/^    val form = Form($/;"	V
form	PartialValidationSpec.scala	/^      val form = Form.form(classOf[SomeForm], classOf[Partial]).bind(Map("prop2" -> "Hello", "prop3" -> "abc").asJava)$/;"	V
form	PartialValidationSpec.scala	/^      val form = Form.form(classOf[SomeForm], classOf[Partial]).bind(Map("prop3" -> "abc").asJava)$/;"	V
form1	PartialValidationSpec.scala	/^      val form1 = Form.form(classOf[SomeForm]).bind(Map("prop2" -> "Hello").asJava)$/;"	V
form2	PartialValidationSpec.scala	/^      val form2 = Form.form(classOf[SomeForm]).bind(Map("prop2" -> "Hello", "prop3" -> "abcd").asJava)$/;"	V
formUrlEncoded	JavaParsers.scala	/^  def formUrlEncoded(maxLength: Int): BodyParser[RequestBody] = parse.maxLength(orDefault(maxLength), parse.urlFormEncoded(Integer.MAX_VALUE)).map {$/;"	m
format	FakeRuntime.scala	/^      def format(pattern: String) = {$/;"	m
format	Form.scala	/^  override val format = wrapped.format$/;"	V
format	Form.scala	/^  override val format: Option[(String, Seq[Any])] = binder.format$/;"	V
format	Form.scala	/^  override val format: Option[(String, Seq[Any])] = wrapped.format$/;"	V
format	Form.scala	/^  val format: Option[(String, Seq[Any])] = None$/;"	V
format	FormatSpec.scala	/^      val format = Formats.dateFormat("HH:mm", TimeZone.getTimeZone("America\/Los_Angeles"))$/;"	V
format	JsPath.scala	/^  def format[T](implicit f: Format[T]): OFormat[T] = Format.at[T](this)(f)$/;"	m
format	JsPath.scala	/^  def format[T](r: Reads[T])(implicit w: Writes[T]): OFormat[T] = Format.at[T](this)(Format(r, w))$/;"	m
format	JsPath.scala	/^  def format[T](w: Writes[T])(implicit r: Reads[T]): OFormat[T] = Format.at[T](this)(Format(r, w))$/;"	m
format	Json.scala	/^  def format[A] = macro JsMacroImpl.formatImpl[A]$/;"	m
format	ScalaTemplate.scala	/^      def format(pattern: String) = {$/;"	m
format.Formats._	FormSpec.scala	/^   import format.Formats._$/;"	i
format._	Form.scala	/^import format._$/;"	i
format._	ObjectMappings.scala	/^import format._$/;"	i
format2	FormatSpec.scala	/^      val format2 = Formats.dateFormat("HH:mm", TimeZone.getTimeZone("GMT+0000"))$/;"	V
formatImpl	JsMacroImpl.scala	/^  def formatImpl[A : c.WeakTypeTag](c: Context) : c.Expr[Format[A]] = {$/;"	m
formatNullable	JsPath.scala	/^  def formatNullable[T](implicit f: Format[T]): OFormat[Option[T]] = Format.nullable[T](this)(f)$/;"	m
formatOpt	JsPath.scala	/^  def formatOpt[T](implicit f: Format[T]): OFormat[Option[T]] = Format.optional[T](this)(f)$/;"	m
formatTree	JsMacroImpl.scala	/^                          val formatTree = $/;"	V
formats	Form.scala	/^  val formats: Map[String, (String, Seq[Any])] = mapping.mappings.map { m =>$/;"	V
formatted	PlayCommands.scala	/^              val formatted = duration match {$/;"	V
formatted	PlayCommands.scala	/^          val formatted = (Seq(module.get('module).map {$/;"	V
found	JsPath.scala	/^      var found = false $/;"	v
found	JsValue.scala	/^          var found = false$/;"	v
frameFormatter	WebSocket.scala	/^case class WebSocket[A](f: RequestHeader => (Enumerator[A], Iteratee[A, Unit]) => Unit)(implicit val frameFormatter: WebSocket.FrameFormatter[A]) extends Handler {$/;"	V
frameReceived	WebSocketHandler.scala	/^      def frameReceived(ctx: ChannelHandlerContext, input: Input[A]) {$/;"	m
from	Configuration.scala	/^  def from(data: Map[String, Any]) = {$/;"	m
fromCallback	Enumerator.scala	/^  def fromCallback[E](retriever: () => Future[Option[E]],$/;"	m
fromCallback1	Enumerator.scala	/^  def fromCallback1[E](retriever: Boolean => Future[Option[E]],$/;"	m
fromFile	Enumerator.scala	/^  def fromFile(file: java.io.File, chunkSize: Int = 1024 * 8): Enumerator[Array[Byte]] = {$/;"	m
fromJson	Form.scala	/^  def fromJson(prefix: String = "", js: JsValue): Map[String, String] = js match {$/;"	m
fromJson	Json.scala	/^  def fromJson[A : Reads]: Enumeratee[JsValue, A] =$/;"	m
fromJson	Json.scala	/^  def fromJson[T](json: JsValue)(implicit fjs: Reads[T]): JsResult[T] = fjs.reads(json)$/;"	m
fromPath	Router.scala	/^    def fromPath[T](key: String, default: Option[T] = None)(implicit binder: PathBindable[T]): Param[T] = {$/;"	m
fromQuery	Router.scala	/^    def fromQuery[T](key: String, default: Option[T] = None)(implicit binder: QueryStringBindable[T]): Param[T] = {$/;"	m
fromStream	Enumerator.scala	/^  def fromStream(input: java.io.InputStream, chunkSize: Int = 1024 * 8) = {$/;"	m
ft	PlayCommands.scala	/^        val ft = new OfflineFileTransform(t, cl, classes.getAbsolutePath, classes.getAbsolutePath)$/;"	V
fullConfiguration	Application.scala	/^  private lazy val fullConfiguration = global.onLoadConfig(initialConfiguration, path, classloader, mode)$/;"	V
fullIn	Iteratee.scala	/^        val fullIn = (e, eIn) match {$/;"	V
fullJump	Iteratee.scala	/^    val fullJump = needleSize$/;"	V
fullMatch	Iteratee.scala	/^        val fullMatch = Range(needleSize - 1, -1, -1).forall(scan => needle(scan) == piece(scan + startScan))$/;"	V
fullUrl	Results.scala	/^    val fullUrl = url + Option(queryString).filterNot(_.isEmpty).map { params =>$/;"	V
fulle	Reads.scala	/^          val fulle = r.filter( _.isLeft ).map( _.left.get )$/;"	V
func	JsonValidSpec.scala	/^      def func = { JsNumber(dt + 100) }$/;"	m
functionType	ScalaTemplateCompiler.scala	/^        val functionType = "(" + params.map(group => "(" + group.map {$/;"	V
functionalCanBuildOWrites	Writes.scala	/^  implicit val functionalCanBuildOWrites:FunctionalCanBuild[OWrites] = new FunctionalCanBuild[OWrites] {$/;"	V
functionalSyntaxPkg	JsMacroImpl.scala	/^    val functionalSyntaxPkg = Select(Select(libsPkg, "functional"), "syntax")$/;"	V
future	Akka.scala	/^  def future[T](body: => T)(implicit app: Application): Future[T] = {$/;"	m
future	ConcurrentSpec.scala	/^      val future = enumerator |>>> Cont {$/;"	V
future	EnumeratorsSpec.scala	/^    val future = enumerator |>>> Iteratee.flatten(promiseIteratee.future)$/;"	V
futureOfResult	EnumeratorsSpec.scala	/^    val futureOfResult = Enumerator.enumerate(iterator) |>>> $/;"	V
futureOfResult	EnumeratorsSpec.scala	/^    val futureOfResult = Enumerator.enumerate(seq) |>>> $/;"	V
gen	JsValue.scala	/^    val gen = stringJsonGenerator(sw)$/;"	V
genCall	RoutesCompiler.scala	/^                    def genCall(route: Route, localNames: Map[String, String] = Map()) = "      return _wA({method:\\"%s\\", url:%s%s})".format($/;"	m
genCall	RoutesCompiler.scala	/^                    def genCall(route: Route, localNames: Map[String, String] = Map()) = """Call("%s", %s%s)""".format($/;"	m
generate	csrf.scala	/^    def generate: Token = {$/;"	m
generateCode	ScalaTemplateCompiler.scala	/^    def generateCode(packageName: String, name: String, root: Template, resultType: String, formatterType: String, additionalImports: String) = {$/;"	m
generateFinalTemplate	ScalaTemplateCompiler.scala	/^    def generateFinalTemplate(absolutePath: String, contents: Array[Byte], packageName: String, name: String, root: Template, resultType: String, formatterType: String, additionalImports: String): String = {$/;"	m
generateFinalTemplate	ScalaTemplateCompiler.scala	/^    def generateFinalTemplate(template: File, packageName: String, name: String, root: Template, resultType: String, formatterType: String, additionalImports: String): String = {$/;"	m
generateFromJsValue	JsValue.scala	/^  def generateFromJsValue(jsValue: JsValue): String = {$/;"	m
generateM	Enumerator.scala	/^  def generateM[E](e: => Future[Option[E]]): Enumerator[E] = checkContinue0( new TreatCont0[E] {$/;"	m
generated	PlayAssetsCompiler.scala	/^        val generated: Seq[(File, java.io.File)] = (files x relativeTo(Seq(src \/ "assets"))).flatMap {$/;"	V
generated	RoutesCompiler.scala	/^      val generated = GeneratedSource(source)$/;"	V
generated	RoutesCompiler.scala	/^    val generated = GeneratedSource(new File(packageDir, "routes_routing.scala"))$/;"	V
generated	ScalaTemplateCompiler.scala	/^        val generated = parseAndGenerateCode(templateName, Path(source).byteArray, source.getAbsolutePath, resultType, formatterType, additionalImports)$/;"	V
generated	ScalaTemplateCompiler.scala	/^      val generated = GeneratedSource(source)$/;"	V
generated	ScalaTemplateCompiler.scala	/^      val generated = generateCode(packageName, name, root, resultType, formatterType, additionalImports)$/;"	V
generated	ScalaTemplateCompiler.scala	/^      val generated = parseAndGenerateCode(templateName, content.getBytes(Codec.UTF8), source.getAbsolutePath, resultType, formatterType, additionalImports)$/;"	V
generated	ScalaTemplateCompiler.scala	/^      val generated = {$/;"	V
generatedClasses	TemplateCompilerSpec.scala	/^  val generatedClasses = new File("src\/templates-compiler\/target\/test\/generated-classes")$/;"	V
generatedDir	TemplateCompilerSpec.scala	/^  val generatedDir = new File("src\/templates-compiler\/target\/test\/generated-templates")$/;"	V
generatedFile	ScalaTemplateCompiler.scala	/^    def generatedFile(template: File, sourceDirectory: File, generatedDirectory: File) = {$/;"	m
generatedFileVirtual	ScalaTemplateCompiler.scala	/^    def generatedFileVirtual(template: File, sourceDirectory: File) = {$/;"	m
get	Anorm.scala	/^  def get(columnName: String) = {$/;"	m
get	Anorm.scala	/^  def get: ID = toOption.get$/;"	m
get	Anorm.scala	/^  def get[A](a: String)(implicit c: Column[A]): MayErr[SqlRequestError, A] = SqlParser.get(a)(c)(this) match {$/;"	m
get	ApplicationProvider.scala	/^  def get = Right(application)$/;"	m
get	ApplicationProvider.scala	/^  def get = {$/;"	m
get	ApplicationProvider.scala	/^  def get: Either[Throwable, Application]$/;"	m
get	Cache.scala	/^    def get(key: String): Option[Any] = {$/;"	m
get	Cache.scala	/^  def get(key: String)(implicit app: Application): Option[Any] = {$/;"	m
get	Cache.scala	/^  def get(key: String): Option[Any]$/;"	m
get	Form.scala	/^  def get: T = value.get$/;"	m
get	FormSpec.scala	/^    def get(name: String) = null$/;"	m
get	Http.scala	/^      def get(name: String) = cookies.get(name)$/;"	m
get	Http.scala	/^    def get(key: String) = data.get(key)$/;"	m
get	Http.scala	/^    def get(key: String): Option[String] = getAll(key).headOption$/;"	m
get	Http.scala	/^    def get(name: String): Option[Cookie]$/;"	m
get	JavaHelpers.scala	/^        def get(name: String) = (for (cookie <- req.cookies.get(name))$/;"	m
get	JavaResults.scala	/^      def get(name: String) = {$/;"	m
get	JsResult.scala	/^  def get: A$/;"	m
get	JsResult.scala	/^  def get: Nothing = throw new NoSuchElementException("JsError.get")$/;"	m
get	JsResult.scala	/^  def get:T = value$/;"	m
get	Messages.scala	/^  def get(code: String): Option[Lang] = {$/;"	m
get	Promise.scala	/^  def get: A = this match {$/;"	m
get	SqlParser.scala	/^  def get[T](columnName: String)(implicit extractor: anorm.Column[T]): RowParser[T] = RowParser { row =>$/;"	m
get	TemplateParserSpec.scala	/^    def get(templateName: String) = {$/;"	m
get	Utils.scala	/^  def get = e.fold(e => throw new RuntimeException(e.toString), a => a)$/;"	m
get	WS.scala	/^    def get(): Future[Response] = prepare("GET").execute$/;"	m
get	WS.scala	/^    def get[A](consumer: ResponseHeaders => Iteratee[Array[Byte], A]): Future[Iteratee[Array[Byte], A]] =$/;"	m
getAHCResponse	WS.scala	/^  def getAHCResponse = ahcResponse$/;"	m
getAcceptedIssuers	NettyServer.scala	/^  def getAcceptedIssuers() = nullArray$/;"	m
getAliased	Anorm.scala	/^  def getAliased(aliasName: String) = {$/;"	m
getAliased	SqlParser.scala	/^  def getAliased[T](aliasName: String)(implicit extractor: anorm.Column[T]): RowParser[T] = RowParser { row =>$/;"	m
getAll	Http.scala	/^    def getAll(key: String): Seq[String] = (toMap.get(key):Option[Seq[String]]).toSeq.flatten$/;"	m
getAs	Cache.scala	/^  def getAs[T](key: String)(implicit app: Application, ct: ClassTag[T]): Option[T] = {$/;"	m
getAutoCommit	DB.scala	/^  def getAutoCommit() = connection.getAutoCommit()$/;"	m
getBody	JavaResults.scala	/^  def getBody(result: play.mvc.Result): Array[Byte] = result.getWrappedResult match {$/;"	m
getBoolean	Configuration.scala	/^  def getBoolean(path: String): Option[Boolean] = readValue(path, underlying.getBoolean(path))$/;"	m
getBooleanList	Configuration.scala	/^  def getBooleanList(path: String): Option[java.util.List[java.lang.Boolean]] = readValue(path, underlying.getBooleanList(path))$/;"	m
getBytes	Configuration.scala	/^  def getBytes(path: String): Option[Long] = readValue(path, underlying.getBytes(path))$/;"	m
getBytesList	Configuration.scala	/^  def getBytesList(path: String): Option[java.util.List[java.lang.Long]] = readValue(path, underlying.getBytesList(path))$/;"	m
getCatalog	DB.scala	/^  def getCatalog() = connection.getCatalog()$/;"	m
getChunks	Iteratee.scala	/^  def getChunks[E]: Iteratee[E, List[E]] = fold[E, List[E]](Nil) { (els, chunk) => chunk +: els }.map(_.reverse)$/;"	m
getClientInfo	DB.scala	/^  def getClientInfo() = connection.getClientInfo()$/;"	m
getClientInfo	DB.scala	/^  def getClientInfo(name: String) = connection.getClientInfo(name)$/;"	m
getConfig	Configuration.scala	/^  def getConfig(path: String): Option[Configuration] = readValue(path, underlying.getConfig(path)).map(Configuration(_))$/;"	m
getConfig	SpecsSpec.scala	/^  def getConfig(key: String)(implicit app: Application) = app.configuration.getString(key)$/;"	m
getConfigList	Configuration.scala	/^  def getConfigList(path: String): Option[java.util.List[Configuration]] = readValue[java.util.List[_ <: Config]](path, underlying.getConfigList(path)).map { configs => configs.asScala.map(Configuration(_)).asJava }$/;"	m
getConnection	DB.scala	/^  def getConnection(name: String = "default", autocommit: Boolean = true)(implicit app: Application): Connection = app.plugin[DBPlugin].map(_.api.getConnection(name, autocommit)).getOrElse(error)$/;"	m
getConnection	DB.scala	/^  def getConnection(name: String, autocommit: Boolean = true): Connection = {$/;"	m
getControllerInstance	GlobalSettings.scala	/^  def getControllerInstance[A](controllerClass: Class[A]): A = {$/;"	m
getCookies	JavaResults.scala	/^  def getCookies(result: play.mvc.Result): JCookies = result.getWrappedResult match {$/;"	m
getDataSource	DB.scala	/^  def getDataSource(name: String = "default")(implicit app: Application): DataSource = app.plugin[DBPlugin].map(_.api.getDataSource(name)).getOrElse(error)$/;"	m
getDataSource	DB.scala	/^  def getDataSource(name: String): DataSource = {$/;"	m
getDataSource	DB.scala	/^  def getDataSource(name: String): DataSource$/;"	m
getDataSourceURL	DB.scala	/^  def getDataSourceURL(name: String): String = {$/;"	m
getDouble	Configuration.scala	/^  def getDouble(path: String): Option[Double] = readValue(path, underlying.getDouble(path))$/;"	m
getDoubleList	Configuration.scala	/^  def getDoubleList(path: String): Option[java.util.List[java.lang.Double]] = readValue(path, underlying.getDoubleList(path))$/;"	m
getExistingFile	Application.scala	/^  def getExistingFile(relativePath: String): Option[File] = Option(getFile(relativePath)).filter(_.exists)$/;"	m
getExistingFile	Play.scala	/^  def getExistingFile(relativePath: String)(implicit app: Application): Option[File] = {$/;"	m
getFile	Application.scala	/^  def getFile(relativePath: String): File = new File(path, relativePath)$/;"	m
getFile	Play.scala	/^  def getFile(relativePath: String)(implicit app: Application): File = {$/;"	m
getFiles	JavaParsers.scala	/^          lazy val getFiles = {$/;"	V
getFilledStatement	Anorm.scala	/^  def getFilledStatement(connection: java.sql.Connection, getGeneratedKeys: Boolean = false) = {$/;"	m
getFilledStatement	Anorm.scala	/^  def getFilledStatement(connection: java.sql.Connection, getGeneratedKeys: Boolean = false): java.sql.PreparedStatement =$/;"	m
getFilledStatement	Anorm.scala	/^  def getFilledStatement(connection: java.sql.Connection, getGeneratedKeys: Boolean = false): java.sql.PreparedStatement$/;"	m
getFlash	JavaResults.scala	/^  def getFlash(result: play.mvc.Result): JFlash = result.getWrappedResult match {$/;"	m
getFunctionMapping	ScalaTemplateCompiler.scala	/^      def getFunctionMapping(signature: String, returnType: String): (String, String, String) = synchronized {$/;"	m
getHandlerFor	Server.scala	/^  def getHandlerFor(request: RequestHeader): Either[Result, (Handler, Application)] = {$/;"	m
getHeader	Server.scala	/^  def getHeader(header: String): String$/;"	m
getHeader	WebSocketHandler.scala	/^    def getHeader(header: String) = req.getHeader(header)$/;"	m
getHeaders	JavaResults.scala	/^  def getHeaders(result: play.mvc.Result): java.util.Map[String, String] = result.getWrappedResult match {$/;"	m
getHoldability	DB.scala	/^  def getHoldability() = connection.getHoldability()$/;"	m
getInside	Enumeratee.scala	/^    def getInside[T](it: Iteratee[E, T]): Future[(Option[Either[(String, Input[E]), (T, Input[E])]], Iteratee[E, T])] = {$/;"	m
getInt	Configuration.scala	/^  def getInt(path: String): Option[Int] = readValue(path, underlying.getInt(path))$/;"	m
getIntList	Configuration.scala	/^  def getIntList(path: String): Option[java.util.List[java.lang.Integer]] = readValue(path, underlying.getIntList(path))$/;"	m
getList	Configuration.scala	/^  def getList(path: String): Option[ConfigList] = readValue(path, underlying.getList(path))$/;"	m
getLong	Configuration.scala	/^  def getLong(path: String): Option[Long] = readValue(path, underlying.getLong(path))$/;"	m
getLongList	Configuration.scala	/^  def getLongList(path: String): Option[java.util.List[java.lang.Long]] = readValue(path, underlying.getLongList(path))$/;"	m
getMajorVersion	ProxyDriver.scala	/^  def getMajorVersion() = proxied.getMajorVersion$/;"	m
getMetaData	DB.scala	/^  def getMetaData() = connection.getMetaData()$/;"	m
getMilliseconds	Configuration.scala	/^  def getMilliseconds(path: String): Option[Long] = readValue(path, underlying.getMilliseconds(path))$/;"	m
getMillisecondsList	Configuration.scala	/^  def getMillisecondsList(path: String): Option[java.util.List[java.lang.Long]] = readValue(path, underlying.getMillisecondsList(path))$/;"	m
getMinorVersion	ProxyDriver.scala	/^  def getMinorVersion() = proxied.getMinorVersion$/;"	m
getNanoseconds	Configuration.scala	/^  def getNanoseconds(path: String): Option[Long] = readValue(path, underlying.getNanoseconds(path))$/;"	m
getNanosecondsList	Configuration.scala	/^  def getNanosecondsList(path: String): Option[java.util.List[java.lang.Long]] = readValue(path, underlying.getNanosecondsList(path))$/;"	m
getNetworkTimeout	DB.scala	/^  def getNetworkTimeout() = {$/;"	m
getNext	Enumeratee.scala	/^    def getNext(it1: Iteratee[E, A], it2: Iteratee[E, B]): Iteratee[E, C] = {$/;"	m
getNumber	Configuration.scala	/^  def getNumber(path: String): Option[Number] = readValue(path, underlying.getNumber(path))$/;"	m
getNumberList	Configuration.scala	/^  def getNumberList(path: String): Option[java.util.List[java.lang.Number]] = readValue(path, underlying.getNumberList(path))$/;"	m
getObject	Configuration.scala	/^  def getObject(path: String): Option[ConfigObject] = readValue(path, underlying.getObject(path))$/;"	m
getObjectList	Configuration.scala	/^  def getObjectList(path: String): Option[java.util.List[_ <: ConfigObject]] = readValue[java.util.List[_ <: ConfigObject]](path, underlying.getObjectList(path))$/;"	m
getOrElse	Anorm.scala	/^  def getOrElse[V >: ID](id: V): V = toOption.getOrElse(id)$/;"	m
getOrElse	Cache.scala	/^  def getOrElse[A](key: String, expiration: Int = 0)(orElse: => A)(implicit app: Application, ct: ClassTag[A]): A = {$/;"	m
getOrElse	JsResult.scala	/^  def getOrElse[AA >: A](t: => AA): AA = this match {$/;"	m
getParentLogger	ProxyDriver.scala	/^  def getParentLogger() = null$/;"	m
getPatchCord	Concurrent.scala	/^      def getPatchCord() = new Enumerator[E] {$/;"	m
getPatchCord	Concurrent.scala	/^    def getPatchCord(): Enumerator[E]$/;"	m
getPipeline	NettyServer.scala	/^    def getPipeline = {$/;"	m
getProblems	PlayReloader.scala	/^      def getProblems(incomplete: Incomplete): Seq[xsbti.Problem] = {$/;"	m
getPropertyInfo	ProxyDriver.scala	/^  def getPropertyInfo(user: String, properties: java.util.Properties) = proxied.getPropertyInfo(user, properties)$/;"	m
getQueryString	Http.scala	/^    def getQueryString(key: String): Option[String] = queryString.get(key).flatMap(_.headOption)$/;"	m
getReflections	ReflectionsCache.scala	/^  def getReflections(classLoader: ClassLoader, pkg: String) = {$/;"	m
getSchema	DB.scala	/^  def getSchema() = {$/;"	m
getSession	JavaResults.scala	/^  def getSession(result: play.mvc.Result): JSession = result.getWrappedResult match {$/;"	m
getStatus	JavaResults.scala	/^  def getStatus(result: play.mvc.Result): Int = result.getWrappedResult match {$/;"	m
getString	Configuration.scala	/^  def getString(path: String, validValues: Option[Set[String]] = None): Option[String] = readValue(path, underlying.getString(path)).map { value =>$/;"	m
getStringData	WS.scala	/^    def getStringData = body.getOrElse("")$/;"	m
getStringList	Configuration.scala	/^  def getStringList(path: String): Option[java.util.List[java.lang.String]] = readValue(path, underlying.getStringList(path))$/;"	m
getToken	csrf.scala	/^    def getToken(request: RequestHeader): Option[Token] = COOKIE_NAME$/;"	m
getTransactionIsolation	DB.scala	/^  def getTransactionIsolation() = connection.getTransactionIsolation()$/;"	m
getTypeMap	DB.scala	/^  def getTypeMap() = connection.getTypeMap()$/;"	m
getWarnings	DB.scala	/^  def getWarnings() = connection.getWarnings()$/;"	m
getWrappedResult	JavaResults.scala	/^    def getWrappedResult = r$/;"	m
giter8.Giter8	Console.scala	/^import giter8.Giter8$/;"	i
giter8._	Console.scala	/^          import giter8._$/;"	i
global	Application.scala	/^  def global: GlobalSettings = {$/;"	m
global	Application.scala	/^  def global: GlobalSettings$/;"	m
global	CoffeescriptCompiler.scala	/^    val global = new Global; global.init(ctx)$/;"	V
global	Fakes.scala	/^  override lazy val global = withGlobal.getOrElse(super.global)$/;"	V
global	JavaAction.scala	/^        val global = play.api.Play.maybeApplication.map(_.global).getOrElse(play.api.DefaultGlobal)$/;"	V
global	JavascriptCompiler.scala	/^    val global = new Global; global.init(ctx)$/;"	V
global	LessCompiler.scala	/^    val global = new Global; global.init(ctx)$/;"	V
global	Play.scala	/^  def global(implicit app: Application): GlobalSettings = app.global$/;"	m
global	ScalaTemplateCompiler.scala	/^        val global = CompilerInstance.compiler$/;"	V
global	ScalaTemplateCompiler.scala	/^        val global: scala.tools.nsc.interactive.Global$/;"	V
globalClass	Application.scala	/^  private lazy val globalClass = initialConfiguration.getString("application.global").getOrElse(initialConfiguration.getString("global").map { g =>$/;"	V
globalError	Configuration.scala	/^  def globalError(message: String, e: Option[Throwable] = None): PlayException = {$/;"	m
globalError	Form.scala	/^  def globalError: Option[FormError] = globalErrors.headOption$/;"	m
globalErrors	Form.scala	/^  def globalErrors: Seq[FormError] = errors.filter(_.key.isEmpty)$/;"	m
globalInstance	Application.scala	/^  private lazy val globalInstance: GlobalSettings = Threads.withContextClassLoader(self.classloader) {$/;"	V
green	Color.scala	/^  def green(str: String): String = if (isANSISupported) (GREEN + str + RESET) else str$/;"	m
green	Console.scala	/^  def green(str: String): String = if (isANSISupported) (GREEN + str + RESET) else str$/;"	m
grouped	Enumeratee.scala	/^  def grouped[From] = new {$/;"	m
gzippedResource	Assets.scala	/^      val gzippedResource = Play.resource(resourceName + ".gz")$/;"	V
gzippedResponse	Assets.scala	/^                val gzippedResponse = (gzippedResource.isDefined, isGzipped) match {$/;"	V
h	Concurrent.scala	/^  def broadcast[E](e: Enumerator[E], interestIsDownToZero: Broadcaster => Unit = _ => ()): (Enumerator[E], Broadcaster) = { lazy val h: Hub[E] = hub(e, () => interestIsDownToZero(h)); (h.getPatchCord(), h) }$/;"	V
h2Command	PlayCommands.scala	/^  val h2Command = Command.command("h2-browser") { state: State =>$/;"	V
h2ServerClass	PlayCommands.scala	/^      val h2ServerClass = commonLoader.loadClass(classOf[org.h2.tools.Server].getName)$/;"	V
handle	Http.scala	/^    def handle(result: Result): Unit$/;"	m
handle	PlayDefaultUpstreamHandler.scala	/^          def handle(result: Result) {$/;"	m
handleAction	PlayDefaultUpstreamHandler.scala	/^        def handleAction(a:EssentialAction,app:Option[Application]){$/;"	m
handleDataPart	ContentTypes.scala	/^      def handleDataPart: PartHandler[Part] = {$/;"	m
handleFilePart	ContentTypes.scala	/^      def handleFilePart[A](handler: FileInfo => Iteratee[Array[Byte], A]): PartHandler[FilePart[A]] = {$/;"	m
handleFilePartAsTemporaryFile	ContentTypes.scala	/^      def handleFilePartAsTemporaryFile: PartHandler[FilePart[TemporaryFile]] = {$/;"	m
handlePart	ContentTypes.scala	/^            val handlePart = Enumeratee.map[MatchInfo[Array[Byte]]](_.content).transform(readPart)$/;"	V
handlePart	ContentTypes.scala	/^      def handlePart(fileHandler: PartHandler[FilePart[File]]): PartHandler[Part] = {$/;"	m
handleWebCommand	ApplicationProvider.scala	/^  def handleWebCommand(request: play.api.mvc.RequestHeader, sbtLink: play.core.SBTLink, path: java.io.File): Option[Result]$/;"	m
handleWebCommand	ApplicationProvider.scala	/^  def handleWebCommand(requestHeader: play.api.mvc.RequestHeader): Option[Result] = None$/;"	m
handleWebCommand	Evolutions.scala	/^  def handleWebCommand(request: play.api.mvc.RequestHeader, sbtLink: play.core.SBTLink, path: java.io.File): Option[play.api.mvc.Result] = {$/;"	m
handler	Action.scala	/^  def handler: play.api.mvc.Handler = {$/;"	m
handler	ContentTypes.scala	/^      val handler: Multipart.PartHandler[Either[Part, FilePart[A]]] =$/;"	V
handler	Helpers.scala	/^    val handler = app.global.onRouteRequest(rhWithCt)$/;"	V
handler	PlayDefaultUpstreamHandler.scala	/^        val handler = server.getHandlerFor(untaggedRequestHeader)$/;"	V
handlerFor	Router.scala	/^    def handlerFor(request: RequestHeader): Option[Handler] = {$/;"	m
has	PathParts.scala	/^  def has(key: String): Boolean = parts.exists {$/;"	m
has	Router.scala	/^  def has(key: String): Boolean = parts.exists {$/;"	m
hasChanged	PlayReloader.scala	/^              def hasChanged = true$/;"	m
hasChanged	PlayReloader.scala	/^            def hasChanged = _changed$/;"	m
hasChangedFiles	PlayReloader.scala	/^      def hasChangedFiles: Boolean = monitoredFiles.exists{ f =>$/;"	m
hasDown	Evolutions.scala	/^          val hasDown = script.find(_.isInstanceOf[DownScript]).isDefined$/;"	V
hasErrors	Form.scala	/^  def hasErrors: Boolean = !errors.isEmpty$/;"	m
hasErrors	Form.scala	/^  lazy val hasErrors: Boolean = !errors.isEmpty$/;"	V
hasErrors	Reads.scala	/^        var hasErrors = false$/;"	v
hasGlobalErrors	Form.scala	/^  def hasGlobalErrors: Boolean = !globalErrors.isEmpty$/;"	m
hasRec	JsMacroImpl.scala	/^                    var hasRec = false$/;"	v
hash	Evolutions.scala	/^        val hash = problem.getString("hash").substring(0, 7)$/;"	V
hash	Evolutions.scala	/^  val hash = sha1(sql_down.trim + sql_up.trim)$/;"	V
hash	RoutesCompiler.scala	/^      val hash = lines.find(_.startsWith("\/\/ @HASH:")).map(m => m.trim.drop(9)).getOrElse("")$/;"	V
head	Iteratee.scala	/^  def head[E]: Iteratee[E, Option[E]] = {$/;"	m
head	TraversableIteratee.scala	/^  def head[E] = new { $/;"	m
head	WS.scala	/^    def head(): Future[Response] = prepare("HEAD").execute$/;"	m
headFields	JsValue.scala	/^          val headFields = fields match {$/;"	V
header	Helpers.scala	/^  def header(header: String, of: Result): Option[String] = headers(of).get(header)$/;"	m
header	PlayDefaultUpstreamHandler.scala	/^          val header = r.header$/;"	V
header	Results.scala	/^  val header: ResponseHeader$/;"	V
header	WS.scala	/^    def header(name: String): Option[String] = headers.get(name).flatMap(_.headOption)$/;"	m
header	WS.scala	/^  def header(key: String): Option[String] = Option(ahcResponse.getHeader(key))$/;"	m
headerString	ContentTypes.scala	/^              val headerString = new String(headerBytes)$/;"	V
headers	ContentTypes.scala	/^              val headers = headerString.lines.map { header =>$/;"	V
headers	FormSpec.scala	/^  def headers() = new java.util.HashMap[String, Array[String]]()$/;"	m
headers	Helpers.scala	/^  def headers(of: Result): Map[String, String] = of match {$/;"	m
headers	Http.scala	/^        val headers = _headers$/;"	V
headers	Http.scala	/^      def headers = rh.headers$/;"	m
headers	Http.scala	/^      def headers = self.headers$/;"	m
headers	Http.scala	/^    def headers = request.headers$/;"	m
headers	Http.scala	/^    def headers: Headers$/;"	m
headers	JavaHelpers.scala	/^      def headers = req.headers.toMap.map(e => e._1 -> e._2.toArray).asJava$/;"	m
headers	PlayDefaultUpstreamHandler.scala	/^          def headers = rHeaders$/;"	m
headers	WS.scala	/^          val headers = h.getHeaders()$/;"	V
headers	WS.scala	/^      val headers = hdrs.foldLeft(this.headers)((m, hdr) =>$/;"	V
headers	WS.scala	/^    protected var headers: Map[String, Seq[String]] = Map()$/;"	v
heading	Enumeratee.scala	/^  def heading[E](es: Enumerator[E]) = new Enumeratee[E,E] {$/;"	m
hello	Action.scala	/^   * val hello = Action {$/;"	V
hello	TemplateCompilerSpec.scala	/^      val hello = helper.compile[((String) => Html)]("hello.scala.html", "html.hello")("World").toString.trim$/;"	V
helloForm	FormSpec.scala	/^    val helloForm = Form($/;"	V
helpCommand	Console.scala	/^  def helpCommand(args: Array[String]): (String, Int) = {$/;"	m
helper	JsMacroImpl.scala	/^                      val helper = newTermName("helper")$/;"	V
helper	TemplateCompilerSpec.scala	/^      val helper = new CompilerHelper(sourceDir, generatedDir, generatedClasses)$/;"	V
helperMember	JsMacroImpl.scala	/^                    val helperMember = Select( This(tpnme.EMPTY), "lazyStuff")$/;"	V
helperVal	JsMacroImpl.scala	/^                      val helperVal = ValDef($/;"	V
hexChars	Codecs.scala	/^  private val hexChars = Array('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f')$/;"	V
hexStringToByte	Codecs.scala	/^  def hexStringToByte(hexString: String): Array[Byte] = {$/;"	m
home	PlayJvm.scala	/^ * val home = javaHome.getOrElse(new File(System.getProperty("java.home")))$/;"	V
host	FormSpec.scala	/^  def host() = "localhost"$/;"	m
host	Http.scala	/^    lazy val host: String = headers.get(HeaderNames.HOST).getOrElse("")$/;"	V
host	JavaHelpers.scala	/^      def host = req.host$/;"	m
hostAndPath	RichUrl.scala	/^    def hostAndPath: String$/;"	m
hostname	JUnitXmlTestListener.scala	/^  val hostname = InetAddress.getLocalHost.getHostName$/;"	V
html	DynamicFormSpec.scala	/^      val html = inputText(form("foo")).body$/;"	V
html	TemplateUtilsSpec.scala	/^        val html = HtmlFormat.raw("<h1>") + HtmlFormat.escape("Hello <world>") + HtmlFormat.raw("<\/h1>")$/;"	V
htmlDescription	Evolutions.scala	/^  def htmlDescription = {$/;"	m
htmlDescription	Evolutions.scala	/^  def htmlDescription: String = {$/;"	m
httpOnly	Http.scala	/^    def httpOnly = true$/;"	m
httpOnly	Http.scala	/^    override val httpOnly = Play.maybeApplication.flatMap(_.configuration.getBoolean("session.httpOnly")).getOrElse(true)$/;"	V
httpPort	PlayCommands.scala	/^    val httpPort = Option(System.getProperty("http.port"))$/;"	V
httpVerb	RoutesCompiler.scala	/^    def httpVerb: Parser[HttpVerb] = namedError("GET" | "POST" | "PUT" | "PATCH" | "HEAD" | "DELETE" | "OPTIONS", "HTTP Verb expected") ^^ {$/;"	m
hub	Concurrent.scala	/^  def hub[E](e: Enumerator[E], interestIsDownToZero: () => Unit = () => ()): Hub[E] = {$/;"	m
hub	EnumeratorsSpec.scala	/^    val hub = Concurrent.hub(e)$/;"	V
humanScript	Evolutions.scala	/^        val humanScript = "# --- Rev:" + revision + "," + (if (state == "applying_up") "Ups" else "Downs") + " - " + hash + "\\n\\n" + script;$/;"	V
i	Enumerator.scala	/^          val i = iter.single.swap(Iteratee.flatten(p.future))$/;"	V
i	Filters.scala	/^        val i = it.future.map(_.map({r => p.success(r); result}))$/;"	V
i	MediaRange.scala	/^    val i = rhs.indexOf(';')$/;"	V
i1	EnumeratorsSpec.scala	/^    val i1 = Iteratee.fold[Int,Int](0){(s,i) => println(i);s+i}$/;"	V
iRedeemed	Promise.scala	/^        val iRedeemed = ref.single.getAndTransform(_ => true)$/;"	V
iable	SqlStatementParser.scala	/^  def variable = "{" ~> (ident ~ (("." ~> ident)?)) <~ "}" ^^ {$/;"	v
iantFunctorOFormat	Format.scala	/^  implicit val invariantFunctorOFormat:InvariantFunctor[OFormat] = new InvariantFunctor[OFormat] {$/;"	v
iantfunctorOWrites	Writes.scala	/^  implicit val contravariantfunctorOWrites:ContravariantFunctor[OWrites] = new ContravariantFunctor[OWrites] {$/;"	v
iantfunctorWrites	Writes.scala	/^  \/*implicit val contravariantfunctorWrites:ContravariantFunctor[Writes] = new ContravariantFunctor[Writes] {$/;"	v
id	Form.scala	/^  lazy val id: String = name.replace('.', '_').replace('[', '_').replace(']', '_')$/;"	V
id	Http.scala	/^        val id = _id$/;"	V
id	Http.scala	/^      def id = rh.id$/;"	m
id	Http.scala	/^      def id = self.id$/;"	m
id	Http.scala	/^    def id = request.id$/;"	m
id	Http.scala	/^    def id: Long $/;"	m
id	JsResult.scala	/^  \/\/def rebase(json: JsValue): JsResult[A] = fold(valid = JsSuccess(_), invalid = (_, e, g) => JsError(json, e, g))$/;"	V
id	JsResult.scala	/^  def fold[X](invalid: Seq[(JsPath, Seq[ValidationError])] => X, valid: A => X): X = this match {$/;"	V
id	JsValue.scala	/^    invalid = _ => None,$/;"	V
id	JsValue.scala	/^    invalid = e => throw new JsResultException(e)$/;"	V
id	JsValue.scala	/^    valid = identity,$/;"	V
id	JsValue.scala	/^    valid = v => Some(v)$/;"	V
id	OpenID.scala	/^      if (response.status == 200 && response.body.contains("is_valid:true")) {$/;"	V
id	OpenID.scala	/^    def id = params.get("openid.claimed_id").flatMap(_.headOption).orElse(params.get("openid.identity").flatMap(_.headOption))$/;"	m
id	OpenID.scala	/^    val id = extractor.id getOrElse (throw Errors.BAD_RESPONSE)$/;"	V
id	OpenIDError.scala	/^sealed abstract class OpenIDError(val id: String, val message: String) extends Throwable$/;"	V
id	OpenIDSpec.scala	/^      ws.response.body returns "is_valid:false\\n"$/;"	V
id	OpenIDSpec.scala	/^    ws.response.body returns "is_valid:true\\n" \/\/ http:\/\/openid.net\/specs\/openid-authentication-2_0.html#kvform$/;"	V
id	PlayDefaultUpstreamHandler.scala	/^          val id = requestIDs.incrementAndGet$/;"	V
id	Task.scala	/^  var id: Long = _$/;"	v
id	Validation.scala	/^  def ++(other: Invalid): Invalid = Invalid(this.errors ++ other.errors)$/;"	V
id	Validation.scala	/^  def apply(error: String, args: Any*): Invalid = Invalid(Seq(ValidationError(error, args: _*)))$/;"	V
id	Validation.scala	/^  def apply(error: ValidationError): Invalid = Invalid(Seq(error))$/;"	V
idValues	Configuration.scala	/^  def getString(path: String, validValues: Option[Set[String]] = None): Option[String] = readValue(path, underlying.getString(path)).map { value =>$/;"	V
identifier	RoutesCompiler.scala	/^    def identifier: Parser[String] = namedError(javaIdent, "Identifier expected")$/;"	m
identifier	ScalaTemplateCompiler.scala	/^      def identifier = as(ident, "identifier")$/;"	m
identity	OpenIDSpec.scala	/^  val identity = "http:\/\/example.com\/openid?id=C123&id"$/;"	V
identity	Reads.scala	/^    def identity = JsArray()$/;"	m
identity	Reads.scala	/^    def identity = JsObject(Seq())$/;"	m
identity	UserInfoSpec.scala	/^  val identity = "http:\/\/example.com\/openid?id=C123&id"$/;"	V
ignore	Iteratee.scala	/^  def ignore[E]: Iteratee[E, Unit] = fold[E, Unit](())((_, _) => ())$/;"	m
ignoreOutputStream	PlayJvm.scala	/^  def ignoreOutputStream = (out: OutputStream) => ()$/;"	m
ignoreWhiteSpace	Messages.scala	/^    def ignoreWhiteSpace = opt(whiteSpace)$/;"	m
ignoreWhiteSpace	RoutesCompiler.scala	/^    def ignoreWhiteSpace: Parser[Option[String]] = opt(whiteSpace)$/;"	m
ignored	Forms.scala	/^  def ignored[A](value: A): Mapping[A] = of(ignoredFormat(value))$/;"	m
importExpression	ScalaTemplateCompiler.scala	/^      def importExpression: Parser[Simple] = {$/;"	m
imported	LessCompiler.scala	/^                        var imported = LessCompiler.resolve(context[context.length - 1], path);$/;"	v
importedName	LessCompiler.scala	/^                        var importedName = String(imported.getAbsolutePath());$/;"	v
imports	ScalaTemplateCompiler.scala	/^      val imports = template.imports.map(_.code).mkString("\\n")$/;"	V
in	Concurrent.scala	/^        val in: Future[Input[E]] = atomic { implicit txn =>$/;"	V
inAllDependencies	PlayCommands.scala	/^  def inAllDependencies[T](base: ProjectRef, key: SettingKey[T], structure: Load.BuildStructure): Seq[T] = {$/;"	m
inAllDeps	PlayCommands.scala	/^  def inAllDeps[T](base: ProjectRef, deps: ProjectRef => Seq[ProjectRef], key: SettingKey[T], data: Settings[Scope]): Seq[T] =$/;"	m
inAllProjects	PlayCommands.scala	/^  def inAllProjects[T](allProjects: Seq[Reference], key: SettingKey[T], data: Settings[Scope]): Seq[T] =$/;"	m
inMemory	ContentTypes.scala	/^  private var inMemory = new ArrayBuffer[Byte] ++= initialData$/;"	v
inMemoryDatabase	Helpers.scala	/^  def inMemoryDatabase(name: String = "default", options: Map[String, String] = Map.empty[String, String]): Map[String, String] = {$/;"	m
inMemoryDatabaseConfiguration	HelpersSpec.scala	/^      val inMemoryDatabaseConfiguration = inMemoryDatabase("test")$/;"	V
inMemoryDatabaseConfiguration	HelpersSpec.scala	/^      val inMemoryDatabaseConfiguration = inMemoryDatabase("test", Map("MODE" -> "PostgreSQL", "DB_CLOSE_DELAY" -> "-1"))$/;"	V
inStream	ContentTypes.scala	/^        val inStream = new FileInputStream(backedByTemporaryFile.file)$/;"	V
include	RoutesCompiler.scala	/^    def include = "->" ~! separator ~ path ~ separator ~ router ~ ignoreWhiteSpace ^^ {$/;"	m
indexes	Form.scala	/^  def indexes(key: String, data: Map[String, String]): Seq[Int] = {$/;"	m
indexes	Form.scala	/^  lazy val indexes: Seq[Int] = {$/;"	V
indexes	TemplateMagicForJava.scala	/^      override lazy val indexes = jField.indexes.asScala.toSeq.map(_.toInt)$/;"	V
inferedImplicits	JsMacroImpl.scala	/^                val inferedImplicits = params.map(_.typeSignature).map{ implType =>      $/;"	V
info	Logger.scala	/^  def info(message: => String) {$/;"	m
info	Logger.scala	/^  def info(message: => String, error: => Throwable) {$/;"	m
init	Logger.scala	/^  def init(home: java.io.File) {$/;"	m
initialConfiguration	Application.scala	/^  protected lazy val initialConfiguration = Threads.withContextClassLoader(self.classloader) {$/;"	V
initialContext	JNDI.scala	/^  lazy val initialContext = {$/;"	V
inmap	Format.scala	/^    def inmap[A,B](fa:OFormat[A], f1:A => B, f2: B => A): OFormat[B] = OFormat[B]( (js: JsValue) => fa.reads(js).map(f1), (b: B) => fa.writes(f2(b)))$/;"	m
inner	Iteratee.scala	/^      val inner = in(a)$/;"	V
innerClient	WS.scala	/^      val innerClient = new AsyncHttpClient(asyncHttpConfig.build())$/;"	V
input	Application.scala	/^          def input = source.map(_._1).map(scalax.file.Path(_).string).orNull$/;"	m
input	Configuration.scala	/^      def input = Option(origin.url).map(_.asInput.string).orNull$/;"	m
input	Enumerator.scala	/^          val input = new Array[Byte](read)$/;"	V
input	JavascriptCompiler.scala	/^    def input = scalax.file.Path(jsFile).string$/;"	m
input	JavascriptCompiler.scala	/^    val input = Array[JSSourceFile](JSSourceFile.fromCode(name.getOrElse("unknown"), source))$/;"	V
input	JavascriptCompiler.scala	/^    val input = if (!simpleCheck) all.map(f => JSSourceFile.fromFile(f)).toArray else Array(JSSourceFile.fromFile(source))$/;"	V
input	LessCompiler.scala	/^                        var input = String(LessCompiler.readContent(imported));$/;"	v
input	Messages.scala	/^            def input = messageInput.string$/;"	m
input	PlayExceptions.scala	/^    def input = problem.position.sourceFile.map(scalax.file.Path(_).string).orNull$/;"	m
input	PlayExceptions.scala	/^    def input = scalax.file.Path(source).string$/;"	m
input	PlayExceptions.scala	/^    def input = source.filter(_.exists()).map(scalax.file.Path(_).string).orNull$/;"	m
input	PlayJvm.scala	/^  def input(connectInput: Boolean): OutputStream => Unit =$/;"	m
inputOrEmpty	Iteratee.scala	/^          def inputOrEmpty(a: Array[Byte]) = if (a.isEmpty) Input.Empty else Input.El(a)$/;"	m
inset	Reads.scala	/^      val inset = 6$/;"	V
instr	SqlStatementParser.scala	/^  def instr: Parser[List[(String, Option[String])]] = rep(literal | variable | other)$/;"	m
int	SqlParser.scala	/^  def int(columnName: String): RowParser[Int] = get[Int](columnName)(implicitly[Column[Int]])$/;"	m
intellijCommandSettings	PlayCommands.scala	/^  def intellijCommandSettings(mainLang: String) = {$/;"	m
interested	Concurrent.scala	/^      val interested = iteratees.single.swap(List())$/;"	V
interested	Concurrent.scala	/^      val interested: List[(Iteratee[E, _], Promise[Iteratee[E, _]])] = iteratees.single.swap(List())$/;"	V
interleave	Enumerator.scala	/^  def interleave[B >: E](other: Enumerator[B]): Enumerator[B] = Enumerator.interleave(this, other)$/;"	m
interleave	Enumerator.scala	/^  def interleave[E1, E2 >: E1](e1: Enumerator[E1], e2: Enumerator[E2]): Enumerator[E2] = new Enumerator[E2] {$/;"	m
interleave	Enumerator.scala	/^  def interleave[E](e1: Enumerator[E], es: Enumerator[E] *): Enumerator[E] = interleave(e1 +: es)$/;"	m
interleave	Enumerator.scala	/^  def interleave[E](es: Seq[Enumerator[E]]): Enumerator[E] = new Enumerator[E] {$/;"	m
internal.defaultExecutionContext	Iteratee.scala	/^import internal.defaultExecutionContext$/;"	i
internalContext	Execution.scala	/^  lazy val internalContext: scala.concurrent.ExecutionContext = {$/;"	V
internalContext	Promise.scala	/^    implicit val internalContext = play.core.Execution.internalContext$/;"	V
internalContext	RequestBodyHandler.scala	/^    implicit val internalContext = play.core.Execution.internalContext$/;"	V
internalExecutionContext	PlayDefaultUpstreamHandler.scala	/^  implicit val internalExecutionContext =  play.core.Execution.internalContext$/;"	V
invariantFunctorOFormat	Format.scala	/^  implicit val invariantFunctorOFormat:InvariantFunctor[OFormat] = new InvariantFunctor[OFormat] {$/;"	V
invocation	JavaAction.scala	/^  def invocation: JResult$/;"	m
invocation	Router.scala	/^          def invocation = call$/;"	m
invocation	Router.scala	/^          def invocation = javaAction.invocation$/;"	m
invoke	PlayReloader.scala	/^            def invoke(proxy: AnyRef, m: java.lang.reflect.Method, args: scala.Array[AnyRef]): AnyRef = {$/;"	m
invokeHandler	Router.scala	/^    def invokeHandler[T](call: => T, handler: HandlerDef)(implicit d: HandlerInvoker[T]): Handler = {$/;"	m
invokeWithContext	JavaHelpers.scala	/^  def invokeWithContext(request: RequestHeader, f: JRequest => Option[JResult]): Option[Result] = {$/;"	m
io.Codec	ScalaTemplateCompiler.scala	/^  import io.Codec$/;"	i
isANSISupported	Color.scala	/^  lazy val isANSISupported = {$/;"	V
isANSISupported	Console.scala	/^  lazy val isANSISupported = {$/;"	V
isClosed	Concurrent.scala	/^      var isClosed: Boolean = false$/;"	v
isClosed	DB.scala	/^  def isClosed() = connection.isClosed()$/;"	m
isCompleted	NettyPromise.scala	/^    def isCompleted: Boolean = channelPromise.isDone$/;"	m
isDebugEnabled	Logger.scala	/^  def isDebugEnabled = logger.isDebugEnabled$/;"	m
isDefined	Anorm.scala	/^  def isDefined: Boolean = toOption.isDefined$/;"	m
isDefined	Promise.scala	/^  def isDefined = this match { case Waiting => false; case _ => true }$/;"	m
isDev	Play.scala	/^  def isDev(implicit app: Application): Boolean = (app.mode == Mode.Dev)$/;"	m
isDisabled	DB.scala	/^  private lazy val isDisabled = {$/;"	V
isDoneOrError	Iteratee.scala	/^  def isDoneOrError[E, A](it: Iteratee[E, A]): Future[Boolean] = it.pureFold { case Step.Cont(_) => false; case _ => true }$/;"	m
isEOF	PlayCommands.scala	/^      def isEOF(c: Int): Boolean = c == 4$/;"	m
isEmpty	Http.scala	/^    def isEmpty: Boolean = data.isEmpty$/;"	m
isEnabled	Configuration.scala	/^   * val isEnabled = configuration.getString("engine.isEnabled")$/;"	V
isErrorEnabled	Logger.scala	/^  def isErrorEnabled = logger.isErrorEnabled$/;"	m
isFullJump	Iteratee.scala	/^          val isFullJump = jump == fullJump$/;"	V
isGenerated	RoutesCompiler.scala	/^    def isGenerated: Boolean = source.isDefined$/;"	m
isInfoEnabled	Logger.scala	/^  def isInfoEnabled = logger.isInfoEnabled$/;"	m
isMarker	Evolutions.scala	/^    val isMarker: PartialFunction[String, Boolean] = {$/;"	V
isMatch	Iteratee.scala	/^    def isMatch = this match {$/;"	m
isMaxSizeExceeded	JavaParsers.scala	/^      override val isMaxSizeExceeded: Boolean = false) extends RequestBody {$/;"	V
isProd	Play.scala	/^  def isProd(implicit app: Application): Boolean = (app.mode == Mode.Prod)$/;"	m
isReadOnly	DB.scala	/^  def isReadOnly() = connection.isReadOnly()$/;"	m
isSigned	Http.scala	/^    def isSigned: Boolean = false$/;"	m
isSigned	Http.scala	/^    override val isSigned = true$/;"	V
isTest	Play.scala	/^  def isTest(implicit app: Application): Boolean = (app.mode == Mode.Test)$/;"	m
isText	MimeTypes.scala	/^  def isText(mimeType: String): Boolean = {$/;"	m
isTraceEnabled	Logger.scala	/^  def isTraceEnabled = logger.isTraceEnabled$/;"	m
isValid	DB.scala	/^  def isValid(timeout: Int) = connection.isValid(timeout)$/;"	m
isValidOpenIDRequest	OpenIDSpec.scala	/^  def isValidOpenIDRequest(query:Params) = {$/;"	m
isWarnEnabled	Logger.scala	/^  def isWarnEnabled = logger.isWarnEnabled$/;"	m
isWrapperFor	DB.scala	/^  def isWrapperFor(iface: Class[_]) = connection.isWrapperFor(iface)$/;"	m
iso_8859_1	Results.scala	/^  val iso_8859_1 = javaSupported("iso-8859-1")$/;"	V
isolation	DB.scala	/^    val isolation = conf.getString("isolation").map {$/;"	V
it	Concurrent.scala	/^              val it = enRef.swap(Done(None, Input.Empty))$/;"	V
it	Enumerator.scala	/^    val it = traversable.toIterator$/;"	V
it	EnumeratorsSpec.scala	/^    val it = Iteratee.fold[Int, Int](0)((sum, x) => sum + x)$/;"	V
it	EnumeratorsSpec.scala	/^    val it = a.iterator$/;"	V
it	Filters.scala	/^        val it = scala.concurrent.Promise[Iteratee[Array[Byte],Result]]()$/;"	V
it	Iteratee.scala	/^  lazy val it: Iteratee[E, A] = this match {$/;"	V
it	WS.scala	/^                val it = Done(a, e)$/;"	V
it	WS.scala	/^                val it = Error(e, input)$/;"	V
it	WebSocket.scala	/^      val it = Iteratee.flatten(p.map(_._1)(internalContext))$/;"	V
itE1	Enumerator.scala	/^      val itE1 = iteratee[E1] { case (l, r) => (false, r) }$/;"	V
itE2	Enumerator.scala	/^      val itE2 = iteratee[E2] { case (l, r) => (l, false) }$/;"	V
itPromise	Concurrent.scala	/^        val itPromise = Promise[Iteratee[E, Unit]]()$/;"	V
itPromise	RequestBodyHandler.scala	/^      val itPromise = Promise[Iteratee[Array[Byte], Result]]()$/;"	V
iter	Enumerator.scala	/^      val iter: Ref[Iteratee[E, A]] = Ref(it)$/;"	V
iter	Enumerator.scala	/^      val iter: Ref[Iteratee[E2, A]] = Ref(it)$/;"	V
iter	JUnitXmlTestListener.scala	/^        val iter = System.getProperties.entrySet.iterator$/;"	V
iteratee	Concurrent.scala	/^      val iteratee: Ref[Future[Option[Input[E] => Iteratee[E, A]]]] = Ref(it.pureFold { case  Step.Cont(k) => Some(k); case other => promise.success(other.it); None})$/;"	V
iteratee	Enumerator.scala	/^      def iteratee[EE <: E2](f: ((Boolean, Boolean)) => (Boolean, Boolean)): Iteratee[EE, Unit] = {$/;"	m
iteratee	Enumerator.scala	/^      def iteratee[EE <: E](f: Seq[Boolean] => Seq[Boolean]): Iteratee[EE, Unit] = {$/;"	m
iteratee	Enumerator.scala	/^      var iteratee: Iteratee[E, A] = it$/;"	v
iteratee	Enumerator.scala	/^  var iteratee: Iteratee[E, _] = _$/;"	v
iteratee	RequestBodyHandler.scala	/^    var iteratee: Ref[Iteratee[Array[Byte], Result]] = Ref(Iteratee.flatten(firstIteratee))$/;"	v
iteratee	WS.scala	/^      var iteratee: Iteratee[Array[Byte], A] = null$/;"	v
iterateeP	Enumerator.scala	/^      var iterateeP = Promise[Iteratee[E, A]]()$/;"	v
iterateeP	WS.scala	/^      val iterateeP = Promise[Iteratee[Array[Byte], A]]()$/;"	V
iterateeRef	WebSocketHandler.scala	/^      val iterateeRef = Ref[Iteratee[A, Any]](Iteratee.flatten(eventuallyIteratee.future))$/;"	V
iteratees	Concurrent.scala	/^    val iteratees: Ref[List[(Iteratee[E, _], Promise[Iteratee[E, _]])]] = Ref(List())$/;"	V
iterator	EnumeratorsSpec.scala	/^    val iterator = scala.collection.Iterator.range(0, 50)$/;"	V
iterator	EnumeratorsSpec.scala	/^    val iterator = scala.collection.Iterator.single[Int](3)$/;"	V
its	Concurrent.scala	/^              val its = atomic { implicit txn =>$/;"	V
its	Concurrent.scala	/^            val its = atomic { implicit txn =>$/;"	V
its	Concurrent.scala	/^          val its = atomic { implicit txn =>$/;"	V
jRoute	Helpers.scala	/^  def jRoute(app: Application, rh: RequestHeader): Option[Result] = route(app, rh, AnyContentAsEmpty)$/;"	m
jRoute	Helpers.scala	/^  def jRoute(app: Application, rh: RequestHeader, body: Array[Byte]): Option[Result] = route(app, rh, body)(Writeable.wBytes)$/;"	m
jRoute	Helpers.scala	/^  def jRoute(rh: RequestHeader, body: Array[Byte]): Option[Result] = jRoute(Play.current, rh, body)$/;"	m
java	PlayJvm.scala	/^ * val java = javaBin.toString$/;"	V
java.io.ByteArrayInputStream	JsValue.scala	/^import java.io.ByteArrayInputStream$/;"	i
java.io.File	GlobalSettings.scala	/^import java.io.File$/;"	i
java.io.File	JavaGlobalSettingsAdapter.scala	/^import java.io.File$/;"	i
java.io.File	ResultsSpec.scala	/^    import java.io.File$/;"	i
java.io.File	RoutesCompiler.scala	/^  import java.io.File$/;"	i
java.io.File	ScalaTemplateCompiler.scala	/^      import java.io.File$/;"	i
java.io.File	ScalaTemplateCompiler.scala	/^  import java.io.File$/;"	i
java.io.File	WS.scala	/^import java.io.File$/;"	i
java.io.OutputStream	EnumeratorsSpec.scala	/^import java.io.OutputStream$/;"	i
java.io._	Application.scala	/^import java.io._$/;"	i
java.io._	ApplicationProvider.scala	/^import java.io._$/;"	i
java.io._	Assets.scala	/^import java.io._$/;"	i
java.io._	CoffeescriptCompiler.scala	/^import java.io._$/;"	i
java.io._	Configuration.scala	/^import java.io._$/;"	i
java.io._	Console.scala	/^import java.io._$/;"	i
java.io._	ContentTypes.scala	/^import java.io._$/;"	i
java.io._	Evolutions.scala	/^import java.io._$/;"	i
java.io._	ExternalAssets.scala	/^import java.io._$/;"	i
java.io._	Files.scala	/^import java.io._$/;"	i
java.io._	JavascriptCompiler.scala	/^import java.io._$/;"	i
java.io._	LessCompiler.scala	/^import java.io._$/;"	i
java.io._	Messages.scala	/^import java.io._$/;"	i
java.io._	NettyServer.scala	/^  import java.io._$/;"	i
java.io._	Play.scala	/^import java.io._$/;"	i
java.io._	PlayAssetsCompiler.scala	/^      import java.io._$/;"	i
java.io._	TemplateCompilerSpec.scala	/^import java.io._$/;"	i
java.io.{ File => JFile, BufferedReader, InputStream, InputStreamReader, OutputStream }	PlayJvm.scala	/^import java.io.{ File => JFile, BufferedReader, InputStream, InputStreamReader, OutputStream }$/;"	i
java.io.{ StringWriter, PrintWriter, File }	JUnitXmlTestListener.scala	/^import java.io.{ StringWriter, PrintWriter, File }$/;"	i
java.io.{File, FileInputStream, FileOutputStream}	FakeKeyStore.scala	/^import java.io.{File, FileInputStream, FileOutputStream}$/;"	i
java.io.{File, FileInputStream}	NettyServer.scala	/^import java.io.{File, FileInputStream}$/;"	i
java.io.{File=>JFile}	PlayCommands.scala	/^import java.io.{File=>JFile}$/;"	i
java.lang.reflect.InvocationTargetException	Application.scala	/^import java.lang.reflect.InvocationTargetException$/;"	i
java.lang.reflect._	PlayReloader.scala	/^          import java.lang.reflect._$/;"	i
java.lang.{ ProcessBuilder => JProcessBuilder }	PlayCommands.scala	/^          import java.lang.{ ProcessBuilder => JProcessBuilder }$/;"	i
java.lang.{ ProcessBuilder => JProcessBuilder }	PlayCommands.scala	/^import java.lang.{ ProcessBuilder => JProcessBuilder }$/;"	i
java.lang.{ ProcessBuilder => JProcessBuilder }	PlayJvm.scala	/^import java.lang.{ ProcessBuilder => JProcessBuilder }$/;"	i
java.math.BigDecimal	Anorm.scala	/^    import java.math.BigDecimal$/;"	i
java.math.BigInteger	Anorm.scala	/^    import java.math.BigInteger$/;"	i
java.math.BigInteger	FakeKeyStore.scala	/^import java.math.BigInteger$/;"	i
java.net.InetAddress	JUnitXmlTestListener.scala	/^import java.net.InetAddress$/;"	i
java.net.JarURLConnection	Assets.scala	/^import java.net.JarURLConnection$/;"	i
java.net.URL	DiscoverySpec.scala	/^import java.net.URL$/;"	i
java.net.URLEncoder	Results.scala	/^    import java.net.URLEncoder$/;"	i
java.net.URLEncoder	Writeable.scala	/^    import java.net.URLEncoder$/;"	i
java.net._	ApplicationProvider.scala	/^import java.net._$/;"	i
java.net._	FormUrlEncodedParser.scala	/^    import java.net._$/;"	i
java.net._	OpenID.scala	/^import java.net._$/;"	i
java.net._	TemplateCompilerSpec.scala	/^    import java.net._$/;"	i
java.net.{ InetSocketAddress }	NettyServer.scala	/^import java.net.{ InetSocketAddress }$/;"	i
java.net.{ URLEncoder, URLDecoder }	Binders.scala	/^import java.net.{ URLEncoder, URLDecoder }$/;"	i
java.nio.ByteBuffer	WS.scala	/^      import java.nio.ByteBuffer$/;"	i
java.nio.charset.Charset	Frame.scala	/^import java.nio.charset.Charset$/;"	i
java.nio.charset.Charset	WebSocketHandshake.scala	/^import java.nio.charset.Charset$/;"	i
java.security.MessageDigest	Codecs.scala	/^    import java.security.MessageDigest$/;"	i
java.security.MessageDigest	RoutesCompiler.scala	/^      import java.security.MessageDigest$/;"	i
java.security.MessageDigest	ScalaTemplateCompiler.scala	/^      import java.security.MessageDigest$/;"	i
java.security.MessageDigest	WebSocketHandshake.scala	/^import java.security.MessageDigest$/;"	i
java.security.SecureRandom	csrf.scala	/^  import java.security.SecureRandom$/;"	i
java.security._	NettyServer.scala	/^import java.security._$/;"	i
java.security.cert.X509Certificate	FakeKeyStore.scala	/^import java.security.cert.X509Certificate$/;"	i
java.security.cert.X509Certificate	NettyServer.scala	/^import java.security.cert.X509Certificate$/;"	i
java.security.{KeyStore, SecureRandom, KeyPairGenerator, KeyPair}	FakeKeyStore.scala	/^import java.security.{KeyStore, SecureRandom, KeyPairGenerator, KeyPair}$/;"	i
java.sql.ResultSetMetaData._	Anorm.scala	/^  import java.sql.ResultSetMetaData._$/;"	i
java.sql._	Anorm.scala	/^  import java.sql._$/;"	i
java.sql._	DB.scala	/^import java.sql._$/;"	i
java.sql._	ProxyDriver.scala	/^import java.sql._$/;"	i
java.sql.{ Statement, Date, Connection, SQLException }	Evolutions.scala	/^import java.sql.{ Statement, Date, Connection, SQLException }$/;"	i
java.text.ParseException	JsPathSpec.scala	/^import java.text.ParseException$/;"	i
java.text.ParseException	JsonRichSpec.scala	/^import java.text.ParseException$/;"	i
java.text.ParseException	JsonSpec.scala	/^import java.text.ParseException$/;"	i
java.text.ParseException	JsonTransSpec.scala	/^import java.text.ParseException$/;"	i
java.text.ParseException	JsonValidSpec.scala	/^import java.text.ParseException$/;"	i
java.text.SimpleDateFormat	JsonSpec.scala	/^  import java.text.SimpleDateFormat$/;"	i
java.text._	Messages.scala	/^  import java.text._$/;"	i
java.util.Date	Anorm.scala	/^import java.util.Date$/;"	i
java.util.Date	FakeKeyStore.scala	/^import java.util.Date$/;"	i
java.util.Date	JsonSpec.scala	/^  import java.util.Date$/;"	i
java.util.Date	SqlParser.scala	/^  import java.util.Date$/;"	i
java.util.Date	Task.scala	/^import java.util.Date$/;"	i
java.util.UUID	Binders.scala	/^import java.util.UUID$/;"	i
java.util.UUID	BindersSpec.scala	/^import java.util.UUID$/;"	i
java.util._	ProxyDriver.scala	/^import java.util._$/;"	i
java.util.concurrent.Executors	Execution.scala	/^import java.util.concurrent.Executors$/;"	i
java.util.concurrent.TimeUnit	DiscoverySpec.scala	/^import java.util.concurrent.TimeUnit$/;"	i
java.util.concurrent.TimeUnit	NettyPromise.scala	/^import java.util.concurrent.TimeUnit$/;"	i
java.util.concurrent.TimeUnit	OpenIDSpec.scala	/^import java.util.concurrent.TimeUnit$/;"	i
java.util.concurrent.TimeUnit	Selenium.scala	/^import java.util.concurrent.TimeUnit$/;"	i
java.util.concurrent.TimeUnit._	ConcurrentSpec.scala	/^import java.util.concurrent.TimeUnit._$/;"	i
java.util.concurrent.TimeoutException	JavaPromise.scala	/^import java.util.concurrent.TimeoutException$/;"	i
java.util.concurrent.TimeoutException	Promise.scala	/^import java.util.concurrent.TimeoutException$/;"	i
java.util.concurrent._	NettyServer.scala	/^import java.util.concurrent._$/;"	i
java.util.concurrent._	PlayDefaultUpstreamHandler.scala	/^import java.util.concurrent._$/;"	i
java.util.concurrent._	RequestBodyHandler.scala	/^import java.util.concurrent._$/;"	i
java.util.concurrent._	WebSocketHandler.scala	/^import java.util.concurrent._$/;"	i
java.util.concurrent._	WebSocketHandshake.scala	/^import java.util.concurrent._$/;"	i
java.util.concurrent.atomic.AtomicInteger	NamedThreadFactory.scala	/^import java.util.concurrent.atomic.AtomicInteger$/;"	i
java.util.concurrent.{ TimeUnit }	Akka.scala	/^import java.util.concurrent.{ TimeUnit }$/;"	i
java.util.concurrent.{ TimeUnit }	Concurrent.scala	/^import java.util.concurrent.{ TimeUnit }$/;"	i
java.util.concurrent.{ TimeUnit }	Promise.scala	/^import java.util.concurrent.{ TimeUnit }$/;"	i
java.util.concurrent.{ TimeUnit, Callable }	JavaPromise.scala	/^import java.util.concurrent.{ TimeUnit, Callable }$/;"	i
java.util.concurrent.{Executors, ThreadFactory}	NamedThreadFactory.scala	/^import java.util.concurrent.{Executors, ThreadFactory}$/;"	i
java.util.logging._	Logger.scala	/^      import java.util.logging._$/;"	i
java.util.regex._	PathParts.scala	/^  import java.util.regex._$/;"	i
java.util.regex._	Router.scala	/^  import java.util.regex._$/;"	i
java.util.{ List => JList }	JavaPromise.scala	/^import java.util.{ List => JList }$/;"	i
java.util.{Date, TimeZone}	FormatSpec.scala	/^import java.util.{Date, TimeZone}$/;"	i
javaBigDecReads	Reads.scala	/^  implicit val javaBigDecReads = Reads[java.math.BigDecimal]( js => js match {$/;"	V
javaClasses	PlayCommands.scala	/^    val javaClasses = (javaSrc ** "*.java").get flatMap { sourceFile =>$/;"	V
javaContext	JavaAction.scala	/^    val javaContext = createJavaContext(req)$/;"	V
javaContext	JavaHelpers.scala	/^    val javaContext = createJavaContext(request)$/;"	V
javaCore	PlayKeys.scala	/^  val javaCore = "play" %% "play-java" % play.core.PlayVersion.current$/;"	V
javaEbean	PlayKeys.scala	/^  val javaEbean = "play" %% "play-java-ebean" % play.core.PlayVersion.current$/;"	V
javaGlobal	Application.scala	/^  lazy private val javaGlobal: Option[play.GlobalSettings] = try {$/;"	V
javaIdent	RoutesCompiler.scala	/^    def javaIdent: Parser[String] = """\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*""".r$/;"	m
javaJdbc	PlayKeys.scala	/^  val javaJdbc = "play" %% "play-java-jdbc" % play.core.PlayVersion.current$/;"	V
javaJpa	PlayKeys.scala	/^  val javaJpa = "play" %% "play-java-jpa" % play.core.PlayVersion.current$/;"	V
javaProperties	PlayCommands.scala	/^    val javaProperties = properties.map(_.drop(2).split('=')).map(a => a(0) -> a(1)).toSeq$/;"	V
javaRoutes	PlayCommands.scala	/^    val javaRoutes = (generatedDir ** "routes.java")$/;"	V
javaScriptReverseRouting	RoutesCompiler.scala	/^  def javaScriptReverseRouting(routes: List[Route]): String = {$/;"	m
javaSupported	Results.scala	/^  def javaSupported(charset: String) = Codec(charset)(str => str.getBytes(charset), bytes => new String(bytes, charset))$/;"	m
javaWebSocket	JavaWebSocket.scala	/^      val javaWebSocket = try {$/;"	V
javascript	Evolutions.scala	/^  private val javascript = """$/;"	V
javascriptEntryPoints	PlayKeys.scala	/^  val javascriptEntryPoints = SettingKey[PathFinder]("play-javascript-entry-points")$/;"	V
javascriptRouter	Routes.scala	/^    def javascriptRouter(name: String = "Router", ajaxMethod: Option[String] = Some("jQuery.ajax"))(routes: JavascriptReverseRoute*)(implicit request: RequestHeader): String = {$/;"	m
javascriptRouter	Routes.scala	/^    def javascriptRouter(name: String, ajaxMethod: Option[String], host: String, routes: JavascriptReverseRoute*): String = {$/;"	m
javascriptUnbind	Binders.scala	/^  def javascriptUnbind: String = """function(k,v) {return encodeURIComponent(k)+'='+encodeURIComponent(v)}"""$/;"	m
javascriptUnbind	Binders.scala	/^  def javascriptUnbind: String = """function(k,v) {return v}"""$/;"	m
javax.crypto._	Crypto.scala	/^import javax.crypto._$/;"	i
javax.crypto.spec.SecretKeySpec	Crypto.scala	/^import javax.crypto.spec.SecretKeySpec$/;"	i
javax.naming.Context._	JNDI.scala	/^import javax.naming.Context._$/;"	i
javax.naming._	JNDI.scala	/^import javax.naming._$/;"	i
javax.net.ssl.KeyManagerFactory	FakeKeyStore.scala	/^import javax.net.ssl.KeyManagerFactory$/;"	i
javax.net.ssl.SSLContext	WS.scala	/^  import javax.net.ssl.SSLContext$/;"	i
javax.net.ssl._	NettyServer.scala	/^import javax.net.ssl._$/;"	i
javax.sql.DataSource	Evolutions.scala	/^import javax.sql.DataSource$/;"	i
javax.sql._	DB.scala	/^import javax.sql._$/;"	i
jdbc	PlayKeys.scala	/^  val jdbc =  "play" %% "play-jdbc" % play.core.PlayVersion.current$/;"	V
jdbcCompliant	ProxyDriver.scala	/^  def jdbcCompliant() = proxied.jdbcCompliant$/;"	m
jline._	Console.scala	/^import jline._$/;"	i
jline._	PlayProject.scala	/^import jline._$/;"	i
jnotify	PlayReloader.scala	/^      lazy val jnotify = { \/\/ This create a fully dynamic version of JNotify that support reloading $/;"	V
jnotifyClass	PlayReloader.scala	/^          val jnotifyClass = sbtLoader.loadClass("net.contentobjects.jnotify.JNotify")$/;"	V
jnotifyJarFile	PlayReloader.scala	/^          var jnotifyJarFile = this.getClass.getClassLoader.asInstanceOf[java.net.URLClassLoader].getURLs$/;"	v
jnotifyListenerClass	PlayReloader.scala	/^          val jnotifyListenerClass = sbtLoader.loadClass("net.contentobjects.jnotify.JNotifyListener")$/;"	V
jodaDate	Forms.scala	/^  def jodaDate(pattern: String, timeZone: org.joda.time.DateTimeZone = org.joda.time.DateTimeZone.getDefault): Mapping[org.joda.time.DateTime] = of[org.joda.time.DateTime] as jodaDateTimeFormat(pattern, timeZone)$/;"	m
jodaDate	Forms.scala	/^  val jodaDate: Mapping[org.joda.time.DateTime] = of[org.joda.time.DateTime]$/;"	V
jodaDateReads	Reads.scala	/^  def jodaDateReads(pattern: String, corrector: String => String = identity): Reads[org.joda.time.DateTime] = new Reads[org.joda.time.DateTime] {$/;"	m
jodaDateWrites	Writes.scala	/^  def jodaDateWrites(pattern: String): Writes[org.joda.time.DateTime] = new Writes[org.joda.time.DateTime] {$/;"	m
jodaLocalDate	Forms.scala	/^  def jodaLocalDate(pattern: String): Mapping[org.joda.time.LocalDate] = of[org.joda.time.LocalDate] as jodaLocalDateFormat(pattern)$/;"	m
jodaLocalDate	Forms.scala	/^  val jodaLocalDate: Mapping[org.joda.time.LocalDate] = of[org.joda.time.LocalDate]$/;"	V
jodaLocalDateReads	Reads.scala	/^  def jodaLocalDateReads(pattern: String, corrector: String => String = identity): Reads[org.joda.time.LocalDate] = new Reads[org.joda.time.LocalDate] {$/;"	m
jodaLocalDateWrites	Writes.scala	/^  def jodaLocalDateWrites(pattern: String): Writes[org.joda.time.LocalDate] = new Writes[org.joda.time.LocalDate] {$/;"	m
joinConcatI	Iteratee.scala	/^  def joinConcatI[AIn, X](implicit in: A <:< Iteratee[E, AIn], p: E => scala.collection.TraversableLike[X, E], bf: scala.collection.generic.CanBuildFrom[E, X, E]): Iteratee[E, AIn] = {$/;"	m
joinI	Iteratee.scala	/^  def joinI[AIn](implicit in: A <:< Iteratee[_, AIn]): Iteratee[E, AIn] = {$/;"	m
js	JsPath.scala	/^      val js = Json.obj("key1" -> "value1", "key2" -> "value2") $/;"	V
js	JsPath.scala	/^    val js = Json.obj("key1" -> "value1", "key2" -> "value2") $/;"	V
js	JsPath.scala	/^    val js = Json.obj("key1" -> "value1", "key2" -> 123) $/;"	V
js	JsPath.scala	/^    val js = Json.obj("key1" -> "value1", "key2" -> Json.obj( "key21" -> "value2") )$/;"	V
js	JsonExtensionSpec.scala	/^      val js = Json.obj("id" -> 123L, "name" -> "toto")$/;"	V
js	JsonRichSpec.scala	/^      val js = Json.obj($/;"	V
js	JsonTransSpec.scala	/^    val js = Json.obj($/;"	V
js	JsonValidSpec.scala	/^      val js = JsString($/;"	V
js	JsonValidSpec.scala	/^      val js = Json.obj($/;"	V
js	JsonValidSpec.scala	/^      val js = Json.toJson(bobby)$/;"	V
js	JsonValidSpec.scala	/^      val js = js0 ++ Json.obj("field2" -> 123L, "field3" -> false)    $/;"	V
js	JsonValidSpec.scala	/^      val js = js0 ++ Json.obj("field2" -> Json.obj("field21" -> 123, "field22" -> true))    $/;"	V
js0	JsonValidSpec.scala	/^      val js0 = Json.obj("field1" -> "alpha")$/;"	V
js0	JsonValidSpec.scala	/^      val js0 = Json.obj($/;"	V
js2	JsonValidSpec.scala	/^      val js2 = Json.obj($/;"	V
js2	JsonValidSpec.scala	/^      val js2 = js ++ Json.obj("field3" -> "beta")  $/;"	V
js2	JsonValidSpec.scala	/^      val js2 = js ++ Json.obj("field4" -> false)  $/;"	V
jsCopyTo	JsConstraints.scala	/^  def jsCopyTo[A <: JsValue](path: JsPath)(reads: Reads[A]) = $/;"	m
jsFiles	JavascriptCompiler.scala	/^    val jsFiles = dir.listFiles(new FileFilter {$/;"	V
jsFilesChildren	JavascriptCompiler.scala	/^    val jsFilesChildren = directories.map(d => allJsFilesIn(d)).flatten$/;"	V
jsFolder	PlayCommands.scala	/^    val jsFolder = if(!requireJsFolder.isEmpty) {requireJsFolder} else "javascripts"$/;"	V
jsPathSelect	JsMacroImpl.scala	/^    val jsPathSelect = Select(jsonPkg, "JsPath")$/;"	V
jsPick	JsConstraints.scala	/^  def jsPick(path: JsPath): Writes[JsValue] =$/;"	m
jsPick	JsConstraints.scala	/^  def jsPick[A <: JsValue](path: JsPath)(implicit reads: Reads[A]): Reads[A] = at(path)(reads)$/;"	m
jsPickBranch	JsConstraints.scala	/^  def jsPickBranch(path: JsPath): OWrites[JsValue] =$/;"	m
jsPickBranch	JsConstraints.scala	/^  def jsPickBranch[A <: JsValue](path: JsPath)(implicit reads: Reads[A]): Reads[JsObject] = $/;"	m
jsPickBranchUpdate	JsConstraints.scala	/^  def jsPickBranchUpdate(path: JsPath, wrs: OWrites[JsValue]): OWrites[JsValue] =$/;"	m
jsPrune	JsConstraints.scala	/^  def jsPrune(path: JsPath) = Reads[JsObject]( js => path.prune(js) )$/;"	m
jsPut	JsConstraints.scala	/^  def jsPut(path: JsPath, a: => JsValue) = Reads[JsObject]( json => JsSuccess(JsPath.createObj(path -> a)) )$/;"	m
jsSource	PlayAssetsCompiler.scala	/^      val jsSource = play.core.coffeescript.CoffeescriptCompiler.compile(coffeeFile, options)$/;"	V
jsUpdate	JsConstraints.scala	/^  def jsUpdate[A <: JsValue](path: JsPath)(reads: Reads[A]) = $/;"	m
jserr	JsonValidSpec.scala	/^      val jserr = JsError( Seq($/;"	V
json	ContentTypes.scala	/^    def json(maxLength: Int): BodyParser[JsValue] = when($/;"	m
json	ContentTypes.scala	/^    def json: BodyParser[JsValue] = json(DEFAULT_MAX_TEXT_LENGTH)$/;"	m
json	JavaParsers.scala	/^  def json(maxLength: Int): BodyParser[RequestBody] = parse.maxLength(orDefault(maxLength), parse.json(Integer.MAX_VALUE)).map {$/;"	m
json	JsPath.scala	/^  object json {$/;"	o
json	JsonSpec.scala	/^      val json = arr(1, 2, 3, 4, 5)$/;"	V
json	JsonSpec.scala	/^      val json = toJson(n)$/;"	V
json	JsonValidSpec.scala	/^      val json = Json.obj("field" -> JsNull)$/;"	V
json	Jsonp.scala	/^ *     val json = ...$/;"	V
json	WS.scala	/^  lazy val json: JsValue = Json.parse(ahcResponse.getResponseBodyAsBytes)$/;"	V
jsonCar	JsonSpec.scala	/^      val jsonCar = toJson(c)$/;"	V
jsonFactory	JsValue.scala	/^  private[this] lazy val jsonFactory = new org.codehaus.jackson.JsonFactory(mapper)$/;"	V
jsonFrame	JavaWebSocket.scala	/^  implicit val jsonFrame = play.api.mvc.WebSocket.FrameFormatter.stringFrame.transform($/;"	V
jsonFrame	WebSocket.scala	/^    implicit val jsonFrame: FrameFormatter[JsValue] = stringFrame.transform(Json.stringify, Json.parse)$/;"	V
jsonM	JsonSpec.scala	/^      val jsonM = toJson(m)$/;"	V
jsonMario	JsonSpec.scala	/^      val jsonMario = toJson(mario)$/;"	V
jsonMessages	Comet.scala	/^    implicit val jsonMessages = CometMessage[play.api.libs.json.JsValue](json => json.toString())$/;"	V
jsonPkg	JsMacroImpl.scala	/^    val jsonPkg = Select(libsPkg, "json")$/;"	V
jsonStream	Json.scala	/^   *   val jsonStream: Enumerator[JsValue] = ???$/;"	V
jsonStream	Json.scala	/^   *   val jsonStream: Enumerator[JsValue] = fooStream &> Json.toJson$/;"	V
jsonTransformer	JsonValidSpec.scala	/^      val jsonTransformer = ($/;"	V
jspathTree	JsMacroImpl.scala	/^                        val jspathTree = Apply( $/;"	V
jump	Iteratee.scala	/^          val jump = jumpBadCharecter(piece(startScan + needleSize - 1))$/;"	V
jumpBadCharecter	Iteratee.scala	/^    val jumpBadCharecter: (Byte => Int) = {$/;"	V
jvm	PlayJvm.scala	/^  def jvm(message: String) = name.map(n => "[%s] %s" format (n, message)).getOrElse(message)$/;"	m
jvmLogger	PlayJvm.scala	/^ * val jvmLogger = new JvmLogger("info")$/;"	V
keepAlive	PlayDefaultUpstreamHandler.scala	/^        val keepAlive = isKeepAlive(nettyHttpRequest)$/;"	V
key	ContentTypes.scala	/^                val key :: value = header.trim.split(":").toList$/;"	V
key	CryptoSpec.scala	/^      val key  = "0123456789abcdef" $/;"	V
key	Form.scala	/^  val key = wrapped.key$/;"	V
key	Form.scala	/^  val key: String$/;"	V
key	Form.scala	/^case class FieldMapping[T](val key: String = "", val constraints: Seq[Constraint[T]] = Nil)(implicit val binder: Formatter[T]) extends Mapping[T] {$/;"	V
key	Form.scala	/^case class ObjectMapping1[R, A1](apply: Function1[A1, R], unapply: Function1[R, Option[(A1)]], f1: (String, Mapping[A1]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	Form.scala	/^case class RepeatedMapping[T](wrapped: Mapping[T], val key: String = "", val constraints: Seq[Constraint[List[T]]] = Nil) extends Mapping[List[T]] {$/;"	V
key	FormUrlEncodedParser.scala	/^        val key = URLDecoder.decode(parts.head, encoding)$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping10[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10](apply: Function10[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping11[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11](apply: Function11[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping12[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12](apply: Function12[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), f12: (String, Mapping[A12]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping13[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13](apply: Function13[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), f12: (String, Mapping[A12]), f13: (String, Mapping[A13]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping14[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14](apply: Function14[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), f12: (String, Mapping[A12]), f13: (String, Mapping[A13]), f14: (String, Mapping[A14]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping15[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15](apply: Function15[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), f12: (String, Mapping[A12]), f13: (String, Mapping[A13]), f14: (String, Mapping[A14]), f15: (String, Mapping[A15]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping16[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16](apply: Function16[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), f12: (String, Mapping[A12]), f13: (String, Mapping[A13]), f14: (String, Mapping[A14]), f15: (String, Mapping[A15]), f16: (String, Mapping[A16]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping17[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17](apply: Function17[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), f12: (String, Mapping[A12]), f13: (String, Mapping[A13]), f14: (String, Mapping[A14]), f15: (String, Mapping[A15]), f16: (String, Mapping[A16]), f17: (String, Mapping[A17]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping18[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18](apply: Function18[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), f10: (String, Mapping[A10]), f11: (String, Mapping[A11]), f12: (String, Mapping[A12]), f13: (String, Mapping[A13]), f14: (String, Mapping[A14]), f15: (String, Mapping[A15]), f16: (String, Mapping[A16]), f17: (String, Mapping[A17]), f18: (String, Mapping[A18]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping2[R, A1, A2](apply: Function2[A1, A2, R], unapply: Function1[R, Option[(A1, A2)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping3[R, A1, A2, A3](apply: Function3[A1, A2, A3, R], unapply: Function1[R, Option[(A1, A2, A3)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping4[R, A1, A2, A3, A4](apply: Function4[A1, A2, A3, A4, R], unapply: Function1[R, Option[(A1, A2, A3, A4)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping5[R, A1, A2, A3, A4, A5](apply: Function5[A1, A2, A3, A4, A5, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping6[R, A1, A2, A3, A4, A5, A6](apply: Function6[A1, A2, A3, A4, A5, A6, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping7[R, A1, A2, A3, A4, A5, A6, A7](apply: Function7[A1, A2, A3, A4, A5, A6, A7, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping8[R, A1, A2, A3, A4, A5, A6, A7, A8](apply: Function8[A1, A2, A3, A4, A5, A6, A7, A8, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
key	ObjectMappings.scala	/^case class ObjectMapping9[R, A1, A2, A3, A4, A5, A6, A7, A8, A9](apply: Function9[A1, A2, A3, A4, A5, A6, A7, A8, A9, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9)]], f1: (String, Mapping[A1]), f2: (String, Mapping[A2]), f3: (String, Mapping[A3]), f4: (String, Mapping[A4]), f5: (String, Mapping[A5]), f6: (String, Mapping[A6]), f7: (String, Mapping[A7]), f8: (String, Mapping[A8]), f9: (String, Mapping[A9]), val key: String = "", val constraints: Seq[Constraint[R]] = Nil) extends Mapping[R] with ObjectMapping {$/;"	V
keyManagerFactory	FakeKeyStore.scala	/^  def keyManagerFactory(appPath: File): Option[KeyManagerFactory] = {$/;"	m
keyPair	FakeKeyStore.scala	/^        val keyPair = keyPairGenerator.generateKeyPair()$/;"	V
keyPairGenerator	FakeKeyStore.scala	/^        val keyPairGenerator = KeyPairGenerator.getInstance("RSA")$/;"	V
keyStore	FakeKeyStore.scala	/^      val keyStore = KeyStore.getInstance("JKS")$/;"	V
keyStore	NettyServer.scala	/^        val keyStore = KeyStore.getInstance(System.getProperty("https.keyStoreType", "JKS"))$/;"	V
keyStoreFile	FakeKeyStore.scala	/^      val keyStoreFile = new File(appPath, GeneratedKeyStore)$/;"	V
keyValue	ContentTypes.scala	/^          val keyValue = """^([a-zA-Z_0-9]+)="(.*)"$""".r$/;"	V
keys	Configuration.scala	/^   * val keys = configuration.keys$/;"	V
keys	Configuration.scala	/^  def keys: Set[String] = underlying.entrySet.asScala.map(_.getKey).toSet$/;"	m
keys	Http.scala	/^    def keys: Set[String] = toMap.keySet$/;"	m
keys	JsValue.scala	/^  def keys: Set[String] = fields.map(_._1).toSet$/;"	m
kinopio	JsonSpec.scala	/^      val kinopio = User(2, "Kinopio", List())$/;"	V
kk	EnumeratorsSpec.scala	/^      val kk = e |>>> Enumeratee.take(7) &>> Iteratee.fold(List.empty[Int])((r, e) => r ++ e)$/;"	V
kk	EnumeratorsSpec.scala	/^      val kk = e |>>> Iteratee.fold(List.empty[Int])((r, e) => r ++ e)$/;"	V
klass	JsValue.scala	/^    val klass = javaType.getRawClass$/;"	V
kmf	FakeKeyStore.scala	/^      val kmf = KeyManagerFactory.getInstance("SunX509")$/;"	V
kmf	NettyServer.scala	/^            val kmf = KeyManagerFactory.getInstance(algorithm)$/;"	V
l	Binders.scala	/^  private def javascriptUnbindList(jsUnbindT: String) = "function(k,vs){var l=vs&&vs.length,r=[],i=0;for(;i<l;i++){r[i]=(" + jsUnbindT + ")(k,vs[i])}return r.join('&')}"$/;"	v
lang	Results.scala	/^   * implicit val lang = Lang("fr-FR")$/;"	V
langCookieName	Play.scala	/^  def langCookieName(implicit app: Application): String = app.configuration.getString("application.lang.cookie").getOrElse("PLAY_LANG")$/;"	m
langs	Http.scala	/^      val langs = acceptHeader(HeaderNames.ACCEPT_LANGUAGE).map(item => (item._1, Lang.get(item._2)))$/;"	V
langsToTry	Messages.scala	/^    val langsToTry: List[Lang] =$/;"	V
language.experimental.macros	JsMacroImpl.scala	/^import language.experimental.macros$/;"	i
language.experimental.macros	Json.scala	/^  import language.experimental.macros$/;"	i
last	Concurrent.scala	/^      val last = Promise[Iteratee[E, Iteratee[E, A]]]()$/;"	V
lastEnhanced	PlayCommands.scala	/^    val lastEnhanced = if (timestampFile.exists) IO.read(timestampFile).toLong else Long.MinValue$/;"	V
lastMessage	PlayLogger.scala	/^  private var lastMessage: String = null$/;"	v
lastModifiedResponse	Assets.scala	/^                val lastModifiedResponse = lastModifiedFor(url).map(lastModified => taggedResponse.withHeaders(LAST_MODIFIED -> lastModified)).getOrElse(taggedResponse)$/;"	V
lastModifieds	Assets.scala	/^  private val lastModifieds = (new java.util.concurrent.ConcurrentHashMap[String, String]()).asScala$/;"	V
lastState	ApplicationProvider.scala	/^  var lastState: Either[Throwable, Application] = Left(new PlayException("Not initialized", "?"))$/;"	v
lazyAndErrIfNotReady	Concurrent.scala	/^  def lazyAndErrIfNotReady[E](timeout: Long, unit: TimeUnit = TimeUnit.MILLISECONDS): Enumeratee[E, E] = new Enumeratee[E, E] {$/;"	m
lazyFormat	JsPath.scala	/^  def lazyFormat[T](f: => Format[T]): OFormat[T] = OFormat[T]( lazyRead(f), lazyWrite(f) )$/;"	m
lazyFormat	JsPath.scala	/^  def lazyFormat[T](r: => Reads[T], w: => Writes[T]): OFormat[T] = OFormat[T]( lazyRead(r), lazyWrite(w) )$/;"	m
lazyFormatNullable	JsPath.scala	/^  def lazyFormatNullable[T](f: => Format[T]): OFormat[Option[T]] = OFormat[Option[T]]( lazyReadNullable(f), lazyWriteNullable(f) )$/;"	m
lazyFormatNullable	JsPath.scala	/^  def lazyFormatNullable[T](r: => Reads[T], w: => Writes[T]): OFormat[Option[T]] = OFormat[Option[T]]( lazyReadNullable(r), lazyWriteNullable(w) )$/;"	m
lazyHelperSelect	JsMacroImpl.scala	/^    val lazyHelperSelect = Select(utilPkg, newTypeName("LazyHelper"))$/;"	V
lazyRead	JsPath.scala	/^  def lazyRead[T](r: => Reads[T]): Reads[T] = Reads( js => Reads.at[T](this)(r).reads(js) )$/;"	m
lazyReadNullable	JsPath.scala	/^  def lazyReadNullable[T](r: => Reads[T]): Reads[Option[T]] = Reads( js => Reads.nullable[T](this)(r).reads(js) )$/;"	m
lazyStuff	JsMacroImpl.scala	/^                          override lazy val lazyStuff: Format[A] = null$/;"	V
lazyStuff	Util.scala	/^    override lazy val lazyStuff = stuff$/;"	V
lazyStuff	Util.scala	/^  def lazyStuff: M[T]$/;"	m
lazyWrite	JsPath.scala	/^  def lazyWrite[T](w: => Writes[T]): OWrites[T] = OWrites( (t:T) => Writes.at[T](this)(w).writes(t) )$/;"	m
lazyWriteNullable	JsPath.scala	/^  def lazyWriteNullable[T](w: => Writes[T]): OWrites[Option[T]] = OWrites( (t:Option[T]) => Writes.nullable[T](this)(w).writes(t) )$/;"	m
ldj	JsonValidSpec.scala	/^      val ldj = org.joda.time.LocalDate.parse(dfj.print(dj), dfj)$/;"	V
left	ContentTypes.scala	/^              val left = rest.drop(CRLFCRLF.length)$/;"	V
left	TraversableIteratee.scala	/^            val left = leftToDrop - e.size$/;"	V
lessEntryPoints	PlayKeys.scala	/^  val lessEntryPoints = SettingKey[PathFinder]("play-less-entry-points")$/;"	V
lessOptions	PlayKeys.scala	/^  val lessOptions = SettingKey[Seq[String]]("play-less-options")$/;"	V
lessScript	LessCompiler.scala	/^  val lessScript = "less-1.3.1.js"$/;"	V
libPath	ScalaTemplateCompiler.scala	/^            val libPath = scalaObjectSource.getLocation.getFile$/;"	V
libPath	TemplateCompilerSpec.scala	/^        val libPath = scalaObjectSource.getLocation$/;"	V
libs	PlayCommands.scala	/^    val libs = dependencies.filter(_.data.ext == "jar").map(_.data) ++ packaged$/;"	V
libs	PlayCommands.scala	/^    val libs = {$/;"	V
libs	PlayReloader.scala	/^          val libs = new File(nativeLibrariesDirectory, System.getProperty("sun.arch.data.model") + "bits").getAbsolutePath$/;"	V
libs.ws.WS	Helpers.scala	/^import libs.ws.WS$/;"	i
libsPkg	JsMacroImpl.scala	/^    val libsPkg = Select(Select(Ident(newTermName("play")), "api"), "libs")$/;"	V
licenseCommand	PlayCommands.scala	/^  val licenseCommand = Command.command("license") { state: State =>$/;"	V
line	Application.scala	/^          def line = source.flatMap(_._2).map(_.asInstanceOf[java.lang.Integer]).orNull$/;"	m
line	CoffeescriptCompiler.scala	/^        val line = """.*on line ([0-9]+).*""".r$/;"	V
line	Configuration.scala	/^      def line = Option(origin.lineNumber:java.lang.Integer).orNull$/;"	m
line	JavascriptCompiler.scala	/^    def line = atLine.map(_.asInstanceOf[java.lang.Integer]).orNull$/;"	m
line	Messages.scala	/^            def line = in.pos.line$/;"	m
line	PlayExceptions.scala	/^    def line = atLine$/;"	m
line	PlayExceptions.scala	/^    def line = atLine.map(_.asInstanceOf[java.lang.Integer]).orNull$/;"	m
line	PlayExceptions.scala	/^    def line = problem.position.line.map(m => m.asInstanceOf[java.lang.Integer]).orNull$/;"	m
line	PlayJvm.scala	/^      val line = reader.readLine()$/;"	V
line	PlayLogger.scala	/^      def line() = Maybe.just(lineNo)$/;"	m
line	PlayPositionMapper.scala	/^          lazy val line = {$/;"	V
line	PlayReloader.scala	/^                  def line = xsbti.Maybe.just(error._2.toInt)$/;"	m
line	ScalaTemplateCompiler.scala	/^          val line = lines(i - 1)$/;"	V
line	ScalaTemplateCompiler.scala	/^          val line = lines.takeRight(1)(0)$/;"	V
line	ScalaTemplateCompiler.scala	/^        val line = Path(source.get).string.substring(0, targetMarker).split('\\n').size$/;"	V
lineContent	PlayLogger.scala	/^      def lineContent() = buffer(buffer.size - 1)._2$/;"	m
lineContent	PlayLogger.scala	/^    val lineContent = pos.lineContent$/;"	V
lineContent	PlayPositionMapper.scala	/^          lazy val lineContent = {$/;"	V
lineContent	PlayReloader.scala	/^                  def lineContent = ""$/;"	m
lineFormat	PlayCommands.scala	/^          val lineFormat = "| %-" + (c1Size + 9) + "s | %-" + (c2Size + 9) + "s | %-" + (c3Size + 9) + "s |"$/;"	V
lineNumberString	PlayLogger.scala	/^    val lineNumberString = m2o(pos.line).map(":" + _ + ":").getOrElse(":") + " "$/;"	V
lines	RoutesCompiler.scala	/^    val lines = if (file.exists) Path(file).string.split('\\n').toList else Nil$/;"	V
lines	ScalaTemplateCompiler.scala	/^      val lines = ListBuffer.empty[(Int, Int)]$/;"	V
lines	ScalaTemplateCompiler.scala	/^    lazy val lines: Seq[(Int, Int)] = {$/;"	V
link	PlayReloader.scala	/^            val link = image match {$/;"	V
link	PlayReloader.scala	/^        val link:(String => (String, String)) = _ match {$/;"	V
links	PlayReloader.scala	/^        val links = new LinkRenderer {$/;"	V
list	Anorm.scala	/^  def list()(implicit connection: java.sql.Connection): Seq[T] = as(defaultParser*)$/;"	m
list	Anorm.scala	/^  def list[A](rowParser: RowParser[A])(implicit connection: java.sql.Connection): Seq[A] = as(rowParser *)$/;"	m
list	Forms.scala	/^  def list[A](mapping: Mapping[A]): Mapping[List[A]] = RepeatedMapping(mapping)$/;"	m
list	JsConstraints.scala	/^  def list[A](implicit reads:Reads[A]): Reads[List[A]] = Reads.traversableReads[List, A]$/;"	m
list	JsConstraints.scala	/^  def list[A](implicit writes:Writes[A]): Writes[List[A]] = Writes.traversableWrites[A]$/;"	m
list	SqlParser.scala	/^  def list[A](p: RowParser[A]): ResultSetParser[List[A]] = {$/;"	m
listener	PlayReloader.scala	/^          val listener = java.lang.reflect.Proxy.newProxyInstance(sbtLoader, Seq(jnotifyListenerClass).toArray, new java.lang.reflect.InvocationHandler {$/;"	V
literal	SqlStatementParser.scala	/^  def literal: Parser[(String, Option[String])] = (stringLiteral | simpleQuotes) ^^ { case s => (s, None) }$/;"	m
load	Configuration.scala	/^  def load(appPath: File, mode: Mode.Mode = Mode.Dev, devSettings: Map[String,String] = Map.empty) = {$/;"	m
loader	PlayReloader.scala	/^        val loader = new java.net.URLClassLoader($/;"	V
localDef	ScalaTemplateCompiler.scala	/^      def localDef: Parser[Def] = {$/;"	m
localNames	RoutesCompiler.scala	/^                            val localNames = reverseParameters.map {$/;"	V
localidRegex	OpenID.scala	/^    private val localidRegex = new Regex( """<link[^>]+openid2[.]local_id[^>]+>""")$/;"	V
lock	Evolutions.scala	/^  def lock(c: Connection, s: Statement, attempts: Int = 5) {$/;"	m
log	PlayAssetsCompiler.scala	/^    val log = state.log$/;"	V
log	PlayCommands.scala	/^              val log = s.log$/;"	V
log	PlayJvm.scala	/^  def log(level: Level.Value, message: => String) = System.out.synchronized {$/;"	m
log	PlayLogger.scala	/^  def log(message: String) {$/;"	m
logAll	PlayJvm.scala	/^  def logAll(events: Seq[LogEvent]) = System.out.synchronized { events.foreach(log) }$/;"	m
logEvent	JUnitXmlTestListener.scala	/^    def logEvent(e: TEvent) = {$/;"	m
logExceptionAndGetResult	Server.scala	/^    def logExceptionAndGetResult(e: Throwable) = {$/;"	m
logName	PlayJvm.scala	/^ * val logName = "* " + name$/;"	V
logged	PlayLogger.scala	/^    val logged = "[info] " + message + "\\r"$/;"	V
logger	DB.scala	/^    val logger = Logger("com.jolbox.bonecp")$/;"	V
logger	Logger.scala	/^  val logger = LoggerFactory.getLogger("application")$/;"	V
logger	Logger.scala	/^  val logger: Slf4jLogger$/;"	V
logger	Logger.scala	/^class Logger(val logger: Slf4jLogger) extends LoggerLike$/;"	V
logger	csrf.scala	/^    lazy val logger = play.api.Logger("play.filters")$/;"	V
loginForm	FormSpec.scala	/^    val loginForm = Form($/;"	V
logo	Console.scala	/^  val logo = Colors.yellow($/;"	V
long	SqlParser.scala	/^  def long(columnName: String): RowParser[Long] = get[Long](columnName)(implicitly[Column[Long]])$/;"	m
longNumber	Forms.scala	/^  def longNumber(min: Long = Long.MinValue, max: Long = Long.MaxValue, strict: Boolean = false): Mapping[Long] = (min, max) match {$/;"	m
longNumber	Forms.scala	/^  val longNumber: Mapping[Long] = of[Long]$/;"	V
longNumberForm	FormSpec.scala	/^    val longNumberForm = Form("longNumber" -> longNumber(10, 42))$/;"	V
loop	Collections.scala	/^    def loop(seed: B)(ls: List[A]): List[A] = f(seed) match {$/;"	m
luigi	JsonSpec.scala	/^      val luigi = User(1, "Luigi", List())$/;"	V
m	JsonSpec.scala	/^      val m = Map("timestamp" -> t)$/;"	V
mac	Crypto.scala	/^    val mac = Mac.getInstance("HmacSHA1")$/;"	V
magenta	Color.scala	/^  def magenta(str: String): String = if (isANSISupported) (MAGENTA + str + RESET) else str$/;"	m
magenta	Console.scala	/^  def magenta(str: String): String = if (isANSISupported) (MAGENTA + str + RESET) else str$/;"	m
main	Console.scala	/^  def main(args: Array[String]) {$/;"	m
main	NettyServer.scala	/^  def main(args: Array[String]) {$/;"	m
mainAddress	NettyServer.scala	/^  def mainAddress: InetSocketAddress$/;"	m
mainAddress	NettyServer.scala	/^  override lazy val mainAddress = HTTP._2.getLocalAddress.asInstanceOf[InetSocketAddress]$/;"	V
mainClass	PlayCommands.scala	/^      val mainClass = applicationLoader.loadClass("play.core.server.NettyServer")$/;"	V
mainDev	NettyServer.scala	/^  def mainDev(sbtLink: SBTLink, port: Int): NettyServer = {$/;"	m
mainDev	PlayCommands.scala	/^      val mainDev = mainClass.getMethod("mainDev", classOf[SBTLink], classOf[Int])$/;"	V
mainIteratee	Concurrent.scala	/^    val mainIteratee = Ref(Cont(step))$/;"	V
mainLang	Project.scala	/^    val mainLang = if (dependencies.contains(javaCore)) JAVA else SCALA$/;"	V
mainScalaClass	PlayJvm.scala	/^ * val mainScalaClass = "scala.tools.nsc.MainGenericRunner"$/;"	V
maliciousSession	ResultsSpec.scala	/^      val maliciousSession = encodedSession.replaceFirst("user%3Aalice", "user%3Amallory")$/;"	V
manage	Selenium.scala	/^  def manage: WebDriver.Options = super.getDriver.manage$/;"	m
managedClasses	PlayCommands.scala	/^      val managedClasses = ((srcManaged ** "*.scala").get ++ (srcManaged ** "*.java").get).map { managedSourceFile =>$/;"	V
managedClassesDirectory	PlayCommands.scala	/^      val managedClassesDirectory = classes.getParentFile \/ (classes.getName + "_managed")$/;"	V
managedSet	PlayCommands.scala	/^      val managedSet = IO.copy(managedClasses)$/;"	V
manager	Cache.scala	/^    val manager = CacheManager.create()$/;"	V
map	Action.scala	/^  def map[B](f: A => B): BodyParser[B] = new BodyParser[B] {$/;"	m
map	Anorm.scala	/^  def map[B](f: ID => B) = toOption.map(f)$/;"	m
map	ConfigurationSpec.scala	/^      val map = Map(exampleConfig.entrySet.toList:_*)$/;"	V
map	Enumeratee.scala	/^  def map[E] = new {$/;"	m
map	Enumerator.scala	/^  def map[U](f: E => U): Enumerator[U] = parent &> Enumeratee.map[E](f)$/;"	m
map	Http.scala	/^    def map[B](f: A => B): Request[B] = new Request[B] {$/;"	m
map	Iteratee.scala	/^      val map = Map(needle.dropRight(1).reverse.zipWithIndex.reverse: _*) \/\/remove the last$/;"	V
map	Iteratee.scala	/^  def map[B](f: A => B): Iteratee[E, B] = this.flatMap(a => Done(f(a), Input.Empty))$/;"	m
map	Iteratee.scala	/^  def map[U](f: (E => U)): Input[U] = this match {$/;"	m
map	JsConstraints.scala	/^  def map[A](implicit reads:Reads[A]): Reads[collection.immutable.Map[String, A]] = Reads.mapReads[A]$/;"	m
map	JsConstraints.scala	/^  def map[A](implicit writes:Writes[A]): OWrites[collection.immutable.Map[String, A]] = Writes.mapWrites[A]$/;"	m
map	JsResult.scala	/^    def map[A,B](m:JsResult[A], f: A => B):JsResult[B] = m.map(f)$/;"	m
map	JsResult.scala	/^    def map[B](f: A => B): JsResult[B] = self match {$/;"	m
map	JsResult.scala	/^  def map[X](f: A => X): JsResult[X] = this match {$/;"	m
map	Reads.scala	/^    def map[A,B](m:Reads[A], f: A => B):Reads[B] = m.map(f)$/;"	m
map	Reads.scala	/^  def map[B](f:A => B):Reads[B] =$/;"	m
map	ReflectionsCache.scala	/^      val map = TrieMap.empty[String, Reflections]$/;"	V
map	Results.scala	/^  def map(f: Result => Result)(implicit ec: ExecutionContext): AsyncResult = AsyncResult(result.map(f))$/;"	m
map	SqlParser.scala	/^  def map[B](f: A => B): ResultSetParser[B] = ResultSetParser(rs => parent(rs).map(f))$/;"	m
map	SqlParser.scala	/^  def map[B](f: A => B): RowParser[B] = RowParser(parent.andThen(_.map(f)))$/;"	m
map	SqlParser.scala	/^  def map[B](f: A => B): SqlResult[B] = self match {$/;"	m
map	Utils.scala	/^  def map[B](f: A => B): MayErr[E, B] = {$/;"	m
map	Writeable.scala	/^  def map[B](f: B => A): Writeable[B] = Writeable(b => transform(f(b)), contentType)$/;"	m
mapAndLogCurrentError	PlayLogger.scala	/^  def mapAndLogCurrentError(level: Level.Value, spaces: String, log: (Level.Value, => String) => Unit) {$/;"	m
mapConcat	Enumeratee.scala	/^  def mapConcat[From] = new {$/;"	m
mapConcatInput	Enumeratee.scala	/^  def mapConcatInput[From] = new {$/;"	m
mapDone	Iteratee.scala	/^  def mapDone[B](f: A => B): Iteratee[E, B] =$/;"	m
mapFlatten	Enumeratee.scala	/^  def mapFlatten[From] = new {$/;"	m
mapInput	Enumeratee.scala	/^  def mapInput[From] = new {$/;"	m
mapInput	Enumerator.scala	/^  def mapInput[U](f: Input[E] => Input[U]) = parent &> Enumeratee.mapInput[E](f)$/;"	m
mapInputFlatten	Enumeratee.scala	/^  def mapInputFlatten[From] = new {$/;"	m
mapInputM	Enumeratee.scala	/^  def mapInputM[From] = new {$/;"	m
mapLine	RoutesCompiler.scala	/^    def mapLine(generatedLine: Int): Option[Int] = {$/;"	m
mapLine	ScalaTemplateCompiler.scala	/^    def mapLine(generatedLine: Int): Int = {$/;"	m
mapM	Enumeratee.scala	/^  def mapM[E] = new {$/;"	m
mapM	Iteratee.scala	/^  def mapM[B](f: A => Future[B]): Iteratee[E, B] = self.flatMapM(a => f(a).map(b => Done(b)))$/;"	m
mapPosition	ScalaTemplateCompiler.scala	/^    def mapPosition(generatedPosition: Int): Int = {$/;"	m
mapUpsAndDowns	Evolutions.scala	/^    val mapUpsAndDowns: PartialFunction[String, String] = {$/;"	V
mappedPosition	PlayReloader.scala	/^        val mappedPosition = playPositionMapper(problem.position)$/;"	V
mapper	JsValue.scala	/^  private[this] val mapper = new ObjectMapper$/;"	V
mapper	TemplateCompilerSpec.scala	/^      val mapper = GeneratedSource(generated)$/;"	V
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15]), a16: (String, Mapping[A16]), a17: (String, Mapping[A17]), a18: (String, Mapping[A18]))(apply: Function18[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, R])(unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15]), a16: (String, Mapping[A16]), a17: (String, Mapping[A17]))(apply: Function17[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, R])(unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15]), a16: (String, Mapping[A16]))(apply: Function16[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, R])(unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15]))(apply: Function15[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, R])(unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]))(apply: Function14[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, R])(unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]))(apply: Function13[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, R])(unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]))(apply: Function12[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, R])(unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]))(apply: Function11[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, R])(unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]))(apply: Function10[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, R])(unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3, A4, A5, A6, A7, A8, A9](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]))(apply: Function9[A1, A2, A3, A4, A5, A6, A7, A8, A9, R])(unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3, A4, A5, A6, A7, A8](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]))(apply: Function8[A1, A2, A3, A4, A5, A6, A7, A8, R])(unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3, A4, A5, A6, A7](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]))(apply: Function7[A1, A2, A3, A4, A5, A6, A7, R])(unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3, A4, A5, A6](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]))(apply: Function6[A1, A2, A3, A4, A5, A6, R])(unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3, A4, A5](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]))(apply: Function5[A1, A2, A3, A4, A5, R])(unapply: Function1[R, Option[(A1, A2, A3, A4, A5)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3, A4](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]))(apply: Function4[A1, A2, A3, A4, R])(unapply: Function1[R, Option[(A1, A2, A3, A4)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2, A3](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]))(apply: Function3[A1, A2, A3, R])(unapply: Function1[R, Option[(A1, A2, A3)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1, A2](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]))(apply: Function2[A1, A2, R])(unapply: Function1[R, Option[(A1, A2)]]): Mapping[R] = {$/;"	m
mapping	Forms.scala	/^  def mapping[R, A1](a1: (String, Mapping[A1]))(apply: Function1[A1, R])(unapply: Function1[R, Option[(A1)]]): Mapping[R] = {$/;"	m
mappings	Form.scala	/^  val mappings = Seq(this) ++ field1.mappings$/;"	V
mappings	Form.scala	/^  val mappings = wrapped.mappings$/;"	V
mappings	Form.scala	/^  val mappings: Seq[Mapping[_]] = Seq(this)$/;"	V
mappings	Form.scala	/^  val mappings: Seq[Mapping[_]] = wrapped.mappings$/;"	V
mappings	Form.scala	/^  val mappings: Seq[Mapping[_]]$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings ++ field4.mappings ++ field5.mappings ++ field6.mappings ++ field7.mappings ++ field8.mappings ++ field9.mappings ++ field10.mappings ++ field11.mappings ++ field12.mappings ++ field13.mappings ++ field14.mappings ++ field15.mappings ++ field16.mappings ++ field17.mappings ++ field18.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings ++ field4.mappings ++ field5.mappings ++ field6.mappings ++ field7.mappings ++ field8.mappings ++ field9.mappings ++ field10.mappings ++ field11.mappings ++ field12.mappings ++ field13.mappings ++ field14.mappings ++ field15.mappings ++ field16.mappings ++ field17.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings ++ field4.mappings ++ field5.mappings ++ field6.mappings ++ field7.mappings ++ field8.mappings ++ field9.mappings ++ field10.mappings ++ field11.mappings ++ field12.mappings ++ field13.mappings ++ field14.mappings ++ field15.mappings ++ field16.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings ++ field4.mappings ++ field5.mappings ++ field6.mappings ++ field7.mappings ++ field8.mappings ++ field9.mappings ++ field10.mappings ++ field11.mappings ++ field12.mappings ++ field13.mappings ++ field14.mappings ++ field15.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings ++ field4.mappings ++ field5.mappings ++ field6.mappings ++ field7.mappings ++ field8.mappings ++ field9.mappings ++ field10.mappings ++ field11.mappings ++ field12.mappings ++ field13.mappings ++ field14.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings ++ field4.mappings ++ field5.mappings ++ field6.mappings ++ field7.mappings ++ field8.mappings ++ field9.mappings ++ field10.mappings ++ field11.mappings ++ field12.mappings ++ field13.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings ++ field4.mappings ++ field5.mappings ++ field6.mappings ++ field7.mappings ++ field8.mappings ++ field9.mappings ++ field10.mappings ++ field11.mappings ++ field12.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings ++ field4.mappings ++ field5.mappings ++ field6.mappings ++ field7.mappings ++ field8.mappings ++ field9.mappings ++ field10.mappings ++ field11.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings ++ field4.mappings ++ field5.mappings ++ field6.mappings ++ field7.mappings ++ field8.mappings ++ field9.mappings ++ field10.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings ++ field4.mappings ++ field5.mappings ++ field6.mappings ++ field7.mappings ++ field8.mappings ++ field9.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings ++ field4.mappings ++ field5.mappings ++ field6.mappings ++ field7.mappings ++ field8.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings ++ field4.mappings ++ field5.mappings ++ field6.mappings ++ field7.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings ++ field4.mappings ++ field5.mappings ++ field6.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings ++ field4.mappings ++ field5.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings ++ field4.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings ++ field3.mappings$/;"	V
mappings	ObjectMappings.scala	/^  val mappings = Seq(this) ++ field1.mappings ++ field2.mappings$/;"	V
mappings	PlayCommands.scala	/^    val mappings = (r.map(d => (d ***) --- (d ** HiddenFileFilter ***)).foldLeft(PathFinder.empty)(_ +++ _).filter(_.isFile) x relativeTo(b +: r.filterNot(_.getAbsolutePath.startsWith(b.getAbsolutePath))) map {$/;"	V
mario	JsonSpec.scala	/^      val mario = User(0, "Mario", List(luigi, kinopio, yoshi))$/;"	V
markdownToHtml	PlayReloader.scala	/^      def markdownToHtml(markdown: String, pagePath: String) = {$/;"	m
matchCompileError	PlayLogger.scala	/^  def matchCompileError(level: Level.Value, message: String, filename: String, line: String, error: String,$/;"	m
matchExpression	ScalaTemplateCompiler.scala	/^      def matchExpression: Parser[Display] = {$/;"	m
matcher	PathParts.scala	/^    val matcher = regex.matcher(path)$/;"	V
matcher	Router.scala	/^    val matcher = regex.matcher(path)$/;"	V
matrix	ScalaTemplateCompiler.scala	/^    lazy val matrix: Seq[(Int, Int)] = {$/;"	V
max	JsConstraints.scala	/^  def max(m:Int)(implicit reads:Reads[Int]) =$/;"	m
max	Validation.scala	/^  def max[T](maxValue: T, strict: Boolean = false)(implicit ordering: scala.math.Ordering[T]): Constraint[T] = Constraint[T]("constraint.max", maxValue) { o =>$/;"	m
maxAge	Http.scala	/^    def maxAge: Option[Int] = None$/;"	m
maxAge	Http.scala	/^    override val maxAge = Play.maybeApplication.flatMap(_.configuration.getInt("session.maxAge"))$/;"	V
maxHeaderBuffer	ContentTypes.scala	/^            val maxHeaderBuffer = Traversable.takeUpTo[Array[Byte]](4 * 1024) transform Iteratee.consume[Array[Byte]]()$/;"	V
maxLength	ContentTypes.scala	/^    def maxLength[A](maxLength: Int, parser: BodyParser[A]): BodyParser[Either[MaxSizeExceeded, A]] = BodyParser("maxLength=" + maxLength + ", wrapping=" + parser.toString) { request =>$/;"	m
maxLength	JsConstraints.scala	/^  def maxLength[M](m:Int)(implicit reads:Reads[M], p: M => scala.collection.TraversableLike[_, M]) =$/;"	m
maxLength	Validation.scala	/^  def maxLength(length: Int): Constraint[String] = Constraint[String]("constraint.maxLength", length) { o =>$/;"	m
maxLines	PlayCommands.scala	/^          val maxLines = Seq(formatted._1.size, formatted._2.size, formatted._3.size).max$/;"	V
maxSize	Configuration.scala	/^   * val maxSize = configuration.getString("engine.maxSize")$/;"	V
maxSizes	Configuration.scala	/^   * val maxSizes = configuration.getBytesList("engine.maxSizes")$/;"	V
maxSizes	Configuration.scala	/^   * val maxSizes = configuration.getDoubleList("engine.maxSizes")$/;"	V
maxSizes	Configuration.scala	/^   * val maxSizes = configuration.getIntList("engine.maxSizes")$/;"	V
maxSizes	Configuration.scala	/^   * val maxSizes = configuration.getList("engine.maxSizes")$/;"	V
maxSizes	Configuration.scala	/^   * val maxSizes = configuration.getLongList("engine.maxSizes")$/;"	V
maxSizes	Configuration.scala	/^   * val maxSizes = configuration.getNumberList("engine.maxSizes")$/;"	V
maybeAction	Server.scala	/^          val maybeAction = application.global.onRouteRequest(request)$/;"	V
maybeApplication	ApplicationProvider.scala	/^          val maybeApplication: Option[Either[Throwable, Application]] = maybeClassLoader.map { projectClassloader =>$/;"	V
maybeApplication	Play.scala	/^  def maybeApplication: Option[Application] = Option(_currentApp)$/;"	m
maybeBoundary	ContentTypes.scala	/^        val maybeBoundary = request.headers.get(play.api.http.HeaderNames.CONTENT_TYPE).filter(ct => ct.trim.startsWith("multipart\/form-data")).flatMap { mpCt =>$/;"	V
maybeConf	Application.scala	/^   * val maybeConf = application.resource("conf\/logger.xml")$/;"	V
maybeConf	Application.scala	/^   * val maybeConf = application.resourceAsStream("conf\/logger.xml")$/;"	V
maybeConf	Play.scala	/^   * val maybeConf = application.resource("conf\/logger.xml")$/;"	V
maybeConf	Play.scala	/^   * val maybeConf = application.resourceAsStream("conf\/logger.xml")$/;"	V
maybeContinuous	PlayCommands.scala	/^      val maybeContinuous = state.get(Watched.Configuration).map { w =>$/;"	V
maybeEtag	Assets.scala	/^      val maybeEtag = lastModifiedFor(resource).map(_ + " -> " + resource.toExternalForm).map("\\"" + Codecs.sha1(_) + "\\"")$/;"	V
maybeLangFromCookie	Controller.scala	/^      val maybeLangFromCookie = request.cookies.get(Play.langCookieName).flatMap(c => Lang.get(c.value))$/;"	V
maybeLastModified	Assets.scala	/^      val maybeLastModified = resource.getProtocol match {$/;"	V
maybeNewState	PlayCommands.scala	/^    val maybeNewState = Project.runTask(dependencyClasspath in Compile, state).get._2.toEither.right.map { dependencies =>$/;"	V
maybeOpenIdServer	DiscoverySpec.scala	/^      val maybeOpenIdServer = new XrdsResolver().resolve(response)$/;"	V
maybeOpenIdServer	OpenID.scala	/^      val maybeOpenIdServer = new XrdsResolver().resolve(response) orElse new HtmlResolver().resolve(response)$/;"	V
maybeSideBar	ApplicationProvider.scala	/^                  val maybeSideBar = parent \\ "_Sidebar.md"$/;"	V
maybeToken	csrf.scala	/^      val maybeToken: Option[Token] = ($/;"	V
md5	Codecs.scala	/^  def md5(bytes: Array[Byte]): String = {$/;"	m
mediaRange	MediaRangeSpec.scala	/^      val mediaRange = MediaRange("*\/*")$/;"	V
mediaRange	MediaRangeSpec.scala	/^      val mediaRange = MediaRange("text\/*")$/;"	V
mediaRange	MediaRangeSpec.scala	/^      val mediaRange = MediaRange("text\/html")$/;"	V
mediaType	MediaRange.scala	/^    val mediaType = parts(0)$/;"	V
mediaTypes	Http.scala	/^      val mediaTypes = acceptHeader(HeaderNames.ACCEPT).map(item => (item._1, MediaRange(item._2)))$/;"	V
merge	Form.scala	/^  def merge(results: Either[Seq[FormError], Any]*): Either[Seq[FormError], Seq[Any]] = {$/;"	m
merge	Http.scala	/^    def merge(cookieHeader: String, cookies: Seq[Cookie]): String = {$/;"	m
merge	JsResult.scala	/^  def merge(e1: JsError, e2: JsError): JsError = {$/;"	m
merge	JsResult.scala	/^  def merge(e1: Seq[(JsPath, Seq[ValidationError])], e2: Seq[(JsPath, Seq[ValidationError])]): Seq[(JsPath, Seq[ValidationError])] = {$/;"	m
merge2	Form.scala	/^  def merge2(a: Either[Seq[FormError], Seq[Any]], b: Either[Seq[FormError], Seq[Any]]): Either[Seq[FormError], Seq[Any]] = (a, b) match {$/;"	m
message	Controller.scala	/^   *   val message = flash("message")$/;"	V
message	Evolutions.scala	/^        val message = e match {$/;"	V
message	Http.scala	/^          val message = splitted.tail.mkString("-")$/;"	V
message	Messages.scala	/^    def message = ignoreWhiteSpace ~ messageKey ~ (ignoreWhiteSpace ~ "=" ~ ignoreWhiteSpace) ~ messagePattern ^^ {$/;"	m
message	PlayReloader.scala	/^                def message = error._3$/;"	m
message	PlayReloader.scala	/^            def message = problem.message$/;"	m
messageKey	Messages.scala	/^    def messageKey = namedError("""[a-zA-Z0-9_.]+""".r, "Message key expected")$/;"	m
messagePattern	Messages.scala	/^    def messagePattern = namedError($/;"	m
messages	Messages.scala	/^  def messages(implicit app: Application): Map[String, Map[String, String]] = {$/;"	m
messages	Messages.scala	/^  private lazy val messages = {$/;"	V
meta	Anorm.scala	/^    val meta = rs.getMetaData()$/;"	V
meta	ScalaTemplateCompiler.scala	/^    lazy val meta: Map[String, String] = {$/;"	V
metaData	Anorm.scala	/^  def metaData(rs: java.sql.ResultSet) = {$/;"	m
metaData	Anorm.scala	/^  val metaData: MetaData$/;"	V
method	FormSpec.scala	/^  def method() = "GET"$/;"	m
method	Http.scala	/^        val method = _method$/;"	V
method	Http.scala	/^      def method = rh.method$/;"	m
method	Http.scala	/^      def method = self.method$/;"	m
method	Http.scala	/^    def method = request.method$/;"	m
method	Http.scala	/^    def method: String$/;"	m
method	JavaAction.scala	/^  def method: java.lang.reflect.Method$/;"	m
method	JavaHelpers.scala	/^      def method = req.method$/;"	m
method	PlayDefaultUpstreamHandler.scala	/^          def method = nettyHttpRequest.getMethod.getName$/;"	m
method	PlayReloader.scala	/^          val method = classOf[java.net.URLClassLoader].getDeclaredMethod("addURL", classOf[java.net.URL])$/;"	V
method	Router.scala	/^          def method = javaAction.method$/;"	m
method	Router.scala	/^          lazy val method = MethodUtils.getMatchingAccessibleMethod(controller, handler.method, handler.parameterTypes: _*)$/;"	V
method	WS.scala	/^    def method: String = _method$/;"	m
method	csrf.scala	/^          def method = request.method$/;"	m
methodCall	ScalaTemplateCompiler.scala	/^      def methodCall: Parser[String] = identifier ~ (squareBrackets?) ~ (parentheses?) ^^ {$/;"	m
methodName	RoutesCompiler.scala	/^          val methodName = classAndMethod(1)$/;"	V
mimeType	RequestExtractors.scala	/^case class Accepting(val mimeType: String) {$/;"	V
min	JsConstraints.scala	/^  def min(m:Int)(implicit reads:Reads[Int]) =$/;"	m
min	LessCompiler.scala	/^      val min = minCompiler(source)$/;"	V
min	Validation.scala	/^  def min[T](minValue: T, strict: Boolean = false)(implicit ordering: scala.math.Ordering[T]): Constraint[T] = Constraint[T]("constraint.min", minValue) { o =>$/;"	m
minCompiler	LessCompiler.scala	/^  private lazy val minCompiler = compiler(true)$/;"	V
minLength	JsConstraints.scala	/^  def minLength[M](m:Int)(implicit reads:Reads[M], p: M => scala.collection.TraversableLike[_, M]) =$/;"	m
minLength	Validation.scala	/^  def minLength(length: Int): Constraint[String] = Constraint[String]("constraint.minLength", length) { o =>$/;"	m
minified	PlayAssetsCompiler.scala	/^      val minified = catching(classOf[CompilationException]).opt(play.core.jscompile.JavascriptCompiler.minify(jsSource, Some(coffeeFile.getName())))$/;"	V
minify	JavascriptCompiler.scala	/^  def minify(source: String, name: Option[String]): String = {$/;"	m
mixed	ScalaTemplateCompiler.scala	/^      def mixed: Parser[Seq[TemplateTree]] = {$/;"	m
mixedFrame	Frame.scala	/^  val mixedFrame = FrameFormatter[Either[String, Array[Byte]]]($/;"	V
mixedFrame	WebSocket.scala	/^    implicit val mixedFrame: FrameFormatter[Either[String, Array[Byte]]] = play.core.server.websocket.Frames.mixedFrame$/;"	V
mode	Application.scala	/^  def mode: Mode.Mode$/;"	m
mode	Application.scala	/^  override val mode: Mode.Mode$/;"	V
mode	Configuration.scala	/^   * val mode = config.getString("engine.mode", Some(Set("dev","prod")))$/;"	V
mode	Fakes.scala	/^  override val mode = play.api.Mode.Test$/;"	V
mode	NettyServer.scala	/^class NettyServer(appProvider: ApplicationProvider, port: Int, sslPort: Option[Int] = None, address: String = "0.0.0.0", val mode: Mode.Mode = Mode.Prod) extends Server with ServerWithStop {$/;"	V
mode	Play.scala	/^  def mode(implicit app: Application): Mode.Mode = app.mode$/;"	m
mode	Server.scala	/^  def mode: Mode.Mode$/;"	m
models	PlayCommands.scala	/^        val models = try {$/;"	V
module	JsValue.scala	/^  object module extends SimpleModule("PlayJson", Version.unknownVersion()) {$/;"	o
moreInput	Concurrent.scala	/^      def moreInput[A](k: K[E, A]): Iteratee[E, Iteratee[E, A]] = {$/;"	m
moveFile	Files.scala	/^  def moveFile(from: File, to: File, replace: Boolean = true, atomicMove: Boolean = true): Path = {$/;"	m
moveTo	Files.scala	/^    def moveTo(to: File, replace: Boolean = false) {$/;"	m
ms	ConcurrentSpec.scala	/^        Enumeratee.scanLeft((now,0L)){ case ((s,v),_) => val ms = now;  (ms,(ms - s)) } &>$/;"	V
msgString	Messages.scala	/^ * val msgString = Messages("items.found", items.size)$/;"	V
multiString	RoutesCompiler.scala	/^    def multiString: Parser[String] = {$/;"	m
multipartFormData	ContentTypes.scala	/^    def multipartFormData: BodyParser[MultipartFormData[TemporaryFile]] = multipartFormData(Multipart.handleFilePartAsTemporaryFile)$/;"	m
multipartFormData	ContentTypes.scala	/^    def multipartFormData[A](filePartHandler: Multipart.PartHandler[FilePart[A]]): BodyParser[MultipartFormData[A]] = BodyParser("multipartFormData") { request =>$/;"	m
multipartFormData	JavaParsers.scala	/^  def multipartFormData(maxLength: Int): BodyParser[RequestBody] = parse.maxLength(orDefault(maxLength), parse.multipartFormData).map {$/;"	m
multipartParser	ContentTypes.scala	/^      def multipartParser[A](partHandler: Map[String, String] => Iteratee[Array[Byte], A]): BodyParser[Seq[A]] = parse.using { request =>$/;"	m
multipleComponentsPathPart	RoutesCompiler.scala	/^    def multipleComponentsPathPart: Parser[DynamicPart] = ("*" ~> identifier) ^^ {$/;"	m
myConf	Application.scala	/^   * val myConf = application.getExistingFile("conf\/myConf.yml")$/;"	V
myConf	Application.scala	/^   * val myConf = application.getFile("conf\/myConf.yml")$/;"	V
myConf	Play.scala	/^   * val myConf = application.getExistingFile("conf\/myConf.yml")$/;"	V
myConf	Play.scala	/^   * val myConf = application.getFile("conf\/myConf.yml")$/;"	V
myForm	FormSpec.scala	/^      val myForm = JForm.form(classOf[play.data.models.Task]).bindFromRequest()$/;"	V
myFormat	JsonValidSpec.scala	/^      val myFormat = (__ \\ 'field).format[String].inmap(Test, unlift(Test.unapply))$/;"	V
myReads	JsonValidSpec.scala	/^      val myReads = ($/;"	V
myReads	JsonValidSpec.scala	/^      val myReads: Reads[JsArray] = ($/;"	V
myReads	JsonValidSpec.scala	/^      val myReads: Reads[JsObject] = ($/;"	V
myWrites	JsonSpec.scala	/^      implicit val myWrites = ($/;"	V
n	Concurrent.scala	/^               val n = {$/;"	V
n	Concurrent.scala	/^            val n = k(in)$/;"	V
n	Enumerator.scala	/^                  val n = k(in)$/;"	V
n	JsonSpec.scala	/^      val n = BigDecimal("12345678901234567890.42")$/;"	V
name	Console.scala	/^        val name = readApplicationName(defaultName)$/;"	V
name	JUnitXmlTestListener.scala	/^  class TestSuite(val name: String) {$/;"	V
name	Task.scala	/^  var name: String = _$/;"	v
namedError	Messages.scala	/^    def namedError[A](p: Parser[A], msg: String) = Parser[A] { i =>$/;"	m
namedError	RoutesCompiler.scala	/^    def namedError[A](p: Parser[A], msg: String): Parser[A] = Parser[A] { i =>$/;"	m
namedImplicits	JsMacroImpl.scala	/^                    val namedImplicits = params.map(_.name).zip(inferedImplicits)$/;"	V
names	Configuration.scala	/^   * val names = configuration.getStringList("names")$/;"	V
namespace	RoutesCompiler.scala	/^    val namespace = Option(Path(file).name).filter(_.endsWith(".routes")).map(_.dropRight(".routes".size))$/;"	V
nativeLibrariesDirectory	PlayReloader.scala	/^          val nativeLibrariesDirectory = new File(targetDirectory, "native_libraries")$/;"	V
nativeSQL	DB.scala	/^  def nativeSQL(sql: String) = connection.nativeSQL(sql)$/;"	m
nativeWatcher	PlayReloader.scala	/^          val nativeWatcher = new {$/;"	V
nbColumns	Anorm.scala	/^    val nbColumns = meta.getColumnCount()$/;"	V
nc	Http.scala	/^          val nc = new DefaultCookie(c.name, c.value)$/;"	V
needRecompilation	ScalaTemplateCompiler.scala	/^    def needRecompilation: Boolean = (!file.exists ||$/;"	m
neededImplicit	JsMacroImpl.scala	/^                  val neededImplicit = c.inferImplicitValue(neededImplicitType)$/;"	V
neededImplicitType	JsMacroImpl.scala	/^                  val neededImplicitType = appliedType(weakTypeOf[Format[_]].typeConstructor, tpe::Nil)$/;"	V
neededImplicitType	JsMacroImpl.scala	/^                  val neededImplicitType = appliedType(weakTypeOf[Reads[_]].typeConstructor, tpe::Nil)$/;"	V
neededImplicitType	JsMacroImpl.scala	/^                  val neededImplicitType = appliedType(weakTypeOf[Writes[_]].typeConstructor, tpe::Nil)$/;"	V
needleSize	Iteratee.scala	/^    val needleSize = needle.size$/;"	V
needsRecompilation	RoutesCompiler.scala	/^    def needsRecompilation: Boolean = {$/;"	m
negative	Validation.scala	/^ *   val negative = Constraint[Int] {$/;"	V
net.sf.ehcache._	Cache.scala	/^  import net.sf.ehcache._$/;"	i
nettyFrameFormatter	WebSocketHandler.scala	/^    val nettyFrameFormatter = frameFormatter.asInstanceOf[play.core.server.websocket.FrameFormatter[A]]$/;"	V
nettyResponse	PlayDefaultUpstreamHandler.scala	/^                val nettyResponse = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(500))$/;"	V
nettyResponse	PlayDefaultUpstreamHandler.scala	/^                val nettyResponse = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.valueOf(status))$/;"	V
nettyUri	PlayDefaultUpstreamHandler.scala	/^        val nettyUri = new QueryStringDecoder(nettyHttpRequest.getUri)$/;"	V
nettyVersion	PlayDefaultUpstreamHandler.scala	/^        var nettyVersion = nettyHttpRequest.getProtocolVersion$/;"	v
newActor	Akka.scala	/^   * val newActor = Akka.system.actorOf[Props[MyActor]]$/;"	V
newApplication	ApplicationProvider.scala	/^              val newApplication = new DefaultApplication(reloadable.path, projectClassloader, Some(new SourceMapper {$/;"	V
newCert	FakeKeyStore.scala	/^    val newCert = new X509CertImpl(certInfo)$/;"	V
newChild	PlayEclipse.scala	/^                val newChild = elem.child ++ <classpathentry path={ "target" + f + ct.getName + f + "src_managed" + f + "main" } kind="src"><\/classpathentry>$/;"	V
newChild	PlayEclipse.scala	/^                val newChild = elem.child ++ <classpathentry path={ scalaLib } kind="lib"><\/classpathentry>$/;"	V
newCommand	Console.scala	/^  def newCommand(args: Array[String]): (String, Int) = {$/;"	m
newCompiler	ScalaTemplateCompiler.scala	/^          val newCompiler = global.asInstanceOf[Scala29Compiler]$/;"	V
newCookieHeader	ResultsSpec.scala	/^      val newCookieHeader = Cookies.merge(setCookieHeader, Seq(Cookie("lang", "fr"), Cookie("session", "items2")))$/;"	V
newCookies	Http.scala	/^      val newCookies = cookies.map{c =>$/;"	V
newDecodedCookies	ResultsSpec.scala	/^      val newDecodedCookies = Cookies.decode(newCookieHeader).map(c => c.name -> c).toMap$/;"	V
newFields	JsValue.scala	/^          val newFields = fields match {$/;"	V
newLine	Messages.scala	/^    def newLine = namedError((("\\r"?) ~> "\\n"), "End of line expected")$/;"	m
newLine	RoutesCompiler.scala	/^    def newLine: Parser[String] = namedError((("\\r"?) ~> "\\n"), "End of line expected")$/;"	m
newLine	ScalaTemplateCompiler.scala	/^      def newLine = (("\\r"?) ~> "\\n")$/;"	m
newMap	Conversions.scala	/^  def newMap[A, B](data: (A, B)*) = Map(data: _*)$/;"	m
newPipeline	NettyServer.scala	/^      val newPipeline = pipeline()$/;"	V
newProducts	PlayReloader.scala	/^        val newProducts = classFiles.map { classFile =>$/;"	V
newPromise	Enumerator.scala	/^    val newPromise = Promise[Iteratee[E, A]]()$/;"	V
newRef	Concurrent.scala	/^              val newRef = Ref(it)$/;"	V
newRef	Concurrent.scala	/^            val newRef = atomic { implicit txn =>$/;"	V
newReloader	PlayReloader.scala	/^  def newReloader(state: State, playReload: TaskKey[sbt.inc.Analysis], baseLoader: ClassLoader) = {$/;"	m
newRequestBodyHandler	RequestBodyHandler.scala	/^  def newRequestBodyHandler[R](firstIteratee: Future[Iteratee[Array[Byte], Result]], allChannels: DefaultChannelGroup, server: Server): (Future[Iteratee[Array[Byte], Result]], SimpleChannelUpstreamHandler) = {$/;"	m
newResults	Iteratee.scala	/^          val newResults = previousMatches ++ List(Unmatched(prefix), Matched(matched)) filter (!_.content.isEmpty)$/;"	V
newS	Iteratee.scala	/^      case Input.El(e) => { val newS = f(s, e); flatten(newS.map { case (s1, done) => if (!done) Cont[E, A](i => step(s1)(i)) else Done(s1, Input.Empty) }) }$/;"	V
newS	Iteratee.scala	/^      case Input.El(e) => { val newS = f(s, e); flatten(newS.map(s1 => Cont[E, A](i => step(s1)(i)))) }$/;"	V
newScan	Iteratee.scala	/^          val newScan = startScan + jump$/;"	V
newSecret	Console.scala	/^    val newSecret = (1 to 64).map { _ =>$/;"	V
newSession	csrf.scala	/^           val newSession = if(session.contains(TOKEN_NAME)) session else (session + (TOKEN_NAME -> token.value))$/;"	V
newSession	csrf.scala	/^          lazy val newSession = request.session + (TOKEN_NAME -> token.value)$/;"	V
newState	PlayCommands.scala	/^      val newState = maybeContinuous match {$/;"	V
newThread	NamedThreadFactory.scala	/^  def newThread(r: Runnable) = {$/;"	m
newWebSocketInHandler	WebSocketHandler.scala	/^  def newWebSocketInHandler[A](frameFormatter: play.api.mvc.WebSocket.FrameFormatter[A]) = {$/;"	m
next	Concurrent.scala	/^                      val next = k(in)$/;"	V
next	Concurrent.scala	/^                  val next = k(item)$/;"	V
next	Concurrent.scala	/^              val next = k(in)$/;"	V
next	Concurrent.scala	/^        val next = Promise[Iteratee[E, Option[A]]]()$/;"	V
next	Concurrent.scala	/^        val next = current.pureFold {$/;"	V
next	Enumeratee.scala	/^                val next = k(in)$/;"	V
next	Enumeratee.scala	/^          val next = f(lastTo, e)$/;"	V
next	Enumerator.scala	/^                val next = k(Input.El(item))$/;"	V
next	Enumerator.scala	/^          val next = currentIt.next$/;"	V
next	Enumerator.scala	/^          val next = k(Input.El(item))$/;"	V
next	Enumerator.scala	/^        val next = it.fold {$/;"	V
next	Enumerator.scala	/^        val next = it.fold{$/;"	V
next	JUnitXmlTestListener.scala	/^          val next = iter.next$/;"	V
next	WebSocketHandler.scala	/^              val next = k(input)$/;"	V
next	WebSocketHandler.scala	/^        val next = current.flatFold($/;"	V
nextI	Enumerator.scala	/^              val nextI = i.fold {$/;"	V
nextIteratee	Enumerator.scala	/^                val nextIteratee = k(Input.El(read))$/;"	V
noCATrustManager	NettyServer.scala	/^object noCATrustManager extends X509TrustManager {$/;"	o
noCords	Concurrent.scala	/^      def noCords() = iteratees.single().isEmpty$/;"	m
noCords	Concurrent.scala	/^    def noCords(): Boolean$/;"	m
nonEmpty	Validation.scala	/^  def nonEmpty: Constraint[String] = Constraint[String]("constraint.required") { o =>$/;"	m
nonEmptyList	SqlParser.scala	/^  def nonEmptyList[A](p: RowParser[A]): ResultSetParser[List[A]] = ResultSetParser(rows => if (rows.isEmpty) Error(SqlMappingError("Empty Result Set")) else list(p)(rows))$/;"	m
nonEmptyText	Forms.scala	/^  def nonEmptyText(minLength: Int = 0, maxLength: Int = Int.MaxValue): Mapping[String] = text(minLength, maxLength) verifying Constraints.nonEmpty$/;"	m
nonEmptyText	Forms.scala	/^  val nonEmptyText: Mapping[String] = text verifying Constraints.nonEmpty$/;"	V
nonNull	Anorm.scala	/^  def nonNull[A](transformer: ((Any, MetaDataItem) => MayErr[SqlRequestError, A])): Column[A] = Column[A] {$/;"	m
normalize	OpenID.scala	/^    def normalize = catching(classOf[MalformedURLException], classOf[URISyntaxException]) opt {$/;"	m
normalizeIdentifier	OpenID.scala	/^  def normalizeIdentifier(openID: String) = {$/;"	m
notFound	Default.scala	/^  def notFound: Action[AnyContent] = Action {$/;"	m
now	ConcurrentSpec.scala	/^    def now = System.currentTimeMillis()$/;"	m
nullArray	NettyServer.scala	/^  val nullArray = Array[X509Certificate]()$/;"	V
nullable	JsConstraints.scala	/^  def nullable[A](path: JsPath)(implicit wrs:Writes[A]): OWrites[Option[A]] =$/;"	m
nullable	JsConstraints.scala	/^  def nullable[A](path:JsPath)(implicit f: Format[A]): OFormat[Option[A]] = $/;"	m
nullable	JsConstraints.scala	/^  def nullable[A](path:JsPath)(implicit reads: Reads[A]) = Reads[Option[A]]{ json => $/;"	m
num	LessCompiler.scala	/^                            var num = timers.length;$/;"	v
number	Forms.scala	/^  def number(min: Int = Int.MinValue, max: Int = Int.MaxValue, strict: Boolean = false): Mapping[Int] = (min, max) match {$/;"	m
number	Forms.scala	/^  val number: Mapping[Int] = of[Int]$/;"	V
numberOfThreads	Execution.scala	/^    val numberOfThreads = play.api.Play.maybeApplication.map(_.configuration.getInt("internal-threadpool-size")).flatten.getOrElse(Runtime.getRuntime.availableProcessors)$/;"	V
o	Binders.scala	/^        val o = ct.runtimeClass.newInstance.asInstanceOf[T].bind(key, params.mapValues(_.toArray).asJava)$/;"	V
o	JsPath.scala	/^      val o = JsObject(obj.fields.map{ case (k,v) => $/;"	V
oauth._	OAuth.scala	/^import oauth._$/;"	i
obj	JsPathSpec.scala	/^      val obj = JsNumber(5)$/;"	V
obj	JsPathSpec.scala	/^      val obj = Json.arr("alpha", "beta", "gamma")$/;"	V
obj	JsPathSpec.scala	/^      val obj = Json.obj( "key1" -> Json.arr("alpha", 5, true, Json.obj("key" -> "value"), "beta"))$/;"	V
obj	JsPathSpec.scala	/^      val obj = Json.obj( "key1" -> Json.obj("key11" -> "value11"), "key2" -> "value2")$/;"	V
obj	JsPathSpec.scala	/^      val obj = Json.obj( $/;"	V
obj	JsPathSpec.scala	/^      val obj = Json.obj("key" -> "value")$/;"	V
obj	JsPathSpec.scala	/^      val obj = Json.obj("key" -> Json.arr("alpha", "beta", "gamma"))$/;"	V
obj	JsPathSpec.scala	/^      val obj = Json.obj("key" -> Json.obj("subkey" -> "value"))$/;"	V
obj	JsPathSpec.scala	/^      val obj = Json.obj("key1" -> "blabla", "key" -> Json.obj("subkey" -> "value"), "key2" -> 567)$/;"	V
obj	Json.scala	/^  def obj(fields: (String, JsValueWrapper)*): JsObject = JsObject(fields.map(f => (f._1, f._2.asInstanceOf[JsValueWrapperImpl].field)))$/;"	m
obj	JsonValidSpec.scala	/^      val obj = JsPath.createObj( $/;"	V
of	Forms.scala	/^  def of[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15]), a16: (String, Mapping[A16]), a17: (String, Mapping[A17]), a18: (String, Mapping[A18])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18)] = of((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11, a12: A12, a13: A13, a14: A14, a15: A15, a16: A16, a17: A17, a18: A18) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18), (t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18)) => Some(t))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18)$/;"	m
of	Forms.scala	/^  def of[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15]), a16: (String, Mapping[A16]), a17: (String, Mapping[A17])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17)] = of((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11, a12: A12, a13: A13, a14: A14, a15: A15, a16: A16, a17: A17) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17), (t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17)) => Some(t))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17)$/;"	m
of	Forms.scala	/^  def of[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15]), a16: (String, Mapping[A16])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16)] = of((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11, a12: A12, a13: A13, a14: A14, a15: A15, a16: A16) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16), (t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16)) => Some(t))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16)$/;"	m
of	Forms.scala	/^  def of[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)] = of((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11, a12: A12, a13: A13, a14: A14, a15: A15) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15), (t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)) => Some(t))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15)$/;"	m
of	Forms.scala	/^  def of[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)] = of((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11, a12: A12, a13: A13, a14: A14) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14), (t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)) => Some(t))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)$/;"	m
of	Forms.scala	/^  def of[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)] = of((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11, a12: A12, a13: A13) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13), (t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)) => Some(t))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)$/;"	m
of	Forms.scala	/^  def of[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)] = of((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11, a12: A12) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12), (t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)) => Some(t))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)$/;"	m
of	Forms.scala	/^  def of[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)] = of((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11), (t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)) => Some(t))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)$/;"	m
of	Forms.scala	/^  def of[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)] = of((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10), (t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)) => Some(t))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)$/;"	m
of	Forms.scala	/^  def of[A1, A2, A3, A4, A5, A6, A7, A8, A9](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9)] = of((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9) => (a1, a2, a3, a4, a5, a6, a7, a8, a9), (t: (A1, A2, A3, A4, A5, A6, A7, A8, A9)) => Some(t))(a1, a2, a3, a4, a5, a6, a7, a8, a9)$/;"	m
of	Forms.scala	/^  def of[A1, A2, A3, A4, A5, A6, A7, A8](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8)] = of((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8) => (a1, a2, a3, a4, a5, a6, a7, a8), (t: (A1, A2, A3, A4, A5, A6, A7, A8)) => Some(t))(a1, a2, a3, a4, a5, a6, a7, a8)$/;"	m
of	Forms.scala	/^  def of[A1, A2, A3, A4, A5, A6, A7](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7])): Mapping[(A1, A2, A3, A4, A5, A6, A7)] = of((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7) => (a1, a2, a3, a4, a5, a6, a7), (t: (A1, A2, A3, A4, A5, A6, A7)) => Some(t))(a1, a2, a3, a4, a5, a6, a7)$/;"	m
of	Forms.scala	/^  def of[A1, A2, A3, A4, A5, A6](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6])): Mapping[(A1, A2, A3, A4, A5, A6)] = of((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => (a1, a2, a3, a4, a5, a6), (t: (A1, A2, A3, A4, A5, A6)) => Some(t))(a1, a2, a3, a4, a5, a6)$/;"	m
of	Forms.scala	/^  def of[A1, A2, A3, A4, A5](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5])): Mapping[(A1, A2, A3, A4, A5)] = of((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => (a1, a2, a3, a4, a5), (t: (A1, A2, A3, A4, A5)) => Some(t))(a1, a2, a3, a4, a5)$/;"	m
of	Forms.scala	/^  def of[A1, A2, A3, A4](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4])): Mapping[(A1, A2, A3, A4)] = of((a1: A1, a2: A2, a3: A3, a4: A4) => (a1, a2, a3, a4), (t: (A1, A2, A3, A4)) => Some(t))(a1, a2, a3, a4)$/;"	m
of	Forms.scala	/^  def of[A1, A2, A3](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3])): Mapping[(A1, A2, A3)] = of((a1: A1, a2: A2, a3: A3) => (a1, a2, a3), (t: (A1, A2, A3)) => Some(t))(a1, a2, a3)$/;"	m
of	Forms.scala	/^  def of[A1, A2](a1: (String, Mapping[A1]), a2: (String, Mapping[A2])): Mapping[(A1, A2)] = of((a1: A1, a2: A2) => (a1, a2), (t: (A1, A2)) => Some(t))(a1, a2)$/;"	m
of	Forms.scala	/^  def of[A1](a1: (String, Mapping[A1])): Mapping[(A1)] = of((a1: A1) => (a1), (t: (A1)) => Some(t))(a1)$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18](apply: Function18[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15]), a16: (String, Mapping[A16]), a17: (String, Mapping[A17]), a18: (String, Mapping[A18])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17](apply: Function17[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15]), a16: (String, Mapping[A16]), a17: (String, Mapping[A17])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16](apply: Function16[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15]), a16: (String, Mapping[A16])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15](apply: Function15[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14](apply: Function14[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13](apply: Function13[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12](apply: Function12[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11](apply: Function11[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10](apply: Function10[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3, A4, A5, A6, A7, A8, A9](apply: Function9[A1, A2, A3, A4, A5, A6, A7, A8, A9, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8, A9)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3, A4, A5, A6, A7, A8](apply: Function8[A1, A2, A3, A4, A5, A6, A7, A8, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7, A8)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3, A4, A5, A6, A7](apply: Function7[A1, A2, A3, A4, A5, A6, A7, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6, A7)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3, A4, A5, A6](apply: Function6[A1, A2, A3, A4, A5, A6, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5, A6)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3, A4, A5](apply: Function5[A1, A2, A3, A4, A5, R], unapply: Function1[R, Option[(A1, A2, A3, A4, A5)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3, A4](apply: Function4[A1, A2, A3, A4, R], unapply: Function1[R, Option[(A1, A2, A3, A4)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2, A3](apply: Function3[A1, A2, A3, R], unapply: Function1[R, Option[(A1, A2, A3)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1, A2](apply: Function2[A1, A2, R], unapply: Function1[R, Option[(A1, A2)]])(a1: (String, Mapping[A1]), a2: (String, Mapping[A2])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[R, A1](apply: Function1[A1, R], unapply: Function1[R, Option[(A1)]])(a1: (String, Mapping[A1])): Mapping[R] = {$/;"	m
of	Forms.scala	/^  def of[T](implicit binder: Formatter[T]): FieldMapping[T] = FieldMapping[T]()(binder)$/;"	m
of	JsConstraints.scala	/^  def of[A](implicit fmt: Format[A]): Format[A] = fmt$/;"	m
of	JsConstraints.scala	/^  def of[A](implicit r: Reads[A]) = r$/;"	m
of	JsConstraints.scala	/^  def of[A](implicit w: Writes[A]) = w$/;"	m
of	Selenium.scala	/^  def of[WEBDRIVER <: WebDriver](webDriver: Class[WEBDRIVER], baseUrl: Option[String] = None) = TestBrowser(WebDriverFactory(webDriver), baseUrl)$/;"	m
ofBytes	JavaWebSocket.scala	/^  def ofBytes(retrieveWebSocket: => play.mvc.WebSocket[Array[Byte]]): Handler = webSocketWrapper[Array[Byte]](retrieveWebSocket)$/;"	m
ofJson	JavaWebSocket.scala	/^  def ofJson(retrieveWebSocket: => play.mvc.WebSocket[org.codehaus.jackson.JsonNode]): Handler = webSocketWrapper[org.codehaus.jackson.JsonNode](retrieveWebSocket)$/;"	m
ofString	JavaWebSocket.scala	/^  def ofString(retrieveWebSocket: => play.mvc.WebSocket[String]): Handler = webSocketWrapper[String](retrieveWebSocket)$/;"	m
offset	PlayLogger.scala	/^      lazy val offset = Maybe.just((IO.read(file).split("\\n").slice(0, lineNo - 1).map(_.length() + 1).reduce((a, b) => a + b) + spaces.length).asInstanceOf[java.lang.Integer])$/;"	V
offset	PlayPositionMapper.scala	/^          val offset = xsbti.Maybe.nothing[java.lang.Integer]$/;"	V
offset	PlayReloader.scala	/^                  def offset = xsbti.Maybe.nothing[java.lang.Integer]$/;"	m
offset	ScalaTemplateCompiler.scala	/^          val offset = in.offset$/;"	V
oldLoader	Threads.scala	/^    val oldLoader = thread.getContextClassLoader$/;"	V
on	Anorm.scala	/^  def on(args: (Any, ParameterValue[_])*): SimpleSql[T] = this.copy(params = (this.params) ++ args.map {$/;"	m
onBadRequest	GlobalSettings.scala	/^  def onBadRequest(request: RequestHeader, error: String): Result = {$/;"	m
onComplete	NettyPromise.scala	/^    def onComplete[U](func: (Try[Unit])  U)(implicit executor: ExecutionContext): Unit = channelPromise.addListener(new ChannelFutureListener {$/;"	m
onDoneEnumerating	Enumerator.scala	/^  def onDoneEnumerating(callback: => Unit) = new Enumerator[E]{$/;"	m
onEOF	Enumeratee.scala	/^  def onEOF[E](action: () => Unit): Enumeratee[E, E] = new CheckDone[E, E] {$/;"	m
onError	GlobalSettings.scala	/^  def onError(request: RequestHeader, ex: Throwable): Result = {$/;"	m
onHandlerNotFound	GlobalSettings.scala	/^  def onHandlerNotFound(request: RequestHeader): Result = {$/;"	m
onIterateeDone	Enumeratee.scala	/^  def onIterateeDone[E](action: () => Unit): Enumeratee[E, E] = new Enumeratee[E, E] {$/;"	m
onLoadConfig	GlobalSettings.scala	/^  def onLoadConfig(config: Configuration, path: File, classloader: ClassLoader, mode: Mode.Mode): Configuration =$/;"	m
onParams	Anorm.scala	/^  def onParams(args: ParameterValue[_]*): SimpleSql[T] = this.copy(params = (this.params) ++ sql.argsInitialOrder.zip(args))$/;"	m
onRedeem	Promise.scala	/^  def onRedeem(k: A => Unit)(implicit ec: ExecutionContext): Unit = extend1 { case Redeemed(a) => k(a); case _ => }$/;"	m
onRequestCompletion	GlobalSettings.scala	/^  def onRequestCompletion(request: RequestHeader) {$/;"	m
onRouteRequest	GlobalSettings.scala	/^  def onRouteRequest(request: RequestHeader): Option[Handler] = Play.maybeApplication.flatMap(_.routes.flatMap { router =>$/;"	m
onStart	GlobalSettings.scala	/^  def onStart(app: Application) {$/;"	m
onStop	GlobalSettings.scala	/^  def onStop(app: Application) {$/;"	m
openId	DiscoverySpec.scala	/^        val openId = "http:\/\/abc.example.com\/foo"$/;"	V
openId	OpenIDSpec.scala	/^      val openId = new OpenIDClient(ws.url)$/;"	V
openIdResponse	OpenIDSpec.scala	/^  def openIdResponse = createDefaultResponse(claimedId, identity, defaultSigned)$/;"	m
operationComplete	NettyPromise.scala	/^      def operationComplete(future: ChannelFuture) {$/;"	m
optionNoError	JsConstraints.scala	/^  def optionNoError[A](implicit reads:Reads[A]): Reads[Option[A]] =$/;"	m
optionWithNull	JsConstraints.scala	/^  def optionWithNull[A](implicit fmt: Format[A]): Format[Option[A]] = Format[Option[A]]( Reads.optionWithNull(fmt), Writes.optionWithNull(fmt) )$/;"	m
optionWithNull	JsConstraints.scala	/^  def optionWithNull[A](implicit wa: Writes[A]) = Writes[Option[A]] { a => $/;"	m
optionWithNull	JsConstraints.scala	/^  def optionWithNull[T](implicit rds: Reads[T]): Reads[Option[T]] = Reads( js => js match {$/;"	m
optional	Forms.scala	/^  def optional[A](mapping: Mapping[A]): Mapping[Option[A]] = OptionalMapping(mapping)$/;"	m
optional	JsConstraints.scala	/^  def optional[A](path: JsPath)(implicit wrs:Writes[A]): OWrites[Option[A]] =$/;"	m
optional	JsConstraints.scala	/^  def optional[A](path:JsPath)(implicit f: Format[A]): OFormat[Option[A]] = $/;"	m
optional	JsConstraints.scala	/^  def optional[A](path:JsPath)(implicit reads: Reads[A]): Reads[Option[A]] = $/;"	m
options	CoffeescriptCompiler.scala	/^      val options = ctx.newObject(scope)$/;"	V
options	JavascriptCompiler.scala	/^    val options = fullCompilerOptions.getOrElse {$/;"	V
options	JavascriptCompiler.scala	/^    val options = new CompilerOptions()$/;"	V
options	PlayJvm.scala	/^ * val options = jvmOptions ++ Seq(bootClasspath, mainScalaClass) ++ arguments$/;"	V
options	WS.scala	/^    def options(): Future[Response] = prepare("OPTIONS").execute$/;"	m
optionsForDbUrl	Helpers.scala	/^    val optionsForDbUrl = options.map { case (k, v) => k + "=" + v }.mkString(";", ";", "")$/;"	V
or	Promise.scala	/^  def or[B](other: Future[B]): Future[Either[A, B]] = {$/;"	m
orElse	JsResult.scala	/^  def orElse[AA >: A](t: => JsResult[AA]): JsResult[AA] = this match {$/;"	m
orElse	Reads.scala	/^  def orElse(v: Reads[A]): Reads[A] = $/;"	m
orTimeout	Promise.scala	/^  def orTimeout(e: Throwable): Future[A] = orTimeout(e, Promise.defaultTimeout)(internalContext).map(_.fold(a => a, e => throw e))(internalContext)$/;"	m
orTimeout	Promise.scala	/^  def orTimeout[B](message: => B, duration: Long, unit: TimeUnit = TimeUnit.MILLISECONDS)(implicit ec: ExecutionContext): Future[Either[A, B]] = {$/;"	m
orTimeout	Promise.scala	/^  def orTimeout[B](message: B): Future[Either[A, B]] = orTimeout(message, Promise.defaultTimeout)(internalContext)$/;"	m
ordering	MediaRange.scala	/^  implicit val ordering = new Ordering[play.api.http.MediaRange] {$/;"	V
org.apache.commons.codec.binary.Base64	WebSocketHandshake.scala	/^import org.apache.commons.codec.binary.Base64$/;"	i
org.apache.commons.codec.binary._	csrf.scala	/^  import org.apache.commons.codec.binary._$/;"	i
org.apache.commons.lang3.reflect.MethodUtils	Router.scala	/^import org.apache.commons.lang3.reflect.MethodUtils$/;"	i
org.apache.commons.lang3.reflect.TypeUtils	Cache.scala	/^import org.apache.commons.lang3.reflect.TypeUtils$/;"	i
org.apache.commons.lang3.{ StringEscapeUtils }	Comet.scala	/^import org.apache.commons.lang3.{ StringEscapeUtils }$/;"	i
org.codehaus.jackson.Version	JsValue.scala	/^  import org.codehaus.jackson.Version$/;"	i
org.codehaus.jackson._	JavaParsers.scala	/^      import org.codehaus.jackson._$/;"	i
org.codehaus.jackson.map.Module.SetupContext	JsValue.scala	/^  import org.codehaus.jackson.map.Module.SetupContext$/;"	i
org.codehaus.jackson.map._	JavaParsers.scala	/^      import org.codehaus.jackson.map._$/;"	i
org.codehaus.jackson.map._	JsValue.scala	/^import org.codehaus.jackson.map._$/;"	i
org.codehaus.jackson.map.annotate.JsonCachable	JsValue.scala	/^import org.codehaus.jackson.map.annotate.JsonCachable$/;"	i
org.codehaus.jackson.map.module.SimpleModule	JsValue.scala	/^  import org.codehaus.jackson.map.module.SimpleModule$/;"	i
org.codehaus.jackson.{ JsonGenerator, JsonToken, JsonParser }	JsValue.scala	/^import org.codehaus.jackson.{ JsonGenerator, JsonToken, JsonParser }$/;"	i
org.fluentlenium.core._	Selenium.scala	/^import org.fluentlenium.core._$/;"	i
org.jboss.netty.bootstrap._	NettyServer.scala	/^import org.jboss.netty.bootstrap._$/;"	i
org.jboss.netty.bootstrap._	PlayDefaultUpstreamHandler.scala	/^import org.jboss.netty.bootstrap._$/;"	i
org.jboss.netty.bootstrap._	RequestBodyHandler.scala	/^import org.jboss.netty.bootstrap._$/;"	i
org.jboss.netty.bootstrap._	WebSocketHandler.scala	/^import org.jboss.netty.bootstrap._$/;"	i
org.jboss.netty.bootstrap._	WebSocketHandshake.scala	/^import org.jboss.netty.bootstrap._$/;"	i
org.jboss.netty.buffer.ChannelBuffer	Frame.scala	/^import org.jboss.netty.buffer.ChannelBuffer$/;"	i
org.jboss.netty.buffer._	PlayDefaultUpstreamHandler.scala	/^import org.jboss.netty.buffer._$/;"	i
org.jboss.netty.buffer._	RequestBodyHandler.scala	/^import org.jboss.netty.buffer._$/;"	i
org.jboss.netty.buffer._	WebSocketHandler.scala	/^import org.jboss.netty.buffer._$/;"	i
org.jboss.netty.buffer._	WebSocketHandshake.scala	/^import org.jboss.netty.buffer._$/;"	i
org.jboss.netty.channel.Channel	Frame.scala	/^import org.jboss.netty.channel.Channel$/;"	i
org.jboss.netty.channel.ChannelFuture	NettyPromise.scala	/^import org.jboss.netty.channel.ChannelFuture$/;"	i
org.jboss.netty.channel.ChannelFutureListener	NettyPromise.scala	/^import org.jboss.netty.channel.ChannelFutureListener$/;"	i
org.jboss.netty.channel.Channels._	NettyServer.scala	/^import org.jboss.netty.channel.Channels._$/;"	i
org.jboss.netty.channel.Channels._	PlayDefaultUpstreamHandler.scala	/^import org.jboss.netty.channel.Channels._$/;"	i
org.jboss.netty.channel.Channels._	RequestBodyHandler.scala	/^import org.jboss.netty.channel.Channels._$/;"	i
org.jboss.netty.channel.Channels._	WebSocketHandler.scala	/^import org.jboss.netty.channel.Channels._$/;"	i
org.jboss.netty.channel.Channels._	WebSocketHandshake.scala	/^import org.jboss.netty.channel.Channels._$/;"	i
org.jboss.netty.channel._	NettyServer.scala	/^import org.jboss.netty.channel._$/;"	i
org.jboss.netty.channel._	PlayDefaultUpstreamHandler.scala	/^import org.jboss.netty.channel._$/;"	i
org.jboss.netty.channel._	RequestBodyHandler.scala	/^import org.jboss.netty.channel._$/;"	i
org.jboss.netty.channel._	WebSocketHandler.scala	/^import org.jboss.netty.channel._$/;"	i
org.jboss.netty.channel._	WebSocketHandshake.scala	/^import org.jboss.netty.channel._$/;"	i
org.jboss.netty.channel.group._	NettyServer.scala	/^import org.jboss.netty.channel.group._$/;"	i
org.jboss.netty.channel.group._	PlayDefaultUpstreamHandler.scala	/^import org.jboss.netty.channel.group._$/;"	i
org.jboss.netty.channel.group._	RequestBodyHandler.scala	/^import org.jboss.netty.channel.group._$/;"	i
org.jboss.netty.channel.group._	WebSocketHandler.scala	/^import org.jboss.netty.channel.group._$/;"	i
org.jboss.netty.channel.group._	WebSocketHandshake.scala	/^import org.jboss.netty.channel.group._$/;"	i
org.jboss.netty.channel.socket.nio._	PlayDefaultUpstreamHandler.scala	/^import org.jboss.netty.channel.socket.nio._$/;"	i
org.jboss.netty.channel.socket.nio._	RequestBodyHandler.scala	/^import org.jboss.netty.channel.socket.nio._$/;"	i
org.jboss.netty.channel.socket.nio._	WebSocketHandler.scala	/^import org.jboss.netty.channel.socket.nio._$/;"	i
org.jboss.netty.channel.socket.nio._	WebSocketHandshake.scala	/^import org.jboss.netty.channel.socket.nio._$/;"	i
org.jboss.netty.handler.codec.http.HttpHeaders.Names._	PlayDefaultUpstreamHandler.scala	/^import org.jboss.netty.handler.codec.http.HttpHeaders.Names._$/;"	i
org.jboss.netty.handler.codec.http.HttpHeaders.Names._	WebSocketHandler.scala	/^import org.jboss.netty.handler.codec.http.HttpHeaders.Names._$/;"	i
org.jboss.netty.handler.codec.http.HttpHeaders.Names._	WebSocketHandshake.scala	/^import org.jboss.netty.handler.codec.http.HttpHeaders.Names._$/;"	i
org.jboss.netty.handler.codec.http.HttpHeaders.Values._	PlayDefaultUpstreamHandler.scala	/^import org.jboss.netty.handler.codec.http.HttpHeaders.Values._$/;"	i
org.jboss.netty.handler.codec.http.HttpHeaders.Values._	WebSocketHandler.scala	/^import org.jboss.netty.handler.codec.http.HttpHeaders.Values._$/;"	i
org.jboss.netty.handler.codec.http.HttpHeaders.Values._	WebSocketHandshake.scala	/^import org.jboss.netty.handler.codec.http.HttpHeaders.Values._$/;"	i
org.jboss.netty.handler.codec.http.HttpHeaders._	PlayDefaultUpstreamHandler.scala	/^import org.jboss.netty.handler.codec.http.HttpHeaders._$/;"	i
org.jboss.netty.handler.codec.http.HttpHeaders._	WebSocketHandler.scala	/^import org.jboss.netty.handler.codec.http.HttpHeaders._$/;"	i
org.jboss.netty.handler.codec.http.HttpHeaders._	WebSocketHandshake.scala	/^import org.jboss.netty.handler.codec.http.HttpHeaders._$/;"	i
org.jboss.netty.handler.codec.http._	NettyServer.scala	/^import org.jboss.netty.handler.codec.http._$/;"	i
org.jboss.netty.handler.codec.http._	PlayDefaultUpstreamHandler.scala	/^import org.jboss.netty.handler.codec.http._$/;"	i
org.jboss.netty.handler.codec.http._	RequestBodyHandler.scala	/^import org.jboss.netty.handler.codec.http._$/;"	i
org.jboss.netty.handler.codec.http._	WebSocketHandler.scala	/^import org.jboss.netty.handler.codec.http._$/;"	i
org.jboss.netty.handler.codec.http._	WebSocketHandshake.scala	/^import org.jboss.netty.handler.codec.http._$/;"	i
org.jboss.netty.handler.codec.http.websocketx.BinaryWebSocketFrame	Frame.scala	/^import org.jboss.netty.handler.codec.http.websocketx.BinaryWebSocketFrame$/;"	i
org.jboss.netty.handler.codec.http.websocketx.TextWebSocketFrame	Frame.scala	/^import org.jboss.netty.handler.codec.http.websocketx.TextWebSocketFrame$/;"	i
org.jboss.netty.handler.codec.http.websocketx.WebSocketFrame	Frame.scala	/^import org.jboss.netty.handler.codec.http.websocketx.WebSocketFrame$/;"	i
org.jboss.netty.handler.codec.http.websocketx._	WebSocketHandler.scala	/^import org.jboss.netty.handler.codec.http.websocketx._$/;"	i
org.jboss.netty.handler.codec.http.websocketx._	WebSocketHandshake.scala	/^import org.jboss.netty.handler.codec.http.websocketx._$/;"	i
org.jboss.netty.handler.codec.http.{ CookieEncoder, CookieDecoder, DefaultCookie }	Http.scala	/^    import org.jboss.netty.handler.codec.http.{ CookieEncoder, CookieDecoder, DefaultCookie }$/;"	i
org.jboss.netty.handler.ssl._	NettyServer.scala	/^import org.jboss.netty.handler.ssl._$/;"	i
org.jboss.netty.handler.ssl._	PlayDefaultUpstreamHandler.scala	/^import org.jboss.netty.handler.ssl._$/;"	i
org.jboss.netty.handler.stream._	PlayDefaultUpstreamHandler.scala	/^import org.jboss.netty.handler.stream._$/;"	i
org.jboss.netty.handler.stream._	RequestBodyHandler.scala	/^import org.jboss.netty.handler.stream._$/;"	i
org.jboss.netty.handler.stream._	WebSocketHandler.scala	/^import org.jboss.netty.handler.stream._$/;"	i
org.jboss.netty.handler.stream._	WebSocketHandshake.scala	/^import org.jboss.netty.handler.stream._$/;"	i
org.jboss.netty.util.CharsetUtil	Frame.scala	/^import org.jboss.netty.util.CharsetUtil$/;"	i
org.joda.time.DateTime	FormSpec.scala	/^    import org.joda.time.DateTime$/;"	i
org.joda.time.DateTime	Reads.scala	/^    import org.joda.time.DateTime$/;"	i
org.joda.time.DateTimeZone	Assets.scala	/^import org.joda.time.DateTimeZone$/;"	i
org.joda.time.LocalDate	FormSpec.scala	/^    import org.joda.time.LocalDate$/;"	i
org.joda.time.LocalDate	Reads.scala	/^    import org.joda.time.LocalDate$/;"	i
org.joda.time.format.{ DateTimeFormatter, DateTimeFormat }	Assets.scala	/^import org.joda.time.format.{ DateTimeFormatter, DateTimeFormat }$/;"	i
org.joda.time.format.{DateTimeFormat,ISODateTimeFormat}	Reads.scala	/^    import org.joda.time.format.{DateTimeFormat,ISODateTimeFormat}$/;"	i
org.mockito._	OpenIDSpec.scala	/^import org.mockito._$/;"	i
org.mozilla.javascript._	CoffeescriptCompiler.scala	/^  import org.mozilla.javascript._$/;"	i
org.mozilla.javascript._	JavascriptCompiler.scala	/^    import org.mozilla.javascript._$/;"	i
org.mozilla.javascript._	LessCompiler.scala	/^  import org.mozilla.javascript._$/;"	i
org.mozilla.javascript.tools.shell._	CoffeescriptCompiler.scala	/^  import org.mozilla.javascript.tools.shell._$/;"	i
org.mozilla.javascript.tools.shell._	JavascriptCompiler.scala	/^    import org.mozilla.javascript.tools.shell._$/;"	i
org.mozilla.javascript.tools.shell._	LessCompiler.scala	/^  import org.mozilla.javascript.tools.shell._$/;"	i
org.openqa.selenium.WebDriver	Specs.scala	/^import org.openqa.selenium.WebDriver$/;"	i
org.openqa.selenium._	Helpers.scala	/^import org.openqa.selenium._$/;"	i
org.openqa.selenium._	Selenium.scala	/^import org.openqa.selenium._$/;"	i
org.openqa.selenium.firefox._	Helpers.scala	/^import org.openqa.selenium.firefox._$/;"	i
org.openqa.selenium.firefox._	Selenium.scala	/^import org.openqa.selenium.firefox._$/;"	i
org.openqa.selenium.htmlunit._	Helpers.scala	/^import org.openqa.selenium.htmlunit._$/;"	i
org.openqa.selenium.htmlunit._	Selenium.scala	/^import org.openqa.selenium.htmlunit._$/;"	i
org.openqa.selenium.support.ui.FluentWait	Selenium.scala	/^import org.openqa.selenium.support.ui.FluentWait$/;"	i
org.pegdown._	PlayReloader.scala	/^        import org.pegdown._$/;"	i
org.pegdown.ast._	PlayReloader.scala	/^        import org.pegdown.ast._$/;"	i
org.reflections.util.FilterBuilder	ReflectionsCache.scala	/^import org.reflections.util.FilterBuilder$/;"	i
org.reflections.{scanners, util, Reflections}	ReflectionsCache.scala	/^  import org.reflections.{scanners, util, Reflections}$/;"	i
org.scalatools.testing.{ Event => TEvent, Result => TResult }	PlayTestListener.scala	/^import org.scalatools.testing.{ Event => TEvent, Result => TResult }$/;"	i
org.scalatools.testing.{ Event => TEvent, Result => TResult, Logger => TLogger }	JUnitXmlTestListener.scala	/^import org.scalatools.testing.{ Event => TEvent, Result => TResult, Logger => TLogger }$/;"	i
org.slf4j._	Logger.scala	/^      import org.slf4j._$/;"	i
org.slf4j.bridge._	Logger.scala	/^      import org.slf4j.bridge._$/;"	i
org.slf4j.{ LoggerFactory, Logger => Slf4jLogger }	Logger.scala	/^import org.slf4j.{ LoggerFactory, Logger => Slf4jLogger }$/;"	i
org.specs2.control.NoStackTraceFilter	DiscoverySpec.scala	/^import org.specs2.control.NoStackTraceFilter$/;"	i
org.specs2.execute.Result	PromiseSpec.scala	/^import org.specs2.execute.Result$/;"	i
org.specs2.execute.{AsResult,Result}	Specs.scala	/^import org.specs2.execute.{AsResult,Result}$/;"	i
org.specs2.execute.{Result => SpecsResult,AsResult}	ResultsSpec.scala	/^import org.specs2.execute.{Result => SpecsResult,AsResult}$/;"	i
org.specs2.mock.Mockito	OpenIDSpec.scala	/^import org.specs2.mock.Mockito$/;"	i
org.specs2.mock.Mockito	WsMock.scala	/^import org.specs2.mock.Mockito$/;"	i
org.specs2.mock._	DiscoverySpec.scala	/^import org.specs2.mock._$/;"	i
org.specs2.mutable.Around	Specs.scala	/^import org.specs2.mutable.Around$/;"	i
org.specs2.mutable.Specification	ConfigurationSpec.scala	/^import org.specs2.mutable.Specification$/;"	i
org.specs2.mutable.Specification	DiscoverySpec.scala	/^import org.specs2.mutable.Specification$/;"	i
org.specs2.mutable.Specification	DynamicFormSpec.scala	/^import org.specs2.mutable.Specification$/;"	i
org.specs2.mutable.Specification	FormSpec.scala	/^import org.specs2.mutable.Specification$/;"	i
org.specs2.mutable.Specification	FormatSpec.scala	/^import org.specs2.mutable.Specification$/;"	i
org.specs2.mutable.Specification	OpenIDSpec.scala	/^import org.specs2.mutable.Specification$/;"	i
org.specs2.mutable.Specification	PartialValidationSpec.scala	/^import org.specs2.mutable.Specification$/;"	i
org.specs2.mutable.Specification	PromiseSpec.scala	/^import org.specs2.mutable.Specification$/;"	i
org.specs2.mutable.Specification	RouterSpec.scala	/^import org.specs2.mutable.Specification$/;"	i
org.specs2.mutable.Specification	RoutesCompilerSpec.scala	/^import org.specs2.mutable.Specification$/;"	i
org.specs2.mutable.Specification	ScriptSpec.scala	/^import org.specs2.mutable.Specification$/;"	i
org.specs2.mutable.Specification	ThreadsSpec.scala	/^import org.specs2.mutable.Specification$/;"	i
org.specs2.mutable.Specification	UserInfoSpec.scala	/^import org.specs2.mutable.Specification$/;"	i
org.specs2.mutable.Specification	WSSpec.scala	/^import org.specs2.mutable.Specification$/;"	i
org.specs2.mutable._	BindersSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	CacheSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	ConcurrentSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	CryptoSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	EnumerateesSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	EnumeratorsSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	HelpersSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	JsPathSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	JsonExtensionSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	JsonRichSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	JsonSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	JsonTransSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	JsonValidSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	MediaRangeSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	MessagesSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	ParsingSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	ResultsSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	SpecsSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	TemplateCompilerSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	TemplateParserSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	TemplateUtilsSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	TemplatesSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.mutable._	ValidationSpec.scala	/^import org.specs2.mutable._$/;"	i
org.specs2.specification.Scope	Specs.scala	/^import org.specs2.specification.Scope$/;"	i
org.specs2.specification.{AroundOutside, Scope}	ResultsSpec.scala	/^import org.specs2.specification.{AroundOutside, Scope}$/;"	i
origBootclasspath	ScalaTemplateCompiler.scala	/^            val origBootclasspath = settings.bootclasspath.value$/;"	V
origBootclasspath	TemplateCompilerSpec.scala	/^        val origBootclasspath = settings.bootclasspath.value$/;"	V
origin	JavascriptCompiler.scala	/^    val origin = Path(source).string$/;"	V
originalContextClassLoader	PlayCommands.scala	/^      val originalContextClassLoader = Thread.currentThread.getContextClassLoader$/;"	V
os	EnumeratorsSpec.scala	/^    var os: OutputStream = null$/;"	v
other	PlayCommands.scala	/^    val other = Seq((root \/ "README") -> (packageName + "\/README"))$/;"	V
other	SqlStatementParser.scala	/^  def other: Parser[(String, Option[String])] = """.""".r ^^ {$/;"	m
out	CoffeescriptCompiler.scala	/^    var out = List[String]()$/;"	v
out	JavascriptCompiler.scala	/^    var out = List[String]()$/;"	v
out	PlayAssetsCompiler.scala	/^              val out = new File(resources, "public\/" + naming(name, false))$/;"	V
outMin	PlayAssetsCompiler.scala	/^                val outMin = new File(resources, "public\/" + naming(name, true))$/;"	V
outStream	ContentTypes.scala	/^  private var outStream: OutputStream = _$/;"	v
outputDir	JUnitXmlTestListener.scala	/^class JUnitXmlTestsListener(val outputDir: String, logger: Logger) extends TestsListener {$/;"	V
outputStream	Enumerator.scala	/^      val outputStream = new java.io.OutputStream(){$/;"	V
outputStream	Enumerator.scala	/^  def outputStream(a: java.io.OutputStream => Unit): Enumerator[Array[Byte]] = {$/;"	m
overloaded	PlayExceptions.scala	/^    val overloaded = """(?s)overloaded method value (.*) with alternatives:(.*)cannot be applied to(.*)""".r$/;"	V
owner	FakeKeyStore.scala	/^    val owner = new X500Name(DnName)$/;"	V
p	Concurrent.scala	/^                val p = Promise[Input[E]]()$/;"	V
p	Concurrent.scala	/^          val p = t._2$/;"	V
p	Concurrent.scala	/^    val p = Promise[A]()$/;"	V
p	ConcurrentSpec.scala	/^      val p = Promise[List[Long]]()$/;"	V
p	ConcurrentSpec.scala	/^    val p = Promise[A]()$/;"	V
p	Enumerator.scala	/^          val p = Promise[Iteratee[E, A]]()$/;"	V
p	Enumerator.scala	/^          val p = Promise[Iteratee[E2, A]]()$/;"	V
p	EnumeratorsSpec.scala	/^    val p = pp.future.await.get$/;"	V
p	Filters.scala	/^    val p = scala.concurrent.Promise[Result]()$/;"	V
p	JsPathSpec.scala	/^      val p = (JsPath \\ 'key)(1)$/;"	V
p	JsPathSpec.scala	/^      val p = JsPath(1)$/;"	V
p	OAuth.scala	/^    val p = new CommonsHttpOAuthProvider(info.requestTokenURL, info.accessTokenURL, info.authorizationURL)$/;"	V
p	PlayDefaultUpstreamHandler.scala	/^                      val p = NettyPromise(f)$/;"	V
p	PlayDefaultUpstreamHandler.scala	/^                  val p = (body |>>> Enumeratee.grouped(stringIteratee) &>> Cont { $/;"	V
p	PlayDefaultUpstreamHandler.scala	/^            val p: ChannelPipeline = ctx.getChannel().getPipeline()$/;"	V
p	Promise.scala	/^    val p = Promise[A]()$/;"	V
p	Promise.scala	/^    val p = Promise[Either[A, B]]()$/;"	V
p	PromiseSpec.scala	/^        val p = Promise.timeout(42, 100)$/;"	V
p	PromiseSpec.scala	/^        val p = Promise.timeout(42, 100).map[Int]{ _ => throw new Exception("foo") }$/;"	V
p	RequestBodyHandler.scala	/^    var p = Promise[Iteratee[Array[Byte], Result]]()$/;"	v
p	WebSocket.scala	/^      val p = f(rh)$/;"	V
p	WebSocketHandler.scala	/^    val p: ChannelPipeline = ctx.getChannel().getPipeline();$/;"	V
p0	RoutesCompiler.scala	/^        val p0 = p \/\/ avoid repeatedly re-evaluating by-name parser$/;"	V
p0	ScalaTemplateCompiler.scala	/^          val p0 = p \/\/ avoid repeatedly re-evaluating by-name parser$/;"	V
pWithBrackets	ScalaTemplateCompiler.scala	/^        val pWithBrackets = "{" ~> p <~ ("}" | eof ~ err("EOF"))$/;"	V
packageDir	RoutesCompiler.scala	/^    val packageDir = namespace.map(pkg => new File(generatedDir, pkg)).getOrElse(generatedDir)$/;"	V
packageName	PlayCommands.scala	/^    val packageName = id + "-" + version$/;"	V
packageName	RoutesCompiler.scala	/^          val packageName = packageParts.mkString(".")$/;"	V
pageWithSidebar	ApplicationProvider.scala	/^          val pageWithSidebar = documentationHome.flatMap { home =>$/;"	V
pages	ApplicationProvider.scala	/^            val pages = Path(book).string.split('\\n').toSeq.map(_.trim)$/;"	V
parameter	RoutesCompiler.scala	/^    def parameter: Parser[Parameter] = (identifier <~ ignoreWhiteSpace) ~ opt(parameterType) ~ (ignoreWhiteSpace ~> opt(parameterDefaultValue | parameterFixedValue)) ^^ {$/;"	m
parameterDefaultValue	RoutesCompiler.scala	/^    def parameterDefaultValue: Parser[String] = "?=" ~ ignoreWhiteSpace ~ expression ^^ {$/;"	m
parameterFixedValue	RoutesCompiler.scala	/^    def parameterFixedValue: Parser[String] = "=" ~ ignoreWhiteSpace ~ expression ^^ {$/;"	m
parameterType	RoutesCompiler.scala	/^    def parameterType: Parser[String] = ":" ~> ignoreWhiteSpace ~> rep1sep(identifier, ".") ~ opt(brackets) ^^ {$/;"	m
parameters	OpenID.scala	/^      val parameters = Seq($/;"	V
parameters	PlayDefaultUpstreamHandler.scala	/^        val parameters = Map.empty[String, Seq[String]] ++ nettyUri.getParameters.asScala.mapValues(_.asScala)$/;"	V
parameters	RoutesCompiler.scala	/^                    val parameters = route.call.parameters.getOrElse(Nil)$/;"	V
parameters	RoutesCompiler.scala	/^                    val parameters = routes(0).call.parameters.getOrElse(Nil)$/;"	V
parameters	RoutesCompiler.scala	/^    def parameters: Parser[List[Parameter]] = "(" ~> repsep(ignoreWhiteSpace ~> positioned(parameter) <~ ignoreWhiteSpace, ",") <~ ")"$/;"	m
params	FormUrlEncodedParser.scala	/^    var params = HashMap.empty[String, Seq[String]]$/;"	v
params	JsMacroImpl.scala	/^                val params = apply.paramss.head \/\/verify there is a single parameter group$/;"	V
params	ScalaTemplateCompiler.scala	/^        val params = findSignature($/;"	V
parentheses	RoutesCompiler.scala	/^    def parentheses: Parser[String] = {$/;"	m
parentheses	ScalaTemplateCompiler.scala	/^      def parentheses: Parser[String] = {$/;"	m
parsableTimezoneCode	Assets.scala	/^  private val parsableTimezoneCode = " " + timeZoneCode$/;"	V
parse	Anorm.scala	/^  def parse[T](parser: ResultSetParser[T])(implicit connection: java.sql.Connection): T = Sql.parse[T](parser, resultSet())$/;"	m
parse	Anorm.scala	/^  def parse[T](parser: ResultSetParser[T], rs: java.sql.ResultSet): T =$/;"	m
parse	ContentTypes.scala	/^  object parse {$/;"	o
parse	FormUrlEncodedParser.scala	/^  def parse(data: String, encoding: String = "utf-8"): Map[String, Seq[String]] = {$/;"	m
parse	Json.scala	/^  def parse(input: Array[Byte]): JsValue = JacksonJson.parseJsValue(input)$/;"	m
parse	Json.scala	/^  def parse(input: String): JsValue = JacksonJson.parseJsValue(input)$/;"	m
parse	Messages.scala	/^    def parse = {$/;"	m
parse	RoutesCompiler.scala	/^    def parse(text: String): ParseResult[List[Rule]] = {$/;"	m
parse	SqlStatementParser.scala	/^  def parse(in: String): (String, List[String]) = {$/;"	m
parse	TemplateParserSpec.scala	/^    def parse(templateName: String) = {$/;"	m
parseAndGenerateCode	ScalaTemplateCompiler.scala	/^    def parseAndGenerateCode(templateName: Array[String], content: Array[Byte], absolutePath: String, resultType: String, formatterType: String, additionalImports: String) = {$/;"	m
parseDate	Assets.scala	/^    def parseDate(date: String): Option[java.util.Date] = try {$/;"	m
parseError	RoutesCompilerSpec.scala	/^    def parseError(line: String) = {$/;"	m
parseJsValue	JsValue.scala	/^  def parseJsValue(data: Array[Byte]): JsValue = {$/;"	m
parseJsValue	JsValue.scala	/^  def parseJsValue(input: String): JsValue = {$/;"	m
parseRoute	RoutesCompilerSpec.scala	/^    def parseRoute(line: String) = {$/;"	m
parseRule	RoutesCompilerSpec.scala	/^    def parseRule(line: String) = {$/;"	m
parsed	Console.scala	/^          val parsed = repo.split(" ").partition { s => Param.pattern.matcher(s).matches } match {$/;"	V
parsed	Evolutions.scala	/^        val parsed = Collections.unfoldLeft(("", script.split('\\n').toList.map(_.trim))) {$/;"	V
parsed	ParsingSpec.scala	/^      val parsed = data |>>> Parsing.search("kiki".getBytes).transform(Iteratee.fold(List.empty[MatchInfo[Array[Byte]]]) { (s, c) => s :+ c })$/;"	V
parsed	PlayReloader.scala	/^              var parsed: (Option[(String, String, String)], Option[Int]) = (None, None)$/;"	v
parsedBody	Helpers.scala	/^        val parsedBody: Option[Either[play.api.mvc.Result, T]] = action.parser(request).fold1($/;"	V
parsedJson	JsonSpec.scala	/^      val parsedJson = Json.parse(postJson)$/;"	V
parser	Action.scala	/^    def parser = bodyParser$/;"	m
parser	Action.scala	/^  def parser: BodyParser[A]$/;"	m
parser	Cached.scala	/^  lazy val parser = action.parser$/;"	V
parser	JavaAction.scala	/^  def parser: BodyParser[play.mvc.Http.RequestBody] = {$/;"	m
parser	Messages.scala	/^    def parser = phrase((sentence | blankLine *) <~ end) ^^ {$/;"	m
parser	PlayReloader.scala	/^        val parser = Act.scopedKeyParser(state)$/;"	V
parser	RoutesCompiler.scala	/^      val parser = new RouteFileParser$/;"	V
parser	RoutesCompiler.scala	/^    def parser: Parser[List[Rule]] = phrase((blankLine | sentence *) <~ end) ^^ {$/;"	m
parser	RoutesCompilerSpec.scala	/^      val parser = new RouteFileParser$/;"	V
parser	ScalaTemplateCompiler.scala	/^      def parser: Parser[Template] = {$/;"	m
parser	TemplateParserSpec.scala	/^    val parser = ScalaTemplateCompiler.templateParser$/;"	V
parts	FormUrlEncodedParser.scala	/^        val parts = param.split('=')$/;"	V
parts	MediaRange.scala	/^    val parts = mediaRange.split('\/')$/;"	V
parts	PlayReloader.scala	/^            val parts = link.split('|')$/;"	V
parts	ScalaTemplateCompiler.scala	/^            val parts = suffix.split('.')$/;"	V
passAlong	Enumeratee.scala	/^  def passAlong[M] = new Enumeratee.CheckDone[M, M] {$/;"	m
passAlong	TraversableIteratee.scala	/^  def passAlong[M] = Enumeratee.passAlong[M]$/;"	m
passAlongFuture	EnumerateesSpec.scala	/^      val passAlongFuture = Enumeratee.flatten {$/;"	V
password	NettyServer.scala	/^        val password = System.getProperty("https.keyStorePassword", "").toCharArray$/;"	V
patchIn	Concurrent.scala	/^        def patchIn(e: Enumerator[E]): Boolean = {$/;"	m
patchIn	Concurrent.scala	/^    def patchIn(e: Enumerator[E]): Boolean$/;"	m
patchPanel	Concurrent.scala	/^  def patchPanel[E](patcher: PatchPanel[E] => Unit): Enumerator[E] = new Enumerator[E] {$/;"	m
path	Application.scala	/^  def path: File$/;"	m
path	Application.scala	/^  override val path: File,$/;"	V
path	ApplicationProvider.scala	/^  def path = application.path$/;"	m
path	ApplicationProvider.scala	/^  def path = applicationPath$/;"	m
path	ApplicationProvider.scala	/^  def path: File$/;"	m
path	ApplicationProvider.scala	/^  lazy val path = sbtLink.projectPath$/;"	V
path	Console.scala	/^    val path = args.headOption.map(new File(_)).getOrElse(new File(".")).getCanonicalFile$/;"	V
path	Fakes.scala	/^    override val path: java.io.File = new java.io.File("."),$/;"	V
path	Fakes.scala	/^  lazy val path = uri.split('?').take(1).mkString$/;"	V
path	FormSpec.scala	/^  def path() = "test"$/;"	m
path	Format.scala	/^  val path: PathFormat = this$/;"	V
path	Http.scala	/^        val path = _path$/;"	V
path	Http.scala	/^      def path = rh.path$/;"	m
path	Http.scala	/^      def path = self.path$/;"	m
path	Http.scala	/^    def path = "\/"$/;"	m
path	Http.scala	/^    def path = request.path$/;"	m
path	Http.scala	/^    def path: String$/;"	m
path	Http.scala	/^    override val path = Play.maybeApplication.flatMap(_.configuration.getString("application.context")).getOrElse("\/")$/;"	V
path	JavaHelpers.scala	/^      def path = req.path$/;"	m
path	OpenID.scala	/^      def path(path:String) = if(null == path || path.isEmpty) "\/" else path$/;"	m
path	PlayCommands.scala	/^        classpath.foreach { item =>$/;"	c
path	PlayCommands.scala	/^        val path = ("lib\/" + filename.getOrElse(dependency.data.getName))$/;"	V
path	PlayCommands.scala	/^classpath=""" + libs.map { case (jar, path) => "$scriptdir\/" + path }.mkString("\\"", ":", "\\"") + """$/;"	c
path	PlayDefaultUpstreamHandler.scala	/^          def path = nettyUri.getPath$/;"	m
path	Reads.scala	/^  val path: PathReads = this$/;"	V
path	RoutesCompiler.scala	/^    def path: Parser[PathPattern] = "\/" ~ ((positioned(singleComponentPathPart) | positioned(multipleComponentsPathPart) | positioned(regexComponentPathPart) | staticPathPart) *) ^^ {$/;"	m
path	Writes.scala	/^  val path: PathWrites = this$/;"	V
path	csrf.scala	/^          def path = request.path$/;"	m
pathList	ScalaTemplateCompiler.scala	/^            val pathList = List(compilerPath, libPath)$/;"	V
pathList	TemplateCompilerSpec.scala	/^        val pathList = List(compilerPath, libPath)$/;"	V
pathString	BindersSpec.scala	/^    val pathString = "\/path\/to\/some%20file"$/;"	V
pathStringBinded	BindersSpec.scala	/^    val pathStringBinded = "\/path\/to\/some file"$/;"	V
pathStringInvalid	BindersSpec.scala	/^    val pathStringInvalid = "\/path\/to\/invalide%2"$/;"	V
pattern	JsConstraints.scala	/^  def pattern(regex: => scala.util.matching.Regex, error: String = "error.pattern")(implicit reads:Reads[String]) = $/;"	m
pattern	Messages.scala	/^    val pattern: Option[String] =$/;"	V
pattern	Validation.scala	/^  def pattern(regex: => scala.util.matching.Regex, name: String = "constraint.pattern", error: String = "error.pattern"): Constraint[String] = Constraint[String](name, () => regex) { o =>$/;"	m
pick	JsPath.scala	/^    def pick: Reads[JsValue] = pick[JsValue]$/;"	m
pick	JsPath.scala	/^    def pick[A <: JsValue](implicit r: Reads[A]): Reads[A] = Reads.jsPick(self)$/;"	m
pickBranch	JsPath.scala	/^    def pickBranch: Reads[JsObject] = Reads.jsPickBranch[JsValue](self)$/;"	m
pickBranch	JsPath.scala	/^    def pickBranch[A <: JsValue](reads: Reads[A]): Reads[JsObject] = Reads.jsPickBranch[A](self)(reads)$/;"	m
pidFile	NettyServer.scala	/^      val pidFile = Option(System.getProperty("pidfile.path")).map(new File(_)).getOrElse(new File(applicationPath.getAbsolutePath, "RUNNING_PID"))$/;"	V
pipeline	WebSocketHandshake.scala	/^    val pipeline = ctx.getChannel().getPipeline()$/;"	V
plain	ScalaTemplateCompiler.scala	/^      def plain: Parser[Plain] = {$/;"	m
plainString	ScalaTemplateCompiler.scala	/^              val plainString = Plain(s)$/;"	V
play	Project.scala	/^package play$/;"	p
play.Project._	PlayProject.scala	/^import play.Project._$/;"	i
play.api	Application.scala	/^package play.api$/;"	p
play.api	Configuration.scala	/^package play.api$/;"	p
play.api	ConfigurationSpec.scala	/^package play.api$/;"	p
play.api	Exceptions.scala	/^package play.api$/;"	p
play.api	GlobalSettings.scala	/^package play.api$/;"	p
play.api	Logger.scala	/^package play.api$/;"	p
play.api	Play.scala	/^package play.api$/;"	p
play.api	Plugins.scala	/^package play.api$/;"	p
play.api	package.scala	/^package play.api$/;"	p
play.api.Application	ResultsSpec.scala	/^import play.api.Application$/;"	i
play.api.Play	Controller.scala	/^import play.api.Play$/;"	i
play.api.Play	Crypto.scala	/^import play.api.Play$/;"	i
play.api.Play.current	csrf.scala	/^      import play.api.Play.current$/;"	i
play.api.PlayException	Crypto.scala	/^import play.api.PlayException$/;"	i
play.api.PlayException	PlayAssetsCompiler.scala	/^import play.api.PlayException$/;"	i
play.api._	Action.scala	/^import play.api._$/;"	i
play.api._	Akka.scala	/^import play.api._$/;"	i
play.api._	ApplicationProvider.scala	/^import play.api._$/;"	i
play.api._	Assets.scala	/^import play.api._$/;"	i
play.api._	Cache.scala	/^import play.api._$/;"	i
play.api._	Cached.scala	/^import play.api._$/;"	i
play.api._	CoffeescriptCompiler.scala	/^import play.api._$/;"	i
play.api._	ContentTypeOf.scala	/^import play.api._$/;"	i
play.api._	ContentTypes.scala	/^import play.api._$/;"	i
play.api._	DB.scala	/^import play.api._$/;"	i
play.api._	Default.scala	/^import play.api._$/;"	i
play.api._	Evolutions.scala	/^    import play.api._$/;"	i
play.api._	Evolutions.scala	/^import play.api._$/;"	i
play.api._	ExternalAssets.scala	/^import play.api._$/;"	i
play.api._	Filters.scala	/^import play.api._$/;"	i
play.api._	Helpers.scala	/^import play.api._$/;"	i
play.api._	Http.scala	/^  import play.api._$/;"	i
play.api._	JNDI.scala	/^import play.api._$/;"	i
play.api._	JavaGlobalSettingsAdapter.scala	/^import play.api._$/;"	i
play.api._	JavascriptCompiler.scala	/^import play.api._$/;"	i
play.api._	LessCompiler.scala	/^import play.api._$/;"	i
play.api._	Messages.scala	/^import play.api._$/;"	i
play.api._	NettyServer.scala	/^import play.api._$/;"	i
play.api._	PlayCommands.scala	/^import play.api._$/;"	i
play.api._	PlayDefaultUpstreamHandler.scala	/^import play.api._$/;"	i
play.api._	PlayExceptions.scala	/^import play.api._$/;"	i
play.api._	PlayProject.scala	/^import play.api._$/;"	i
play.api._	PlayReloader.scala	/^import play.api._$/;"	i
play.api._	Project.scala	/^import play.api._$/;"	i
play.api._	Promise.scala	/^import play.api._$/;"	i
play.api._	RequestBodyHandler.scala	/^import play.api._$/;"	i
play.api._	Results.scala	/^  import play.api._$/;"	i
play.api._	ResultsSpec.scala	/^    import play.api._$/;"	i
play.api._	Security.scala	/^import play.api._$/;"	i
play.api._	Selenium.scala	/^import play.api._$/;"	i
play.api._	Server.scala	/^import play.api._$/;"	i
play.api._	WebSocketHandler.scala	/^import play.api._$/;"	i
play.api._	WebSocketHandshake.scala	/^import play.api._$/;"	i
play.api._	Writeable.scala	/^import play.api._$/;"	i
play.api._	csrf.scala	/^  import play.api._$/;"	i
play.api.cache	Cache.scala	/^package play.api.cache$/;"	p
play.api.cache	CacheSpec.scala	/^package play.api.cache$/;"	p
play.api.cache	Cached.scala	/^package play.api.cache$/;"	p
play.api.data	Form.scala	/^package play.api.data$/;"	p
play.api.data	Forms.scala	/^package play.api.data$/;"	p
play.api.data	ObjectMappings.scala	/^package play.api.data$/;"	p
play.api.data.Forms._	FormSpec.scala	/^    import play.api.data.Forms._$/;"	i
play.api.data.Forms._	FormSpec.scala	/^   import play.api.data.Forms._$/;"	i
play.api.data.Forms._	FormatSpec.scala	/^import play.api.data.Forms._$/;"	i
play.api.data.Forms._	ValidationSpec.scala	/^import play.api.data.Forms._$/;"	i
play.api.data._	FormSpec.scala	/^    import play.api.data._$/;"	i
play.api.data._	FormSpec.scala	/^   import play.api.data._$/;"	i
play.api.data._	FormatSpec.scala	/^import play.api.data._$/;"	i
play.api.data._	Validation.scala	/^import play.api.data._$/;"	i
play.api.data._	ValidationSpec.scala	/^import play.api.data._$/;"	i
play.api.data._	csrf.scala	/^  import play.api.data._$/;"	i
play.api.data.format	FormatSpec.scala	/^package play.api.data.format$/;"	p
play.api.data.format.Formats._	ValidationSpec.scala	/^import play.api.data.format.Formats._$/;"	i
play.api.data.format.Formats.jodaDateTimeFormat	FormSpec.scala	/^    import play.api.data.format.Formats.jodaDateTimeFormat$/;"	i
play.api.data.format.Formats.jodaLocalDateFormat	FormSpec.scala	/^    import play.api.data.format.Formats.jodaLocalDateFormat$/;"	i
play.api.data.format._	Forms.scala	/^import play.api.data.format._$/;"	i
play.api.data.validation	Validation.scala	/^package play.api.data.validation$/;"	p
play.api.data.validation	ValidationSpec.scala	/^package play.api.data.validation$/;"	p
play.api.data.validation.Constraints._	FormSpec.scala	/^   import play.api.data.validation.Constraints._$/;"	i
play.api.data.validation.Constraints._	ValidationSpec.scala	/^import play.api.data.validation.Constraints._$/;"	i
play.api.data.validation.ValidationError	JsConstraints.scala	/^import play.api.data.validation.ValidationError$/;"	i
play.api.data.validation.ValidationError	JsPath.scala	/^import play.api.data.validation.ValidationError$/;"	i
play.api.data.validation.ValidationError	JsPathSpec.scala	/^import play.api.data.validation.ValidationError$/;"	i
play.api.data.validation.ValidationError	JsResult.scala	/^import play.api.data.validation.ValidationError$/;"	i
play.api.data.validation.ValidationError	JsValue.scala	/^import play.api.data.validation.ValidationError$/;"	i
play.api.data.validation.ValidationError	JsonSpec.scala	/^import play.api.data.validation.ValidationError $/;"	i
play.api.data.validation.ValidationError	JsonTransSpec.scala	/^import play.api.data.validation.ValidationError$/;"	i
play.api.data.validation.ValidationError	JsonValidSpec.scala	/^import play.api.data.validation.ValidationError$/;"	i
play.api.data.validation.ValidationError	Reads.scala	/^import play.api.data.validation.ValidationError$/;"	i
play.api.data.validation._	Forms.scala	/^import play.api.data.validation._$/;"	i
play.api.db	DB.scala	/^package play.api.db$/;"	p
play.api.db._	Evolutions.scala	/^import play.api.db._$/;"	i
play.api.db.evolutions	Evolutions.scala	/^package play.api.db.evolutions$/;"	p
play.api.db.evolutions	ScriptSpec.scala	/^package play.api.db.evolutions$/;"	p
play.api.http	ContentTypeOf.scala	/^package play.api.http$/;"	p
play.api.http	MediaRange.scala	/^package play.api.http$/;"	p
play.api.http	MediaRangeSpec.scala	/^package play.api.http$/;"	p
play.api.http	StandardValues.scala	/^package play.api.http$/;"	p
play.api.http	Writeable.scala	/^package play.api.http$/;"	p
play.api.http.ContentTypes	Results.scala	/^  import play.api.http.ContentTypes$/;"	i
play.api.http.HeaderNames	DiscoverySpec.scala	/^import play.api.http.HeaderNames$/;"	i
play.api.http.HeaderNames	OpenID.scala	/^import play.api.http.HeaderNames$/;"	i
play.api.http.HeaderNames.X_FORWARDED_FOR	PlayDefaultUpstreamHandler.scala	/^import play.api.http.HeaderNames.X_FORWARDED_FOR$/;"	i
play.api.http.HeaderNames._	ContentTypeOf.scala	/^import play.api.http.HeaderNames._$/;"	i
play.api.http.HeaderNames._	Render.scala	/^import play.api.http.HeaderNames._$/;"	i
play.api.http.HeaderNames._	Results.scala	/^  import play.api.http.HeaderNames._$/;"	i
play.api.http.HeaderNames._	Results.scala	/^import play.api.http.HeaderNames._$/;"	i
play.api.http.HeaderNames._	Writeable.scala	/^import play.api.http.HeaderNames._$/;"	i
play.api.http.HeaderNames._	csrf.scala	/^        import play.api.http.HeaderNames._$/;"	i
play.api.http.MimeTypes	RequestExtractors.scala	/^    import play.api.http.MimeTypes$/;"	i
play.api.http.Status._	ContentTypeOf.scala	/^import play.api.http.Status._$/;"	i
play.api.http.Status._	DiscoverySpec.scala	/^import play.api.http.Status._$/;"	i
play.api.http.Status._	OpenIDSpec.scala	/^import play.api.http.Status._$/;"	i
play.api.http.Status._	Results.scala	/^  import play.api.http.Status._$/;"	i
play.api.http.Status._	Results.scala	/^import play.api.http.Status._$/;"	i
play.api.http.Status._	Writeable.scala	/^import play.api.http.Status._$/;"	i
play.api.http.Status._	WsMock.scala	/^import play.api.http.Status._$/;"	i
play.api.http._	Controller.scala	/^import play.api.http._$/;"	i
play.api.http._	Helpers.scala	/^import play.api.http._$/;"	i
play.api.http._	JavaResults.scala	/^import play.api.http._$/;"	i
play.api.http._	OpenIDSpec.scala	/^import play.api.http._$/;"	i
play.api.http._	Results.scala	/^import play.api.http._$/;"	i
play.api.http._	csrf.scala	/^          import play.api.http._$/;"	i
play.api.http.{ ContentTypeOf, ContentTypes, Writeable }	Jsonp.scala	/^import play.api.http.{ ContentTypeOf, ContentTypes, Writeable }$/;"	i
play.api.http.{ Writeable, ContentTypeOf }	WS.scala	/^import play.api.http.{ Writeable, ContentTypeOf }$/;"	i
play.api.http.{ContentTypeOf, Writeable, HeaderNames}	WsMock.scala	/^import play.api.http.{ContentTypeOf, Writeable, HeaderNames}$/;"	i
play.api.http.{MediaRange, HeaderNames}	Http.scala	/^  import play.api.http.{MediaRange, HeaderNames}$/;"	i
play.api.http.{Writeable, MediaRange}	Render.scala	/^import play.api.http.{Writeable, MediaRange}$/;"	i
play.api.i18n	Messages.scala	/^package play.api.i18n$/;"	p
play.api.i18n	MessagesSpec.scala	/^package play.api.i18n$/;"	p
play.api.i18n.Lang	Controller.scala	/^import play.api.i18n.Lang$/;"	i
play.api.i18n.Lang	Http.scala	/^  import play.api.i18n.Lang$/;"	i
play.api.i18n.Lang	Results.scala	/^import play.api.i18n.Lang$/;"	i
play.api.libs	Codecs.scala	/^package play.api.libs$/;"	p
play.api.libs	Collections.scala	/^package play.api.libs$/;"	p
play.api.libs	Comet.scala	/^package play.api.libs$/;"	p
play.api.libs	Crypto.scala	/^package play.api.libs$/;"	p
play.api.libs	CryptoSpec.scala	/^package play.api.libs$/;"	p
play.api.libs	EventSource.scala	/^package play.api.libs$/;"	p
play.api.libs	Files.scala	/^package play.api.libs$/;"	p
play.api.libs	JNDI.scala	/^package play.api.libs$/;"	p
play.api.libs	Jsonp.scala	/^package play.api.libs$/;"	p
play.api.libs	MimeTypes.scala	/^package play.api.libs$/;"	p
play.api.libs.Codecs._	Evolutions.scala	/^import play.api.libs.Codecs._$/;"	i
play.api.libs.Crypto	Http.scala	/^  import play.api.libs.Crypto$/;"	i
play.api.libs.Files._	ContentTypes.scala	/^  import play.api.libs.Files._$/;"	i
play.api.libs.Files._	csrf.scala	/^    import play.api.libs.Files._$/;"	i
play.api.libs.Files.{ TemporaryFile }	ContentTypes.scala	/^import play.api.libs.Files.{ TemporaryFile }$/;"	i
play.api.libs.Files.{ TemporaryFile }	JavaParsers.scala	/^import play.api.libs.Files.{ TemporaryFile }$/;"	i
play.api.libs._	Assets.scala	/^import play.api.libs._$/;"	i
play.api.libs._	CryptoSpec.scala	/^import play.api.libs._$/;"	i
play.api.libs._	DB.scala	/^import play.api.libs._$/;"	i
play.api.libs._	Default.scala	/^import play.api.libs._$/;"	i
play.api.libs._	Evolutions.scala	/^    import play.api.libs._$/;"	i
play.api.libs._	Evolutions.scala	/^import play.api.libs._$/;"	i
play.api.libs._	ExternalAssets.scala	/^import play.api.libs._$/;"	i
play.api.libs.concurrent	Akka.scala	/^package play.api.libs.concurrent$/;"	p
play.api.libs.concurrent	Promise.scala	/^package play.api.libs.concurrent$/;"	p
play.api.libs.concurrent.Execution.Implicits.defaultContext	Filters.scala	/^      import play.api.libs.concurrent.Execution.Implicits.defaultContext$/;"	i
play.api.libs.concurrent.Execution.Implicits.defaultContext	csrf.scala	/^  import play.api.libs.concurrent.Execution.Implicits.defaultContext$/;"	i
play.api.libs.concurrent.Promise	EnumeratorsSpec.scala	/^      import play.api.libs.concurrent.Promise$/;"	i
play.api.libs.concurrent.Promise	Fakes.scala	/^import play.api.libs.concurrent.Promise$/;"	i
play.api.libs.concurrent.Promise	WsMock.scala	/^import play.api.libs.concurrent.Promise$/;"	i
play.api.libs.concurrent.PurePromise	OpenID.scala	/^import play.api.libs.concurrent.PurePromise$/;"	i
play.api.libs.concurrent._	Action.scala	/^import play.api.libs.concurrent._$/;"	i
play.api.libs.concurrent._	Akka.scala	/^import play.api.libs.concurrent._$/;"	i
play.api.libs.concurrent._	Filters.scala	/^import play.api.libs.concurrent._$/;"	i
play.api.libs.concurrent._	Helpers.scala	/^import play.api.libs.concurrent._$/;"	i
play.api.libs.concurrent._	JavaPromise.scala	/^import play.api.libs.concurrent._$/;"	i
play.api.libs.concurrent._	JavaResults.scala	/^import play.api.libs.concurrent._$/;"	i
play.api.libs.concurrent._	NettyPromise.scala	/^import play.api.libs.concurrent._$/;"	i
play.api.libs.concurrent._	PlayDefaultUpstreamHandler.scala	/^import play.api.libs.concurrent._$/;"	i
play.api.libs.concurrent._	PromiseSpec.scala	/^import play.api.libs.concurrent._$/;"	i
play.api.libs.concurrent._	RequestBodyHandler.scala	/^import play.api.libs.concurrent._$/;"	i
play.api.libs.concurrent._	Results.scala	/^import play.api.libs.concurrent._$/;"	i
play.api.libs.concurrent._	Server.scala	/^import play.api.libs.concurrent._$/;"	i
play.api.libs.concurrent._	WebSocket.scala	/^import play.api.libs.concurrent._$/;"	i
play.api.libs.concurrent._	WebSocketHandler.scala	/^import play.api.libs.concurrent._$/;"	i
play.api.libs.concurrent._	WebSocketHandshake.scala	/^import play.api.libs.concurrent._$/;"	i
play.api.libs.functional._	Format.scala	/^  import play.api.libs.functional._$/;"	i
play.api.libs.functional._	JsResult.scala	/^  import play.api.libs.functional._$/;"	i
play.api.libs.functional._	Reads.scala	/^  import play.api.libs.functional._$/;"	i
play.api.libs.functional._	Writes.scala	/^  import play.api.libs.functional._$/;"	i
play.api.libs.functional.syntax._	JsonExtensionSpec.scala	/^      import play.api.libs.functional.syntax._$/;"	i
play.api.libs.functional.syntax._	JsonSpec.scala	/^import play.api.libs.functional.syntax._$/;"	i
play.api.libs.functional.syntax._	JsonValidSpec.scala	/^import play.api.libs.functional.syntax._$/;"	i
play.api.libs.iteratee	Concurrent.scala	/^package play.api.libs.iteratee$/;"	p
play.api.libs.iteratee	ConcurrentSpec.scala	/^package play.api.libs.iteratee$/;"	p
play.api.libs.iteratee	Enumeratee.scala	/^package play.api.libs.iteratee$/;"	p
play.api.libs.iteratee	EnumerateesSpec.scala	/^package play.api.libs.iteratee$/;"	p
play.api.libs.iteratee	Enumerator.scala	/^package play.api.libs.iteratee$/;"	p
play.api.libs.iteratee	EnumeratorsSpec.scala	/^package play.api.libs.iteratee$/;"	p
play.api.libs.iteratee	Iteratee.scala	/^package play.api.libs.iteratee$/;"	p
play.api.libs.iteratee	ParsingSpec.scala	/^package play.api.libs.iteratee$/;"	p
play.api.libs.iteratee	TraversableIteratee.scala	/^package play.api.libs.iteratee$/;"	p
play.api.libs.iteratee.Enumeratee	Json.scala	/^  import play.api.libs.iteratee.Enumeratee$/;"	i
play.api.libs.iteratee.Enumeratee.CheckDone	Concurrent.scala	/^    import play.api.libs.iteratee.Enumeratee.CheckDone$/;"	i
play.api.libs.iteratee.Input._	ContentTypes.scala	/^import play.api.libs.iteratee.Input._$/;"	i
play.api.libs.iteratee.Input._	PlayDefaultUpstreamHandler.scala	/^import play.api.libs.iteratee.Input._$/;"	i
play.api.libs.iteratee.Input._	RequestBodyHandler.scala	/^import play.api.libs.iteratee.Input._$/;"	i
play.api.libs.iteratee.Input._	Server.scala	/^import play.api.libs.iteratee.Input._$/;"	i
play.api.libs.iteratee.Input._	WS.scala	/^import play.api.libs.iteratee.Input._$/;"	i
play.api.libs.iteratee.Input._	WebSocketHandler.scala	/^import play.api.libs.iteratee.Input._$/;"	i
play.api.libs.iteratee.Parsing._	ContentTypes.scala	/^import play.api.libs.iteratee.Parsing._$/;"	i
play.api.libs.iteratee._	Action.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	Assets.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	Comet.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	ContentTypes.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	EventSource.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	ExternalAssets.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	Filters.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	Helpers.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	Http.scala	/^  import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	JavaResults.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	JavaWebSocket.scala	/^      import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	PlayDefaultUpstreamHandler.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	RequestBodyHandler.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	Results.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	Security.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	Server.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	WS.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	WebSocket.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	WebSocketHandler.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	WebSocketHandshake.scala	/^import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee._	csrf.scala	/^    import play.api.libs.iteratee._$/;"	i
play.api.libs.iteratee.internal.defaultExecutionContext	Concurrent.scala	/^import play.api.libs.iteratee.internal.defaultExecutionContext$/;"	i
play.api.libs.iteratee.internal.defaultExecutionContext	Enumeratee.scala	/^import play.api.libs.iteratee.internal.defaultExecutionContext$/;"	i
play.api.libs.iteratee.internal.defaultExecutionContext	Enumerator.scala	/^import play.api.libs.iteratee.internal.defaultExecutionContext$/;"	i
play.api.libs.json	Format.scala	/^package play.api.libs.json$/;"	p
play.api.libs.json	JsConstraints.scala	/^package play.api.libs.json$/;"	p
play.api.libs.json	JsMacroImpl.scala	/^package play.api.libs.json$/;"	p
play.api.libs.json	JsPath.scala	/^package play.api.libs.json$/;"	p
play.api.libs.json	JsPathSpec.scala	/^package play.api.libs.json$/;"	p
play.api.libs.json	JsResult.scala	/^package play.api.libs.json$/;"	p
play.api.libs.json	JsValue.scala	/^package play.api.libs.json$/;"	p
play.api.libs.json	Json.scala	/^package play.api.libs.json$/;"	p
play.api.libs.json	JsonExtensionSpec.scala	/^package play.api.libs.json$/;"	p
play.api.libs.json	JsonRichSpec.scala	/^package play.api.libs.json$/;"	p
play.api.libs.json	JsonSpec.scala	/^package play.api.libs.json$/;"	p
play.api.libs.json	JsonTransSpec.scala	/^package play.api.libs.json$/;"	p
play.api.libs.json	JsonValidSpec.scala	/^package play.api.libs.json$/;"	p
play.api.libs.json	Reads.scala	/^package play.api.libs.json$/;"	p
play.api.libs.json	Writes.scala	/^package play.api.libs.json$/;"	p
play.api.libs.json.JsValue	Fakes.scala	/^import play.api.libs.json.JsValue$/;"	i
play.api.libs.json.JsValue	Jsonp.scala	/^import play.api.libs.json.JsValue$/;"	i
play.api.libs.json.Json	JsonExtensionSpec.scala	/^      import play.api.libs.json.Json$/;"	i
play.api.libs.json.Json._	JsPathSpec.scala	/^import play.api.libs.json.Json._$/;"	i
play.api.libs.json.Json._	JsonExtensionSpec.scala	/^import play.api.libs.json.Json._$/;"	i
play.api.libs.json.Json._	JsonRichSpec.scala	/^import play.api.libs.json.Json._$/;"	i
play.api.libs.json.Json._	JsonSpec.scala	/^import play.api.libs.json.Json._$/;"	i
play.api.libs.json.Json._	JsonTransSpec.scala	/^import play.api.libs.json.Json._$/;"	i
play.api.libs.json.Json._	JsonValidSpec.scala	/^import play.api.libs.json.Json._$/;"	i
play.api.libs.json._	ContentTypeOf.scala	/^import play.api.libs.json._$/;"	i
play.api.libs.json._	ContentTypes.scala	/^import play.api.libs.json._$/;"	i
play.api.libs.json._	Form.scala	/^    import play.api.libs.json._$/;"	i
play.api.libs.json._	Form.scala	/^  import play.api.libs.json._$/;"	i
play.api.libs.json._	JavaParsers.scala	/^import play.api.libs.json._$/;"	i
play.api.libs.json._	JsPathSpec.scala	/^import play.api.libs.json._$/;"	i
play.api.libs.json._	JsonExtensionSpec.scala	/^import play.api.libs.json._$/;"	i
play.api.libs.json._	JsonRichSpec.scala	/^import play.api.libs.json._$/;"	i
play.api.libs.json._	JsonSpec.scala	/^import play.api.libs.json._$/;"	i
play.api.libs.json._	JsonTransSpec.scala	/^import play.api.libs.json._$/;"	i
play.api.libs.json._	JsonValidSpec.scala	/^import play.api.libs.json._$/;"	i
play.api.libs.json._	Results.scala	/^  import play.api.libs.json._$/;"	i
play.api.libs.json._	Results.scala	/^import play.api.libs.json._$/;"	i
play.api.libs.json._	WS.scala	/^  import play.api.libs.json._$/;"	i
play.api.libs.json._	WebSocket.scala	/^import play.api.libs.json._$/;"	i
play.api.libs.json._	Writeable.scala	/^import play.api.libs.json._$/;"	i
play.api.libs.json.util	Util.scala	/^package play.api.libs.json.util$/;"	p
play.api.libs.json.util._	JsonTransSpec.scala	/^import play.api.libs.json.util._$/;"	i
play.api.libs.oauth	OAuth.scala	/^package play.api.libs.oauth$/;"	p
play.api.libs.openid	DiscoverySpec.scala	/^package play.api.libs.openid$/;"	p
play.api.libs.openid	OpenID.scala	/^package play.api.libs.openid$/;"	p
play.api.libs.openid	OpenIDError.scala	/^package play.api.libs.openid$/;"	p
play.api.libs.openid	OpenIDSpec.scala	/^package play.api.libs.openid$/;"	p
play.api.libs.openid	RichUrl.scala	/^package play.api.libs.openid$/;"	p
play.api.libs.openid	UserInfoSpec.scala	/^package play.api.libs.openid$/;"	p
play.api.libs.openid	WsMock.scala	/^package play.api.libs.openid$/;"	p
play.api.libs.openid.Errors.{BAD_RESPONSE, AUTH_ERROR}	OpenIDSpec.scala	/^import play.api.libs.openid.Errors.{BAD_RESPONSE, AUTH_ERROR}$/;"	i
play.api.libs.ws	WS.scala	/^package play.api.libs.ws$/;"	p
play.api.libs.ws.Response	DiscoverySpec.scala	/^import play.api.libs.ws.Response$/;"	i
play.api.libs.ws.Response	WsMock.scala	/^import play.api.libs.ws.Response$/;"	i
play.api.libs.ws.WS	WSSpec.scala	/^import play.api.libs.ws.WS$/;"	i
play.api.libs.ws.WS.WSRequest	OAuth.scala	/^import play.api.libs.ws.WS.WSRequest$/;"	i
play.api.libs.ws.WS.WSRequestHolder	OpenID.scala	/^import play.api.libs.ws.WS.WSRequestHolder$/;"	i
play.api.libs.ws.WS.WSRequestHolder	WsMock.scala	/^import play.api.libs.ws.WS.WSRequestHolder$/;"	i
play.api.libs.ws._	OAuth.scala	/^import play.api.libs.ws._$/;"	i
play.api.libs.ws._	OpenID.scala	/^import play.api.libs.ws._$/;"	i
play.api.mvc	Action.scala	/^package play.api.mvc$/;"	p
play.api.mvc	Binders.scala	/^package play.api.mvc$/;"	p
play.api.mvc	BindersSpec.scala	/^package play.api.mvc$/;"	p
play.api.mvc	Content.scala	/^package play.api.mvc$/;"	p
play.api.mvc	ContentTypes.scala	/^package play.api.mvc$/;"	p
play.api.mvc	Controller.scala	/^package play.api.mvc$/;"	p
play.api.mvc	Filters.scala	/^package play.api.mvc$/;"	p
play.api.mvc	Render.scala	/^package play.api.mvc$/;"	p
play.api.mvc	RequestExtractors.scala	/^package play.api.mvc$/;"	p
play.api.mvc	Results.scala	/^package play.api.mvc$/;"	p
play.api.mvc	ResultsSpec.scala	/^package play.api.mvc$/;"	p
play.api.mvc	Security.scala	/^package play.api.mvc$/;"	p
play.api.mvc	WebSocket.scala	/^package play.api.mvc$/;"	p
play.api.mvc.Codec	Jsonp.scala	/^import play.api.mvc.Codec$/;"	i
play.api.mvc.Codec	StandardValues.scala	/^  import play.api.mvc.Codec$/;"	i
play.api.mvc.Request	OpenID.scala	/^import play.api.mvc.Request$/;"	i
play.api.mvc.Request	OpenIDSpec.scala	/^import play.api.mvc.Request$/;"	i
play.api.mvc.RequestHeader	Routes.scala	/^    import play.api.mvc.RequestHeader$/;"	i
play.api.mvc.Results._	ApplicationProvider.scala	/^    import play.api.mvc.Results._$/;"	i
play.api.mvc.Results._	Render.scala	/^import play.api.mvc.Results._$/;"	i
play.api.mvc.Results._	ResultsSpec.scala	/^  import play.api.mvc.Results._$/;"	i
play.api.mvc.Results._	Router.scala	/^import play.api.mvc.Results._$/;"	i
play.api.mvc.Results._	Security.scala	/^import play.api.mvc.Results._$/;"	i
play.api.mvc._	Application.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	ApplicationProvider.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	Assets.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	Binders.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	Cached.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	Comet.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	ContentTypeOf.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	Default.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	EventSource.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	ExternalAssets.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	Fakes.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	GlobalSettings.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	Helpers.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	JavaAction.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	JavaGlobalSettingsAdapter.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	JavaHelpers.scala	/^  import play.api.mvc._$/;"	i
play.api.mvc._	JavaHelpers.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	JavaParsers.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	JavaResults.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	JavaWebSocket.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	Play.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	PlayDefaultUpstreamHandler.scala	/^                    import play.api.mvc._$/;"	i
play.api.mvc._	PlayDefaultUpstreamHandler.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	Plugins.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	RequestBodyHandler.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	Router.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	Server.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	TemplateMagicForJava.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	Templates.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	WebSocketHandler.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	WebSocketHandshake.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	Writeable.scala	/^import play.api.mvc._$/;"	i
play.api.mvc._	csrf.scala	/^    import play.api.mvc._$/;"	i
play.api.mvc._	csrf.scala	/^  import play.api.mvc._$/;"	i
play.api.templates	Templates.scala	/^package play.api.templates$/;"	p
play.api.templates	TemplatesSpec.scala	/^package play.api.templates$/;"	p
play.api.templates._	Comet.scala	/^import play.api.templates._$/;"	i
play.api.templates._	ContentTypeOf.scala	/^import play.api.templates._$/;"	i
play.api.templates._	EventSource.scala	/^import play.api.templates._$/;"	i
play.api.templates._	Results.scala	/^  import play.api.templates._$/;"	i
play.api.templates._	Writeable.scala	/^import play.api.templates._$/;"	i
play.api.test	Fakes.scala	/^package play.api.test$/;"	p
play.api.test	Helpers.scala	/^package play.api.test$/;"	p
play.api.test	HelpersSpec.scala	/^package play.api.test$/;"	p
play.api.test	Selenium.scala	/^package play.api.test$/;"	p
play.api.test	Specs.scala	/^package play.api.test$/;"	p
play.api.test	SpecsSpec.scala	/^package play.api.test$/;"	p
play.api.test.Helpers._	HelpersSpec.scala	/^import play.api.test.Helpers._$/;"	i
play.api.test._	HelpersSpec.scala	/^import play.api.test._$/;"	i
play.api.{Application, Play}	Results.scala	/^import play.api.{Application, Play}$/;"	i
play.api.{Application, WithDefaultConfiguration, WithDefaultGlobal, WithDefaultPlugins}	Fakes.scala	/^import  play.api.{Application, WithDefaultConfiguration, WithDefaultGlobal, WithDefaultPlugins}$/;"	i
play.api.{Logger, Application}	FakeKeyStore.scala	/^import play.api.{Logger, Application}$/;"	i
play.api.{Logger, Play}	Invoker.scala	/^import play.api.{Logger, Play}$/;"	i
play.api.{Play, Application}	SpecsSpec.scala	/^import play.api.{Play, Application}$/;"	i
play.concurrent	PromiseSpec.scala	/^package play.concurrent$/;"	p
play.console	Console.scala	/^package play.console$/;"	p
play.console.Colors	JUnitXmlTestListener.scala	/^import play.console.Colors$/;"	i
play.console.Colors	PlayCommands.scala	/^import play.console.Colors$/;"	i
play.console.Colors	PlayProject.scala	/^import play.console.Colors$/;"	i
play.console.Colors	Project.scala	/^import play.console.Colors$/;"	i
play.core	ApplicationProvider.scala	/^package play.core$/;"	p
play.core	Execution.scala	/^package play.core$/;"	p
play.core	Invoker.scala	/^package play.core$/;"	p
play.core	NamedThreadFactory.scala	/^package play.core$/;"	p
play.core	Router.scala	/^package play.core$/;"	p
play.core.Execution.internalContext	JavaPromise.scala	/^import play.core.Execution.internalContext$/;"	i
play.core.Execution.internalContext	OpenID.scala	/^import play.core.Execution.internalContext$/;"	i
play.core.Execution.internalContext	Promise.scala	/^import play.core.Execution.internalContext$/;"	i
play.core.Execution.internalContext	Results.scala	/^import play.core.Execution.internalContext$/;"	i
play.core.Execution.internalContext	WebSocket.scala	/^import play.core.Execution.internalContext$/;"	i
play.core.Router	RouterSpec.scala	/^import play.core.Router$/;"	i
play.core.Router._	Routes.scala	/^    import play.core.Router._$/;"	i
play.core._	Application.scala	/^import play.core._$/;"	i
play.core._	DB.scala	/^import play.core._$/;"	i
play.core._	Evolutions.scala	/^import play.core._$/;"	i
play.core._	Messages.scala	/^import play.core._$/;"	i
play.core._	NettyServer.scala	/^import play.core._$/;"	i
play.core._	Play.scala	/^import play.core._$/;"	i
play.core._	PlayCommands.scala	/^import play.core._$/;"	i
play.core._	PlayDefaultUpstreamHandler.scala	/^import play.core._$/;"	i
play.core._	PlayExceptions.scala	/^import play.core._$/;"	i
play.core._	PlayProject.scala	/^import play.core._$/;"	i
play.core._	PlayReloader.scala	/^import play.core._$/;"	i
play.core._	Project.scala	/^import play.core._$/;"	i
play.core._	Promise.scala	/^import play.core._$/;"	i
play.core._	RequestBodyHandler.scala	/^import play.core._$/;"	i
play.core._	Results.scala	/^import play.core._$/;"	i
play.core._	Server.scala	/^import play.core._$/;"	i
play.core._	WebSocketHandler.scala	/^import play.core._$/;"	i
play.core._	WebSocketHandshake.scala	/^import play.core._$/;"	i
play.core.coffeescript	CoffeescriptCompiler.scala	/^package play.core.coffeescript$/;"	p
play.core.j	JavaAction.scala	/^package play.core.j$/;"	p
play.core.j	JavaGlobalSettingsAdapter.scala	/^package play.core.j$/;"	p
play.core.j	JavaHelpers.scala	/^package play.core.j$/;"	p
play.core.j	JavaParsers.scala	/^package play.core.j$/;"	p
play.core.j	JavaPromise.scala	/^package play.core.j$/;"	p
play.core.j	JavaResults.scala	/^package play.core.j$/;"	p
play.core.j	JavaWebSocket.scala	/^package play.core.j$/;"	p
play.core.j	TemplateMagicForJava.scala	/^package play.core.j$/;"	p
play.core.j.PlayMagicForJava._	DynamicFormSpec.scala	/^import play.core.j.PlayMagicForJava._$/;"	i
play.core.jscompile	JavascriptCompiler.scala	/^package play.core.jscompile$/;"	p
play.core.less	LessCompiler.scala	/^package play.core.less$/;"	p
play.core.parsers	FormUrlEncodedParser.scala	/^package play.core.parsers$/;"	p
play.core.parsers._	ContentTypes.scala	/^      import play.core.parsers._$/;"	i
play.core.router	RouterSpec.scala	/^package play.core.router$/;"	p
play.core.server	NettyServer.scala	/^package play.core.server$/;"	p
play.core.server	Server.scala	/^package play.core.server$/;"	p
play.core.server.netty	FakeKeyStore.scala	/^package play.core.server.netty$/;"	p
play.core.server.netty	NettyPromise.scala	/^package play.core.server.netty$/;"	p
play.core.server.netty	PlayDefaultUpstreamHandler.scala	/^package play.core.server.netty$/;"	p
play.core.server.netty	RequestBodyHandler.scala	/^package play.core.server.netty$/;"	p
play.core.server.netty	WebSocketHandler.scala	/^package play.core.server.netty$/;"	p
play.core.server.netty._	NettyServer.scala	/^import play.core.server.netty._$/;"	i
play.core.server.websocket	Frame.scala	/^package play.core.server.websocket$/;"	p
play.core.server.websocket	WebSocketHandshake.scala	/^package play.core.server.websocket$/;"	p
play.core.server.websocket.WebSocketHandshake	WebSocketHandler.scala	/^import play.core.server.websocket.WebSocketHandshake$/;"	i
play.core.utils	CaseInstensitiveOrdered.scala	/^package play.core.utils$/;"	p
play.core.utils	ThreadsSpec.scala	/^package play.core.utils$/;"	p
play.core.utils.CaseInsensitiveOrdered	Fakes.scala	/^import play.core.utils.CaseInsensitiveOrdered$/;"	i
play.core.utils.CaseInsensitiveOrdered	Http.scala	/^      import play.core.utils.CaseInsensitiveOrdered$/;"	i
play.core.utils.CaseInsensitiveOrdered	WS.scala	/^import play.core.utils.CaseInsensitiveOrdered$/;"	i
play.data	DynamicFormSpec.scala	/^package play.data$/;"	p
play.data	FormSpec.scala	/^package play.data$/;"	p
play.data	PartialValidationSpec.scala	/^package play.data$/;"	p
play.data._	FormSpec.scala	/^    import play.data._$/;"	i
play.data.models	Task.scala	/^package play.data.models$/;"	p
play.data.{ Form => JForm }	FormSpec.scala	/^import play.data.{ Form => JForm }$/;"	i
play.libs	ReflectionsCache.scala	/^package play.libs$/;"	p
play.libs.F	JavaPromise.scala	/^import play.libs.F$/;"	i
play.mvc.Http.Context	FormSpec.scala	/^import play.mvc.Http.Context$/;"	i
play.mvc.Http.RequestBody	JavaHelpers.scala	/^  import play.mvc.Http.RequestBody$/;"	i
play.mvc.Http.{ Context => JContext, Request => JRequest, RequestBody => JBody, Cookies => JCookies, Cookie => JCookie }	JavaAction.scala	/^import play.mvc.Http.{ Context => JContext, Request => JRequest, RequestBody => JBody, Cookies => JCookies, Cookie => JCookie }$/;"	i
play.mvc.Http.{ Context => JContext, Request => JRequest, RequestBody => JBody, Cookies => JCookies, Cookie => JCookie }	JavaHelpers.scala	/^import play.mvc.Http.{ Context => JContext, Request => JRequest, RequestBody => JBody, Cookies => JCookies, Cookie => JCookie }$/;"	i
play.mvc.Http.{ Context => JContext, Request => JRequest, RequestBody => JBody, Cookies => JCookies, Cookie => JCookie }	JavaWebSocket.scala	/^import play.mvc.Http.{ Context => JContext, Request => JRequest, RequestBody => JBody, Cookies => JCookies, Cookie => JCookie }$/;"	i
play.mvc.Http.{ Cookies => JCookies, Cookie => JCookie, Session => JSession, Flash => JFlash }	JavaResults.scala	/^import play.mvc.Http.{ Cookies => JCookies, Cookie => JCookie, Session => JSession, Flash => JFlash }$/;"	i
play.mvc.Http.{ RequestBody }	JavaParsers.scala	/^  import play.mvc.Http.{ RequestBody }$/;"	i
play.mvc.Http.{ RequestHeader => JRequestHeader }	JavaGlobalSettingsAdapter.scala	/^import play.mvc.Http.{ RequestHeader => JRequestHeader }$/;"	i
play.mvc._	FormSpec.scala	/^import play.mvc._$/;"	i
play.mvc.{ Action => JAction, Result => JResult }	JavaAction.scala	/^import play.mvc.{ Action => JAction, Result => JResult }$/;"	i
play.mvc.{ Action => JAction, Result => JResult }	JavaHelpers.scala	/^import play.mvc.{ Action => JAction, Result => JResult }$/;"	i
play.mvc.{ Action => JAction, Result => JResult }	JavaWebSocket.scala	/^import play.mvc.{ Action => JAction, Result => JResult }$/;"	i
play.router	PathParts.scala	/^package play.router$/;"	p
play.router	RoutesCompiler.scala	/^package play.router$/;"	p
play.router	RoutesCompilerSpec.scala	/^package play.router$/;"	p
play.router.RoutesCompiler._	PlayCommands.scala	/^    import play.router.RoutesCompiler._$/;"	i
play.router.RoutesCompiler._	RoutesCompilerSpec.scala	/^import play.router.RoutesCompiler._$/;"	i
play.router.RoutesCompiler.{MaybeGeneratedSource => RoutesSource}	PlayLogger.scala	/^  import play.router.RoutesCompiler.{MaybeGeneratedSource => RoutesSource}$/;"	i
play.templates.TemplateMagic._	ScalaTemplateCompiler.scala	/^import play.templates.TemplateMagic._$/;"	i
play.templates._	PlayCommands.scala	/^    import play.templates._$/;"	i
play.templates._	ScalaTemplateCompiler.scala	/^import play.templates._$/;"	i
play.templates._	TemplateCompilerSpec.scala	/^import play.templates._$/;"	i
play.templates._	TemplateMagicForJava.scala	/^import play.templates._$/;"	i
play.templates._	TemplateParserSpec.scala	/^import play.templates._$/;"	i
play.templates._	TemplateUtilsSpec.scala	/^import play.templates._$/;"	i
play.templates._	Templates.scala	/^import play.templates._$/;"	i
play.templates.test	TemplateCompilerSpec.scala	/^package play.templates.test$/;"	p
play.templates.test	TemplateParserSpec.scala	/^package play.templates.test$/;"	p
play.templates.test	TemplateUtilsSpec.scala	/^package play.templates.test$/;"	p
play.templates.{MaybeGeneratedSource => TemplateSource}	PlayLogger.scala	/^  import play.templates.{MaybeGeneratedSource => TemplateSource}$/;"	i
play.utils	Color.scala	/^package play.utils$/;"	p
play.utils	Conversions.scala	/^package play.utils$/;"	p
play.utils	ProxyDriver.scala	/^package play.utils$/;"	p
play.utils	Threads.scala	/^package play.utils$/;"	p
play.utils.Colors	Logger.scala	/^    import play.utils.Colors$/;"	i
play.utils.Threads	ThreadsSpec.scala	/^import play.utils.Threads$/;"	i
play.utils._	Application.scala	/^import play.utils._$/;"	i
play.utils.{ Threads }	Play.scala	/^import play.utils.{ Threads }$/;"	i
play.ws	WSSpec.scala	/^package play.ws$/;"	p
playAssetsDirectories	PlayKeys.scala	/^  val playAssetsDirectories = SettingKey[Seq[File]]("play-assets-directories")$/;"	V
playCommand	PlayCommands.scala	/^  val playCommand = Command.command("play", Help("play", ("play", "Enter the play console"), "Welcome to Play " + play.core.PlayVersion.current + """!$/;"	V
playCommonClassloader	PlayCommands.scala	/^  val playCommonClassloader = TaskKey[ClassLoader]("play-common-classloader")$/;"	V
playCommonClassloaderTask	PlayCommands.scala	/^  val playCommonClassloaderTask = (dependencyClasspath in Compile) map { classpath =>$/;"	V
playCompileEverything	PlayCommands.scala	/^  val playCompileEverything = TaskKey[Seq[sbt.inc.Analysis]]("play-compile-everything")$/;"	V
playCompileEverythingTask	PlayCommands.scala	/^  val playCompileEverythingTask = (state, thisProjectRef) flatMap { (s, r) =>$/;"	V
playConfig	WS.scala	/^      val playConfig = play.api.Play.maybeApplication.map(_.configuration)$/;"	V
playCopyAssets	PlayCommands.scala	/^  val playCopyAssets = TaskKey[Seq[(File, File)]]("play-copy-assets")$/;"	V
playCopyAssetsTask	PlayCommands.scala	/^  val playCopyAssetsTask = (baseDirectory, managedResources in Compile, resourceManaged in Compile, playAssetsDirectories, playExternalAssets, classDirectory in Compile, cacheDirectory, streams, state) map { (b, resources, resourcesDirectories, r, externals, t, c, s, state) =>$/;"	V
playDefaultPort	PlayKeys.scala	/^  val playDefaultPort = SettingKey[Int]("play-default-port")$/;"	V
playExternalAssets	PlayKeys.scala	/^  val playExternalAssets = SettingKey[Seq[(File, File => PathFinder, String)]]("play-external-assets")$/;"	V
playMonitoredFiles	PlayCommands.scala	/^  val playMonitoredFiles = TaskKey[Seq[String]]("play-monitored-files")$/;"	V
playMonitoredFilesTask	PlayCommands.scala	/^  val playMonitoredFilesTask = (thisProjectRef, state) map { (ref, state) =>$/;"	V
playOnStarted	PlayKeys.scala	/^  val playOnStarted = SettingKey[Seq[(java.net.InetSocketAddress) => Unit]]("play-onStarted")$/;"	V
playOnStopped	PlayKeys.scala	/^  val playOnStopped = SettingKey[Seq[() => Unit]]("play-onStopped")$/;"	V
playPackageEverything	PlayCommands.scala	/^  val playPackageEverything = TaskKey[Seq[File]]("play-package-everything")$/;"	V
playPackageEverythingTask	PlayCommands.scala	/^  val playPackageEverythingTask = (state, thisProjectRef, distExcludes).flatMap { (state, project, excludes) =>$/;"	V
playPlugin	PlayKeys.scala	/^  val playPlugin = SettingKey[Boolean]("play-plugin")$/;"	V
playPositionMapper	PlayLogger.scala	/^class PlaySourcePositionFilter(val playPositionMapper: Position => Option[Position]) {$/;"	V
playPositionMapper	PlayPositionMapper.scala	/^  val playPositionMapper = playPositionMappers.reduceLeft { (m1, m2) =>$/;"	V
playPositionMappers	PlayPositionMapper.scala	/^  val playPositionMappers = Seq(templatePositionMapper, routesPositionMapper)$/;"	V
playPrompt	PlayCommands.scala	/^  val playPrompt = { state: State =>$/;"	V
playReload	PlayCommands.scala	/^  val playReload = TaskKey[sbt.inc.Analysis]("play-reload")$/;"	V
playReloadTask	PlayCommands.scala	/^  val playReloadTask = (playCopyAssets, playCompileEverything) map { (_, analysises) =>$/;"	V
playRunCommand	PlayCommands.scala	/^  val playRunCommand = Command.args("run", "<args>") { (state: State, args: Seq[String]) =>$/;"	V
playSession	ResultsSpec.scala	/^      val playSession = Session.decodeFromCookie(setCookies.get(Session.COOKIE_NAME))$/;"	V
playSettings	PlayProject.scala	/^    lazy val playSettings =$/;"	V
playSettings	Project.scala	/^    lazy val playSettings =$/;"	V
playStage	PlayCommands.scala	/^  val playStage = TaskKey[Unit]("stage")$/;"	V
playStageTask	PlayCommands.scala	/^  val playStageTask = (baseDirectory, playPackageEverything, dependencyClasspath in Runtime, target, streams) map { (root, packaged, dependencies, target, s) =>$/;"	V
playStartCommand	PlayCommands.scala	/^  val playStartCommand = Command.args("start", "<port>") { (state: State, args: Seq[String]) =>$/;"	V
playVersion	PlayKeys.scala	/^  val playVersion = SettingKey[String]("play-version")$/;"	V
plugin	Application.scala	/^            val plugin = classloader.loadClass(className).getConstructor(classOf[play.Application]).newInstance(new play.Application(this)).asInstanceOf[Plugin]$/;"	V
plugin	Application.scala	/^        val plugin = classloader.loadClass(className).getConstructor(classOf[Application]).newInstance(this).asInstanceOf[Plugin]$/;"	V
plugin	Application.scala	/^  def plugin[T](implicit ct: ClassTag[T]): Option[T] = plugin(ct.runtimeClass).asInstanceOf[Option[T]]$/;"	m
plugin	Application.scala	/^  def plugin[T](pluginClass: Class[T]): Option[T] =$/;"	m
pluginFiles	Application.scala	/^    val pluginFiles = self.classloader.getResources("play.plugins").asScala.toList ++ self.classloader.getResources("conf\/play.plugins").asScala.toList$/;"	V
plugins	Application.scala	/^  def plugins: Seq[Plugin]$/;"	m
plugins	Application.scala	/^  lazy val plugins: Seq[Plugin] = Threads.withContextClassLoader(classloader) {$/;"	V
pointer	PlayLogger.scala	/^      def pointer() = Maybe.just(spaces.length + 1)$/;"	m
pointer	PlayPositionMapper.scala	/^          lazy val pointer = {$/;"	V
pointer	PlayPositionMapper.scala	/^          val pointer = xsbti.Maybe.nothing[java.lang.Integer]$/;"	V
pointer	PlayReloader.scala	/^                  def pointer = maybePosition.map(pos => xsbti.Maybe.just((pos - 1).asInstanceOf[java.lang.Integer])).getOrElse(xsbti.Maybe.nothing[java.lang.Integer])$/;"	m
pointerSpace	PlayLogger.scala	/^      def pointerSpace() = Maybe.just(spaces)$/;"	m
pointerSpace	PlayPositionMapper.scala	/^          lazy val pointerSpace = {$/;"	V
pointerSpace	PlayPositionMapper.scala	/^          val pointerSpace = xsbti.Maybe.nothing[String]$/;"	V
pointerSpace	PlayReloader.scala	/^                  def pointerSpace = xsbti.Maybe.nothing[String]$/;"	m
poolSize	Configuration.scala	/^   * val poolSize = configuration.getInt("engine.pool.size")$/;"	V
population	Configuration.scala	/^   * val population = configuration.getDouble("world.population")$/;"	V
port	OpenID.scala	/^      def port(p:Int) = p match {$/;"	m
port	PlayCommands.scala	/^    val port = others.headOption.orElse(javaProperties.toMap.get("http.port")).orElse(httpPort).map(parsePort).getOrElse(defaultPort)$/;"	V
port	Specs.scala	/^                          val port: Int = Helpers.testServerPort) extends Around with Scope {$/;"	V
port	Specs.scala	/^        val port: Int = Helpers.testServerPort) extends Around with Scope {$/;"	V
pos	PlayLogger.scala	/^    val pos = playPositionMapper(position).get$/;"	V
pos	ScalaTemplateCompiler.scala	/^          val pos = matrix(i - 1)$/;"	V
pos	ScalaTemplateCompiler.scala	/^          val pos = matrix.takeRight(1)(0)$/;"	V
position	Application.scala	/^          def position = null$/;"	m
position	Configuration.scala	/^      def position = null$/;"	m
position	JavascriptCompiler.scala	/^    def position = null$/;"	m
position	Messages.scala	/^            def position = in.pos.column - 1$/;"	m
position	PlayExceptions.scala	/^    def position = column$/;"	m
position	PlayExceptions.scala	/^    def position = column.map(_.asInstanceOf[java.lang.Integer]).orNull$/;"	m
position	PlayExceptions.scala	/^    def position = problem.position.pointer.map(m => m.asInstanceOf[java.lang.Integer]).orNull$/;"	m
position	PlayLogger.scala	/^    val position = new Position {$/;"	V
position	PlayReloader.scala	/^                def position = new xsbti.Position {$/;"	m
position	PlayReloader.scala	/^            def position = pos$/;"	m
positionalLiteral	ScalaTemplateCompiler.scala	/^      def positionalLiteral(s: String): Parser[Plain] = new Parser[Plain] {$/;"	m
positions	ScalaTemplateCompiler.scala	/^      val positions = ListBuffer.empty[(Int, Int)]$/;"	V
post	WS.scala	/^    def post(body: File): Future[Response] = prepare("POST", body).execute$/;"	m
post	WS.scala	/^    def post[T](body: T)(implicit wrt: Writeable[T], ct: ContentTypeOf[T]): Future[Response] = prepare("POST", body).execute$/;"	m
postAndRetrieveStream	WS.scala	/^    def postAndRetrieveStream[A, T](body: T)(consumer: ResponseHeaders => Iteratee[Array[Byte], A])(implicit wrt: Writeable[T], ct: ContentTypeOf[T]): Future[Iteratee[Array[Byte], A]] = prepare("POST", body).executeStream(consumer)$/;"	m
postJson	JsonSpec.scala	/^      val postJson = """[null]"""$/;"	V
postJson	JsonSpec.scala	/^      val postJson = """{"body": "foobar", "created_at": "2011-04-22T13:33:48Z"}"""$/;"	V
postJson	JsonSpec.scala	/^      val postJson = """{"body": "foobar", "created_at":null}"""$/;"	V
postJson	JsonSpec.scala	/^      val postJson = """{"body": "foobar"}"""$/;"	V
postJson	JsonSpec.scala	/^      val postJson = """{"foo": null}"""$/;"	V
postfix	PlayTestListener.scala	/^    val postfix = "Total " + totalCount + ", Failed " + failures + ", Errors " + errors + ", Passed " + passed + ", Skipped " + skipped$/;"	V
pp	EnumeratorsSpec.scala	/^    val pp = Promise[Concurrent.PatchPanel[Int]]()$/;"	V
pp	EnumeratorsSpec.scala	/^    var pp:Enumerator.Pushee[Int] = null$/;"	v
preferred	Messages.scala	/^  def preferred(langs: Seq[Lang])(implicit app: Application): Lang = {$/;"	m
prefix	Router.scala	/^    def prefix: String$/;"	m
prepareCall	DB.scala	/^  def prepareCall(sql: String) = registering(connection.prepareCall(sql))$/;"	m
prepareCall	DB.scala	/^  def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int) = registering(connection.prepareCall(sql, resultSetType, resultSetConcurrency))$/;"	m
prepareCall	DB.scala	/^  def prepareCall(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int) = registering(connection.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability))$/;"	m
prepareStatement	DB.scala	/^  def prepareStatement(sql: String) = registering(connection.prepareStatement(sql))$/;"	m
prepareStatement	DB.scala	/^  def prepareStatement(sql: String, autoGeneratedKeys: Int) = registering(connection.prepareStatement(sql, autoGeneratedKeys))$/;"	m
prepareStatement	DB.scala	/^  def prepareStatement(sql: String, columnIndexes: scala.Array[Int]) = registering(connection.prepareStatement(sql, columnIndexes))$/;"	m
prepareStatement	DB.scala	/^  def prepareStatement(sql: String, columnNames: scala.Array[String]) = registering(connection.prepareStatement(sql, columnNames))$/;"	m
prepareStatement	DB.scala	/^  def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int) = registering(connection.prepareStatement(sql, resultSetType, resultSetConcurrency))$/;"	m
prepareStatement	DB.scala	/^  def prepareStatement(sql: String, resultSetType: Int, resultSetConcurrency: Int, resultSetHoldability: Int) = registering(connection.prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability))$/;"	m
prepend	JsResult.scala	/^  def prepend(error: (JsPath, ValidationError) ): JsError = this.+:(error)$/;"	m
prepend	JsValue.scala	/^  def prepend(el: JsValue): JsArray = this.+:(el)$/;"	m
previous	JsValue.scala	/^          val previous :: stack = nextContext$/;"	V
problem	Evolutions.scala	/^      val problem = executeQuery("select id, hash, apply_script, revert_script, state, last_problem from play_evolutions where state like 'applying_%'")$/;"	V
process	PlayJvm.scala	/^ * val process = {$/;"	V
processStream	PlayJvm.scala	/^  def processStream(log: Logger, level: Level.Value): InputStream => Unit =$/;"	m
processStream	PlayJvm.scala	/^  def processStream(processLine: String => Unit): InputStream => Unit = in => {$/;"	m
processor	PlayReloader.scala	/^        val processor = new PegDownProcessor(Extensions.ALL)$/;"	V
prodApplicationConf	PlayCommands.scala	/^    val prodApplicationConf = customConfig.map { location =>$/;"	V
productionConfig	PlayCommands.scala	/^    val productionConfig = customFileName.map(fn => target \/ fn).getOrElse(target \/ "application.conf")$/;"	V
projectPath	PlayReloader.scala	/^      lazy val projectPath = extracted.currentProject.base$/;"	V
projectTransformers	PlayEclipse.scala	/^    val projectTransformers = if (mainLang == SCALA) Seq[EclipseTransformerFactory[RewriteRule]]() else Seq(addJavaBuilder)$/;"	V
promise	Concurrent.scala	/^            val promise = (e |>> Cont(step))$/;"	V
promise	Concurrent.scala	/^      val promise: scala.concurrent.Promise[Iteratee[E, A]] = Promise[Iteratee[E, A]]()$/;"	V
promise	ConcurrentSpec.scala	/^      val promise = (enumerator |>> Iteratee.fold[String, String]("")(_ ++ _)).flatMap(_.run)$/;"	V
promise	Enumerator.scala	/^      var promise: scala.concurrent.Promise[Iteratee[E, A]] = Promise[Iteratee[E, A]]()$/;"	v
promise	Enumerator.scala	/^  var promise: Promise[Iteratee[E, _]]= _$/;"	v
promise	EnumeratorsSpec.scala	/^    val promise = (enumerator |>>> Iteratee.fold[Array[Byte],Array[Byte]](Array[Byte]())(_ ++ _))$/;"	V
promise	WebSocketHandler.scala	/^      private val promise: scala.concurrent.Promise[Iteratee[A, Any]] = Promise[Iteratee[A, Any]]()$/;"	V
promiseIteratee	EnumeratorsSpec.scala	/^    val promiseIteratee = Promise[Iteratee[Array[Byte], Array[Byte]]]$/;"	V
promiseOfResult	Akka.scala	/^   * val promiseOfResult = Akka.future {$/;"	V
prop1	PartialValidationSpec.scala	/^  var prop1: String = _$/;"	v
prop2	PartialValidationSpec.scala	/^  var prop2: String = _$/;"	v
prop3	PartialValidationSpec.scala	/^  var prop3: String = _$/;"	v
properties	JUnitXmlTestListener.scala	/^  val properties =$/;"	V
props	JUnitXmlTestListener.scala	/^        val props: ListBuffer[Node] = new ListBuffer()$/;"	V
provider	OAuth.scala	/^  private val provider = {$/;"	V
providerRegex	OpenID.scala	/^    private val providerRegex = new Regex( """<link[^>]+openid2[.]provider[^>]+>""")$/;"	V
prune	JsPath.scala	/^    def prune: Reads[JsObject] = Reads.jsPrune(self)$/;"	m
prune	JsPath.scala	/^  def prune(js: JsValue) = {$/;"	m
pruned	JsConstraints.scala	/^  def pruned[A](implicit w: Writes[A]): Writes[A] = new Writes[A] {$/;"	m
ps	Console.scala	/^              val ps = G8Helpers.interact(parameters - "application_name") + ("application_name" -> appName)$/;"	V
ps	Enumerator.scala	/^      val ps = es.zipWithIndex.map{ case (e,index) => e |>> iteratee[E](_.patch(index,Seq(true),1))}$/;"	V
ps	Evolutions.scala	/^            val ps = prepare("insert into play_evolutions values(?, ?, ?, ?, ?, ?, ?)")$/;"	V
ps	Evolutions.scala	/^        val ps = prepare("update play_evolutions set last_problem = ? where id = ?")$/;"	V
pure	JavaPromise.scala	/^  def pure[A](a: A) = Promise.pure(a)$/;"	m
pure	JsConstraints.scala	/^  def pure[A](a: => A) = Reads[A] { js => JsSuccess(a) }$/;"	m
pure	JsConstraints.scala	/^  def pure[A](fixed: => A)(implicit wrs:Writes[A]): Writes[JsValue] =$/;"	m
pure	JsConstraints.scala	/^  def pure[A](path: JsPath, fixed: => A)(implicit wrs:Writes[A]): OWrites[JsValue] =$/;"	m
pure	JsResult.scala	/^    def pure[A](a:A):JsResult[A] = JsSuccess(a)$/;"	m
pure	Promise.scala	/^  def pure[A](a: => A): Future[A] = PurePromise(a)$/;"	m
pure	Reads.scala	/^    def pure[A](a:A):Reads[A] = Reads[A] { _ => JsSuccess(a) }$/;"	m
pureFlatFold	Iteratee.scala	/^  def pureFlatFold[B, C](folder: Step[E, A] => Iteratee[B, C]): Iteratee[B, C] = Iteratee.flatten(pureFold(folder))$/;"	m
pureFold	Iteratee.scala	/^  def pureFold[B](folder: Step[E, A] => B): Future[B] = fold(s => Future.successful(folder(s)))$/;"	m
push	Concurrent.scala	/^        def push(item: Input[E]) {$/;"	m
push	Concurrent.scala	/^      def push(chunk: Input[E]) {$/;"	m
push	Concurrent.scala	/^    def push(chunk: Input[E])$/;"	m
push	Concurrent.scala	/^    def push(item: E) { push(Input.El(item)) }$/;"	m
push	Enumerator.scala	/^        def push(item: E): Boolean = {$/;"	m
push	Enumerator.scala	/^    def push(item: E): Boolean$/;"	m
push	Enumerator.scala	/^  def push(item: E): Boolean = {$/;"	m
pushChunk	RequestBodyHandler.scala	/^    def pushChunk(ctx: ChannelHandlerContext, chunk: Input[Array[Byte]]) {$/;"	m
pushee	Concurrent.scala	/^      val pushee = new Channel[E] {$/;"	V
pushee	Enumerator.scala	/^      val pushee = new Pushee[E] {$/;"	V
put	JsPath.scala	/^    def put(a: => JsValue): Reads[JsObject] = Reads.jsPut(self, a)$/;"	m
put	WS.scala	/^    def put(body: File): Future[Response] = prepare("PUT", body).execute$/;"	m
put	WS.scala	/^    def put[T](body: T)(implicit wrt: Writeable[T], ct: ContentTypeOf[T]): Future[Response] = prepare("PUT", body).execute$/;"	m
putAndRetrieveStream	WS.scala	/^    def putAndRetrieveStream[A, T](body: T)(consumer: ResponseHeaders => Iteratee[Array[Byte], A])(implicit wrt: Writeable[T], ct: ContentTypeOf[T]): Future[Iteratee[Array[Byte], A]] = prepare("PUT", body).executeStream(consumer)$/;"	m
qPattern	Http.scala	/^    val qPattern = ";\\\\s*q=([0-9.]+)".r$/;"	V
qb	CoffeescriptCompiler.scala	/^    val qb = Process(in)$/;"	V
qb	JavascriptCompiler.scala	/^    val qb = Process(in)$/;"	V
query	OpenIDSpec.scala	/^      val query = parseQueryString(redirectUrl)$/;"	V
queryParams	RoutesCompiler.scala	/^                        val queryParams = route.call.parameters.getOrElse(Nil).filterNot { p =>$/;"	V
queryString	Fakes.scala	/^  lazy val queryString: Map[String, Seq[String]] = play.core.parsers.FormUrlEncodedParser.parse(rawQueryString)$/;"	V
queryString	FormSpec.scala	/^  def queryString: java.util.Map[String, Array[String]] = new java.util.HashMap()$/;"	m
queryString	Http.scala	/^        val queryString = _queryString$/;"	V
queryString	Http.scala	/^      def queryString = rh.queryString$/;"	m
queryString	Http.scala	/^      def queryString = self.queryString$/;"	m
queryString	Http.scala	/^    def queryString = request.queryString$/;"	m
queryString	Http.scala	/^    def queryString: Map[String, Seq[String]]$/;"	m
queryString	JavaHelpers.scala	/^      def queryString = {$/;"	m
queryString	PlayDefaultUpstreamHandler.scala	/^          def queryString = parameters$/;"	m
queryString	Router.scala	/^  def queryString(items: List[Option[String]]) = {$/;"	m
queryString	WS.scala	/^    def queryString: Map[String, Seq[String]] = {$/;"	m
queryString	csrf.scala	/^          def queryString = request.queryString$/;"	m
r	CoffeescriptCompiler.scala	/^      val r = eRegex.unapplySeq(errReverse.mkString("")).map(_.head.toInt)$/;"	V
r	DB.scala	/^        val r = block(connection)$/;"	V
r	Evolutions.scala	/^      val r = s.executeQuery("select lock from play_evolutions_lock")$/;"	V
r	JavaGlobalSettingsAdapter.scala	/^    val r = JavaHelpers.createJavaRequest(request)$/;"	V
r	JavascriptCompiler.scala	/^      val r = ctx.evaluateReader(scope, new InputStreamReader($/;"	V
r	JavascriptCompiler.scala	/^      val r = eRegex.unapplySeq(errReverse.mkString("")).map(_.head.toInt)$/;"	V
r	NettyPromise.scala	/^        val r = if (future.isSuccess()) Success(()) else Failure(future.getCause())$/;"	V
r	Reads.scala	/^        val r = m.map { case (key, value) => $/;"	V
r	Reads.scala	/^        val r = ts.zipWithIndex.map { case (elt, idx) => fromJson[A](elt)(ra) match {$/;"	V
r	ScalaTemplateCompiler.scala	/^          val r = new java.util.Random$/;"	V
r	SqlStatementParser.scala	/^    val r = parse(instr, in.trim().replace("\\r", "").replace("\\n", " ")).get$/;"	V
r1	Enumerator.scala	/^      val r1 = e1 |>>| itE1$/;"	V
r1	ScalaTemplateCompiler.scala	/^          val r1 = new Response[global.Tree]$/;"	V
r2	Enumerator.scala	/^      val r2 = e2 |>>| itE2$/;"	V
rCookies	PlayDefaultUpstreamHandler.scala	/^        val rCookies = getCookies(nettyHttpRequest)$/;"	V
rHeaders	PlayDefaultUpstreamHandler.scala	/^        val rHeaders = getHeaders(nettyHttpRequest)$/;"	V
rRemoteAddress	PlayDefaultUpstreamHandler.scala	/^        def rRemoteAddress = e.getRemoteAddress match {$/;"	m
random	Console.scala	/^    val random = new java.security.SecureRandom$/;"	V
random	csrf.scala	/^    val random = new SecureRandom$/;"	V
randomFileName	ScalaTemplateCompiler.scala	/^        val randomFileName = {$/;"	V
raw	ContentTypes.scala	/^    def raw(memoryThreshold: Int): BodyParser[RawBuffer] = BodyParser("raw, memoryThreshold=" + memoryThreshold) { request =>$/;"	m
raw	ContentTypes.scala	/^    def raw: BodyParser[RawBuffer] = raw(memoryThreshold = 100 * 1024)$/;"	m
raw	Crypto.scala	/^    val raw = privateKey.getBytes("utf-8")$/;"	V
raw	FakeRuntime.scala	/^    def raw(text: String): T$/;"	m
raw	JavaParsers.scala	/^  def raw(maxLength: Int): BodyParser[RequestBody] = parse.maxLength(orDefault(maxLength), parse.raw(Integer.MAX_VALUE)).map { body =>$/;"	m
raw	ScalaTemplate.scala	/^    def raw(text: String): T$/;"	m
raw	TemplateCompilerSpec.scala	/^    def raw(text: String) = Html(text)$/;"	m
raw	TemplateUtilsSpec.scala	/^          def raw(text: String) = Html(text)$/;"	m
raw	TemplateUtilsSpec.scala	/^          def raw(text: String) = Text(text)$/;"	m
raw	Templates.scala	/^  def raw(text: String) = Txt(text)$/;"	m
raw	Templates.scala	/^  def raw(text: String) = Xml(text)$/;"	m
raw	Templates.scala	/^  def raw(text: String): Html = Html(text)$/;"	m
rawQueryString	Http.scala	/^    lazy val rawQueryString: String = uri.split('?').drop(1).mkString("?")$/;"	V
read	JsPath.scala	/^  def read[T](implicit r: Reads[T]): Reads[T] = Reads.at[T](this)(r)$/;"	m
read	JsPath.scala	/^  def read[T](t: T) = Reads.pure(t)$/;"	m
readApplicationName	Console.scala	/^  def readApplicationName(defaultName: String): String = {$/;"	m
readAsBytes	Helpers.scala	/^      var readAsBytes = Enumeratee.map[r.BODY_CONTENT](r.writeable.transform(_)).transform(Iteratee.consume[Array[Byte]]())$/;"	v
readAsBytes	JavaResults.scala	/^      var readAsBytes = Enumeratee.map[r.BODY_CONTENT](r.writeable.transform(_)).transform(Iteratee.consume[Array[Byte]]())$/;"	v
readContent	LessCompiler.scala	/^  def readContent(file: File) = Path(file).string.replace("\\r", "")$/;"	m
readFile	Files.scala	/^  def readFile(path: File): String = Path(path).string$/;"	m
readNullable	JsPath.scala	/^  def readNullable[T](implicit r: Reads[T]): Reads[Option[T]] = Reads.nullable[T](this)(r)$/;"	m
readOnly	DB.scala	/^    val readOnly = conf.getBoolean("readOnly").getOrElse(false)$/;"	V
readOpt	JsPath.scala	/^  def readOpt[T](implicit r: Reads[T]): Reads[Option[T]] = Reads.optional[T](this)(r)$/;"	m
readPart	ContentTypes.scala	/^            val readPart = collectHeaders.flatMap { case (headers, left) => Iteratee.flatten(partHandler(headers).feed(Input.El(left))) }$/;"	V
readTree	JsMacroImpl.scala	/^                          val readTree = $/;"	V
reader	PlayJvm.scala	/^    val reader = new BufferedReader(new InputStreamReader(in))$/;"	V
reads	Format.scala	/^      def reads(json: JsValue) = fjs.reads(json)$/;"	m
reads	Format.scala	/^    def reads(js:JsValue):JsResult[A] = r.reads(js)$/;"	m
reads	Format.scala	/^    def reads(js:JsValue):JsResult[A] = read(js)$/;"	m
reads	Json.scala	/^  def reads[A] = macro JsMacroImpl.readsImpl[A]$/;"	m
reads	Reads.scala	/^      def reads(js: JsValue) = alt1.reads(js) match {$/;"	m
reads	Reads.scala	/^    def reads(json: JsValue) = JsSuccess(json)$/;"	m
reads	Reads.scala	/^    def reads(json: JsValue) = f(json)$/;"	m
reads	Reads.scala	/^    def reads(json: JsValue) = fmt.reads(json).fold( e => JsSuccess(None), v => JsSuccess(Some(v)))$/;"	m
reads	Reads.scala	/^    def reads(json: JsValue) = json match {$/;"	m
reads	Reads.scala	/^    def reads(json: JsValue) = json.validate[List[T]].map( _.toArray )$/;"	m
reads	Reads.scala	/^    def reads(json: JsValue): JsResult[DateTime] = json match {$/;"	m
reads	Reads.scala	/^    def reads(json: JsValue): JsResult[LocalDate] = json match {$/;"	m
reads	Reads.scala	/^    def reads(json: JsValue): JsResult[java.util.Date] = json match {$/;"	m
reads	Reads.scala	/^  def reads(json: JsValue): JsResult[A]$/;"	m
reads1	JsonValidSpec.scala	/^      val reads1 = (__ \\ 'field3).json.pick$/;"	V
reads2	JsonValidSpec.scala	/^      val reads2 = ((__ \\ 'field32).read[Int] and (__ \\ 'field31).read[String]).tupled$/;"	V
readsImpl	JsMacroImpl.scala	/^  def readsImpl[A : c.WeakTypeTag](c: Context) : c.Expr[Reads[A]] = {$/;"	m
readsSelect	JsMacroImpl.scala	/^    val readsSelect = Select(jsonPkg, "Reads")$/;"	V
ready	Concurrent.scala	/^          val ready = commitReady().toMap$/;"	V
ready	Concurrent.scala	/^      val ready = interested.map {$/;"	V
ready	Concurrent.scala	/^      val ready = interested.zipWithIndex.map {$/;"	V
ready	NettyPromise.scala	/^    def ready(atMost: Duration)(implicit permit: CanAwait): this.type = {$/;"	m
readyOrNot	Concurrent.scala	/^              val readyOrNot: Future[Either[Iteratee[E, Iteratee[E, A]], Unit]] = Future.firstCompletedOf($/;"	V
recUserFormat	JsonExtensionSpec.scala	/^      implicit val recUserFormat = Json.format[RecUser]$/;"	V
recUserReads	JsonExtensionSpec.scala	/^      implicit val recUserReads = Json.reads[RecUser]$/;"	V
recUserWrites	JsonExtensionSpec.scala	/^      implicit val recUserWrites = Json.writes[RecUser]$/;"	V
recover	JavaPromise.scala	/^  def recover[A](promise: Future[A], f: Throwable => Future[A], ec:ExecutionContext): Future[A] = {$/;"	m
recover	JsResult.scala	/^  def recover[AA >: A]( errManager: PartialFunction[JsError, AA] ): JsResult[AA] = this match {$/;"	m
recoverTotal	JsResult.scala	/^  def recoverTotal[AA >: A]( errManager: JsError => AA ): AA = this match {$/;"	m
recursiveJson	JsonSpec.scala	/^      val recursiveJson = """{"foo": {"foo":["bar"]}, "bar": {"foo":["bar"]}}"""$/;"	V
red	Color.scala	/^  def red(str: String): String = if (isANSISupported) (RED + str + RESET) else str$/;"	m
red	Console.scala	/^  def red(str: String): String = if (isANSISupported) (RED + str + RESET) else str$/;"	m
redeem	Promise.scala	/^  def redeem(a: => A)(implicit ec:ExecutionContext): Unit = p.completeWith(Future(a)(ec))$/;"	m
redeem	Promise.scala	/^  def redeem(a: => A)(implicit ec:ExecutionContext): Unit$/;"	m
redeemResultIfNotYet	Enumerator.scala	/^      def redeemResultIfNotYet(r:Iteratee[E, A]){$/;"	m
redeemResultIfNotYet	Enumerator.scala	/^      def redeemResultIfNotYet(r:Iteratee[E2, A]){$/;"	m
redeemed	Concurrent.scala	/^      val redeemed = Ref(None: Option[Try[Iteratee[E, Unit]]])$/;"	V
redeemed	Concurrent.scala	/^    val redeemed = Ref(None: Option[Try[Unit]])$/;"	V
redeemed	RequestBodyHandler.scala	/^    val redeemed = Ref(false)$/;"	V
redirect	Default.scala	/^  def redirect(to: String): Action[AnyContent] = Action {$/;"	m
redirectLocation	Helpers.scala	/^  def redirectLocation(of: Result): Option[String] = of match {$/;"	m
redirectURL	OpenID.scala	/^  def redirectURL(openID: String,$/;"	m
redirectUrl	DiscoverySpec.scala	/^        val redirectUrl = Await.result(new OpenIDClient(ws.url).redirectURL("http:\/\/example.com\/", returnTo), dur)$/;"	V
redirectUrl	DiscoverySpec.scala	/^        val redirectUrl = Await.result(new OpenIDClient(ws.url).redirectURL(openId, returnTo), dur)$/;"	V
redirectUrl	OAuth.scala	/^  def redirectUrl(token: String): String = {$/;"	m
redirectUrl	OpenIDSpec.scala	/^      val redirectUrl = Await.result(openId.redirectURL("http:\/\/example.com", "http:\/\/foo.bar.com\/returnto"), dur)$/;"	V
redirectUrl	OpenIDSpec.scala	/^      val redirectUrl = Await.result(openId.redirectURL("http:\/\/example.com", "http:\/\/foo.bar.com\/returnto",$/;"	V
ref	Concurrent.scala	/^        val ref: Ref[Ref[Iteratee[E, Option[A]]]] = Ref(Ref(it.map(Some(_))))$/;"	V
ref	Promise.scala	/^    val ref = Ref(false)$/;"	V
ref	ScalaTemplateCompiler.scala	/^    def ref: this.type = this$/;"	m
ref.SoftReference	ReflectionsCache.scala	/^  import ref.SoftReference$/;"	i
refIteratee	Concurrent.scala	/^      def refIteratee(ref: Ref[Iteratee[E, Option[A]]]): Iteratee[E, Option[A]] = {$/;"	m
refReverseRouting	RoutesCompiler.scala	/^  def refReverseRouting(routes: List[Route]): String = {$/;"	m
reflect.BeanProperty	Task.scala	/^import reflect.BeanProperty$/;"	i
reflect.ClassTag	Application.scala	/^import reflect.ClassTag$/;"	i
reflect.ClassTag	Binders.scala	/^import reflect.ClassTag$/;"	i
reflect.ClassTag	Cached.scala	/^import reflect.ClassTag$/;"	i
reflect.ClassTag	Reads.scala	/^import reflect.ClassTag$/;"	i
reflect.ClassTag	ScalaTemplate.scala	/^import reflect.ClassTag$/;"	i
reflect.{ClassTag, ClassManifest}	Cache.scala	/^import reflect.{ClassTag, ClassManifest}$/;"	i
reflections	ReflectionsCache.scala	/^      val reflections = new Reflections(new util.ConfigurationBuilder()$/;"	V
reflectionsMap	ReflectionsCache.scala	/^    val reflectionsMap = reflectionsMapRef.flatMap(_.get).filter(_._1 == classLoader).map(_._2).getOrElse {$/;"	V
reflectionsMapRef	ReflectionsCache.scala	/^  @volatile private var reflectionsMapRef: Option[SoftReference[(ClassLoader, Map[String, Reflections])]] = None$/;"	v
regexComponentPathPart	RoutesCompiler.scala	/^    def regexComponentPathPart: Parser[DynamicPart] = "$" ~> identifier ~ ("<" ~> (not(">") ~> """[^\\s]""".r +) <~ ">" ^^ { case c => c.mkString }) ^^ {$/;"	m
reif	JsMacroImpl.scala	/^                      \/*val reif = reify($/;"	V
relativeModulePath	PlayCommands.scala	/^      val relativeModulePath = (str: String) => str.replace(".js", "")$/;"	V
relativePath	ApplicationProvider.scala	/^              val relativePath = pageSource.parent.get.relativize(Path(documentationHome.get)).path$/;"	V
releaseSavepoint	DB.scala	/^  def releaseSavepoint(savepoint: Savepoint) { connection.releaseSavepoint(savepoint) }$/;"	m
reload	PlayReloader.scala	/^      def reload: AnyRef = {$/;"	m
reloadNextTime	PlayReloader.scala	/^      var reloadNextTime = false$/;"	v
reloadable	ApplicationProvider.scala	/^              val reloadable = this$/;"	V
reloaded	ApplicationProvider.scala	/^        val reloaded = sbtLink.reload match {$/;"	V
reloaded	PlayReloader.scala	/^              def reloaded(): Unit = ()$/;"	m
reloaded	PlayReloader.scala	/^            def reloaded() { _changed = false }$/;"	m
reloader	PlayCommands.scala	/^      lazy val reloader = newReloader(state, playReload, applicationLoader)$/;"	V
remainingIteratee	Enumerator.scala	/^                val remainingIteratee = k(Input.EOF)$/;"	V
remapProblemForGeneratedSources	PlayReloader.scala	/^      def remapProblemForGeneratedSources(problem: xsbti.Problem) = {$/;"	m
remoteAddress	FormSpec.scala	/^  val remoteAddress = "127.0.0.1"$/;"	V
remoteAddress	Http.scala	/^        val remoteAddress = _remoteAddress$/;"	V
remoteAddress	Http.scala	/^      def remoteAddress = self.remoteAddress$/;"	m
remoteAddress	Http.scala	/^      lazy val remoteAddress = rh.remoteAddress$/;"	V
remoteAddress	Http.scala	/^    def remoteAddress = request.remoteAddress$/;"	m
remoteAddress	Http.scala	/^    def remoteAddress: String$/;"	m
remoteAddress	JavaHelpers.scala	/^      def remoteAddress = req.remoteAddress$/;"	m
remoteAddress	PlayDefaultUpstreamHandler.scala	/^            val remoteAddress = ra.getAddress.getHostAddress$/;"	V
remoteAddress	PlayDefaultUpstreamHandler.scala	/^          lazy val remoteAddress = rRemoteAddress$/;"	V
remoteAddress	csrf.scala	/^          def remoteAddress = request.remoteAddress$/;"	m
remove	Cache.scala	/^    def remove(key: String) {$/;"	m
remove	Cache.scala	/^  def remove(key: String)$/;"	m
remove	Cache.scala	/^  def remove(key: String)(implicit app: Application) {$/;"	m
removeWatch	PlayReloader.scala	/^              def removeWatch(id: Int): Unit = ()$/;"	m
removeWatch	PlayReloader.scala	/^            def removeWatch(id: Int): Unit = removeWatchMethod.invoke(null, id.asInstanceOf[AnyRef])$/;"	m
removeWatchMethod	PlayReloader.scala	/^          val removeWatchMethod = jnotifyClass.getMethod("removeWatch", classOf[Int])$/;"	V
render	Render.scala	/^  def render(f: PartialFunction[MediaRange, Result])(implicit request: RequestHeader): Result = {$/;"	m
renderCall	ScalaTemplateCompiler.scala	/^        val renderCall = "def render%s: %s = apply%s".format($/;"	V
repath	JsResult.scala	/^  def repath(path: JsPath): JsResult[A] = this match {$/;"	m
repeat	Enumerator.scala	/^  def repeat[E](e: => E): Enumerator[E] = checkContinue0( new TreatCont0[E]{$/;"	m
repeat	Iteratee.scala	/^  def repeat[E, A](i: Iteratee[E, A]): Iteratee[E, Seq[A]] = {$/;"	m
repeatM	Enumerator.scala	/^  def repeatM[E](e: => Future[E]): Enumerator[E] = checkContinue0( new TreatCont0[E]{$/;"	m
repeatedForm	FormSpec.scala	/^    val repeatedForm = Form($/;"	V
replace	Console.scala	/^  def replace(file: File, tokens: (String, String)*) {$/;"	m
repo	Console.scala	/^          val repo = template._1$/;"	V
report	PlayCommands.scala	/^      val report = XML.loadFile($/;"	V
reportCompilationError	PlayAssetsCompiler.scala	/^  def reportCompilationError(state: State, error: PlayException.ExceptionSource) = {$/;"	m
reportError	Configuration.scala	/^  def reportError(path: String, message: String, e: Option[Throwable] = None): PlayException = {$/;"	m
req	FormSpec.scala	/^      val req = new DummyRequest(Map("id" -> Array("1234567891"), "name" -> Array("peter"), "done" -> Array("true"), "dueDate" -> Array("15\/12\/2009")))$/;"	V
req	FormSpec.scala	/^      val req = new DummyRequest(Map("id" -> Array("1234567891"), "name" -> Array("peter"), "dueDate" -> Array("15\/12\/2009")))$/;"	V
req	FormSpec.scala	/^      val req = new DummyRequest(Map("id" -> Array("1234567891"), "name" -> Array("peter"), "dueDate" -> Array("2009\/11e\/11")))$/;"	V
req	FormSpec.scala	/^      val req = new DummyRequest(Map("id" -> Array("1234567891x"), "name" -> Array("peter"), "dueDate" -> Array("12\/12\/2009")))$/;"	V
req	WSSpec.scala	/^      val req = WS.url("http:\/\/playframework.org\/")$/;"	V
request	Action.scala	/^        val request = Request(rh, a)$/;"	V
request	OpenIDSpec.scala	/^    val request = mock[Request[_]]$/;"	V
request	WS.scala	/^      val request = new WSRequest(method, auth, calc).setUrl(url)$/;"	V
request	WsMock.scala	/^    val request = mock[WSRequestHolder]$/;"	V
requestHeader	PlayDefaultUpstreamHandler.scala	/^        val requestHeader = handler.right.toOption.map({$/;"	V
requestIDs	PlayDefaultUpstreamHandler.scala	/^  private val requestIDs = new java.util.concurrent.atomic.AtomicLong(0)$/;"	V
requestParams	UserInfoSpec.scala	/^      val requestParams = createDefaultResponseWithAttributeExchange ++ Map[String, Seq[String]]($/;"	V
requestParams	UserInfoSpec.scala	/^    val requestParams = createDefaultResponseWithAttributeExchange ++ Map[String, Seq[String]]($/;"	V
require	JavascriptCompiler.scala	/^  def require(source: File): Unit = {$/;"	m
requireJs	PlayKeys.scala	/^  val requireJs = SettingKey[Seq[String]]("play-require-js")$/;"	V
requireJsFolder	PlayKeys.scala	/^  val requireJsFolder = SettingKey[String]("play-require-js-folder")$/;"	V
requireJsShim	PlayKeys.scala	/^  val requireJsShim = SettingKey[String]("play-require-js-shim")$/;"	V
requireNativePath	PlayKeys.scala	/^  val requireNativePath = SettingKey[Option[String]]("play-require-native-path")$/;"	V
requireSupport	PlayAssetsCompiler.scala	/^      val requireSupport = if (!requireJs.isEmpty) {$/;"	V
required	JsConstraints.scala	/^  def required(path:JsPath)(implicit reads: Reads[JsValue]): Reads[JsValue] = at(path)(reads)$/;"	m
res	JsPathSpec.scala	/^      val res = Json.obj( $/;"	V
res	JsonValidSpec.scala	/^      val res = JsSuccess("foo")$/;"	V
res	JsonValidSpec.scala	/^      val res = Json.obj($/;"	V
res	WS.scala	/^      val res = mapAsScalaMapConverter(headers).asScala.map(e => e._1 -> e._2.asScala.toSeq).toMap$/;"	V
res1	JsonValidSpec.scala	/^        val res1: JsResult[String] = JsSuccess("foo", JsPath(List(KeyPathNode("bar"))))$/;"	V
res2	JsPathSpec.scala	/^      val res2 = Json.obj( $/;"	V
res2	JsonValidSpec.scala	/^        val res2: JsResult[String] = JsError(Seq(JsPath(List(KeyPathNode("bar"))) -> Seq(ValidationError("baz.bah"))))$/;"	V
res3	JsPathSpec.scala	/^      val res3 = Json.obj( $/;"	V
resetClient	WS.scala	/^  def resetClient(): Unit = {$/;"	m
resolve	Evolutions.scala	/^  def resolve(api: DBApi, db: String, revision: Int) {$/;"	m
resolve	Evolutions.scala	/^  def resolve(appPath: File, classloader: ClassLoader, dbName: String, revision: Int) {$/;"	m
resolve	LessCompiler.scala	/^  def resolve(originalSource: File, imported: String) = new File(originalSource.getParentFile, imported)$/;"	m
resolve	OpenID.scala	/^    def resolve(response: Response) = for {$/;"	m
resolve	OpenID.scala	/^    def resolve(response: Response) = {$/;"	m
resolve	OpenID.scala	/^    def resolve(response: Response): Option[OpenIDServer]$/;"	m
resolveEvolutions	Evolutions.scala	/^    val resolveEvolutions = """\/@evolutions\/resolve\/([a-zA-Z0-9_]+)\/([0-9]+)""".r$/;"	V
resource	Application.scala	/^  def resource(name: String): Option[java.net.URL] = {$/;"	m
resource	Assets.scala	/^      val resource = {$/;"	V
resource	Play.scala	/^  def resource(name: String)(implicit app: Application): Option[java.net.URL] = {$/;"	m
resource	PlayCommands.scala	/^          val resource = reloader.currentApplicationClassLoader.map(findResource.invoke(_, name).asInstanceOf[java.net.URL]).orNull$/;"	V
resourceAsStream	Application.scala	/^  def resourceAsStream(name: String): Option[InputStream] = {$/;"	m
resourceAsStream	Play.scala	/^  def resourceAsStream(name: String)(implicit app: Application): Option[InputStream] = {$/;"	m
resourceName	Assets.scala	/^    val resourceName = Option(path + "\/" + file).map(name => if (name.startsWith("\/")) name else ("\/" + name)).get$/;"	V
resources	PlayCommands.scala	/^          val resources = new java.util.Vector[java.net.URL]($/;"	V
resources	PlayCommands.scala	/^    val resources = inAllDependencies(ref, resourceDirectories in Compile, Project structure state).foldLeft(Seq.empty[File])(_ ++ _)$/;"	V
resources1	PlayCommands.scala	/^          val resources1 = reloader.currentApplicationClassLoader.map(findResources.invoke(_, name).asInstanceOf[java.util.Enumeration[java.net.URL]]).getOrElse(new java.util.Vector[java.net.URL]().elements)$/;"	V
resources2	PlayCommands.scala	/^          val resources2 = super.getResources(name)$/;"	V
resp	csrf.scala	/^           val resp = cookies.get(c).map(_ => r).getOrElse(r.withCookies(Cookie(c, token.value)))$/;"	V
resp	csrf.scala	/^           val resp = r.withSession(Session.deserialize(newSession))$/;"	V
response	Assets.scala	/^                val response = SimpleResult($/;"	V
response	DiscoverySpec.scala	/^      val response = mock[Response]$/;"	V
response	PlayDefaultUpstreamHandler.scala	/^        val response = new Response {$/;"	V
response	WsMock.scala	/^    val response = mock[Response]$/;"	V
responseQueryString	OpenIDSpec.scala	/^      val responseQueryString = (openIdResponse - "openid.op_endpoint")$/;"	V
responseQueryString	OpenIDSpec.scala	/^      val responseQueryString = openIdResponse - "openid.op_endpoint" + ("openid.op_endpoint" -> Seq(spoofedEndpoint))$/;"	V
responseQueryString	OpenIDSpec.scala	/^      val responseQueryString = openIdResponse$/;"	V
result	Anorm.scala	/^      val result = sql.argsInitialOrder$/;"	V
result	Codecs.scala	/^    val result = new Array[Char](array.length * 2)$/;"	V
result	Concurrent.scala	/^          val result = Promise[Iteratee[E, A]]()$/;"	V
result	Concurrent.scala	/^        val result = Promise[Iteratee[E, A]]()$/;"	V
result	Concurrent.scala	/^      val result = Promise[Iteratee[E, A]]()$/;"	V
result	ConcurrentSpec.scala	/^      val result = $/;"	V
result	ConcurrentSpec.scala	/^      val result = (fastEnumerator &> Concurrent.lazyAndErrIfNotReady(50) |>>> slowIteratee)$/;"	V
result	Console.scala	/^          val result = parsed.right.flatMap { case (repo, branch, _) =>$/;"	V
result	EnumerateesSpec.scala	/^      val result = $/;"	V
result	EnumerateesSpec.scala	/^      val result = (Enumerator("dasdasdas ", "dadadasda\\nshouldb\\neinnext") &> Enumeratee.grouped(upToSpace) ><> Enumeratee.map(_+"|")) |>>> Iteratee.consume[String]()$/;"	V
result	Enumerator.scala	/^      val result = Promise[Iteratee[E, A]]()$/;"	V
result	Enumerator.scala	/^      val result = Promise[Iteratee[E2, A]]()$/;"	V
result	EnumeratorsSpec.scala	/^      val result = Await.result(kk, Duration.Inf)$/;"	V
result	EnumeratorsSpec.scala	/^    val result = Await.result((e1 interleave e2) |>>> Iteratee.getChunks[Int], Duration.Inf)$/;"	V
result	EnumeratorsSpec.scala	/^    val result = Await.result(futureOfResult, Duration.Inf)$/;"	V
result	Filters.scala	/^        val result = self.apply({(rh:RequestHeader) => it.success(next(rh)) ; AsyncResult(p.future)})(rh)$/;"	V
result	Filters.scala	/^ *		 val result = next(request)$/;"	V
result	Form.scala	/^    val result = mapping.unbind(value)$/;"	V
result	JUnitXmlTestListener.scala	/^      val result = <testsuite hostname={ hostname } name={ name } tests={ tests + "" } errors={ errors + "" } failures={ failures + "" } time={ (duration \/ 1000.0).toString }>$/;"	V
result	LessCompiler.scala	/^      val result = Context.call(null, compilerFunction, scope, scope, Array(source)).asInstanceOf[Scriptable]$/;"	V
result	NettyPromise.scala	/^    def result(atMost: Duration)(implicit permit: CanAwait): Unit = {$/;"	m
result	ParsingSpec.scala	/^      val result = Await.result(parsed, Duration.Inf).map {$/;"	V
result	PlayReloader.scala	/^        val result = Project.runTask(sk, state).map(_._2)$/;"	V
result	PlayTestListener.scala	/^  val result = new collection.mutable.ListBuffer[String]$/;"	V
result	Promise.scala	/^    val result = Promise[B]()$/;"	V
result	RoutesCompilerSpec.scala	/^      val result = parser.parse(line)$/;"	V
result	ScalaTemplateCompiler.scala	/^          val result = literal(s)(in)$/;"	V
result	WS.scala	/^      var result = Promise[Response]()$/;"	v
resultJson	JsonSpec.scala	/^      val resultJson = Json.parse(recursiveJson)$/;"	V
resultPost	JsonSpec.scala	/^      val resultPost = Json.parse(postJson).as[Post]$/;"	V
resultPost	JsonValidSpec.scala	/^      val resultPost = json.validate( (__ \\ "field").read(Reads.optionWithNull[String]) )$/;"	V
resultSet	Anorm.scala	/^  def resultSet()(implicit connection: java.sql.Connection) = (getFilledStatement(connection).executeQuery())$/;"	m
resultSetToStream	Anorm.scala	/^  def resultSetToStream(rs: java.sql.ResultSet): Stream[SqlRow] = {$/;"	m
results	EnumeratorsSpec.scala	/^    val results = Future.sequence(Range(1,20).map(_ => Iteratee.fold[String,String](""){(s,e) => s + e }).map(broadcaster.apply).map(_.flatMap(_.run)))$/;"	V
retrieveAccessToken	OAuth.scala	/^  def retrieveAccessToken(token: RequestToken, verifier: String): Either[OAuthException, RequestToken] = {$/;"	m
retrieveRequestToken	OAuth.scala	/^  def retrieveRequestToken(callbackURL: String): Either[OAuthException, RequestToken] = {$/;"	m
returnTo	DiscoverySpec.scala	/^        val returnTo = "http:\/\/foo.bar.com\/openid"$/;"	V
reverseParameters	RoutesCompiler.scala	/^                    val reverseParameters = parameters.zipWithIndex.filterNot {$/;"	V
reverseRouting	RoutesCompiler.scala	/^  def reverseRouting(routes: List[Route]): String = {$/;"	m
reverseSignature	RoutesCompiler.scala	/^                    val reverseSignature = parameters.map(p => safeKeyword(p.name) + ":" + p.typeName).mkString(", ")$/;"	V
reverseSignature	RoutesCompiler.scala	/^                    val reverseSignature = reverseParameters.map(p => safeKeyword(p._1.name) + ":" + p._1.typeName + {$/;"	V
revision	Evolutions.scala	/^        val revision = problem.getInt("id")$/;"	V
rhWithCt	Helpers.scala	/^    val rhWithCt = w.contentType.map(ct => rh.copy($/;"	V
rhs	MediaRange.scala	/^    val rhs = parts(1)$/;"	V
rjnewDir	PlayCommands.scala	/^      val rjnewDir = new JFile(rjoldDir.getAbsolutePath + "-min")$/;"	V
rjoldDir	PlayCommands.scala	/^    val rjoldDir = crossTarget \/ "classes" \/ "public" \/ jsFolder$/;"	V
rollback	DB.scala	/^  def rollback(savepoint: Savepoint) { connection.rollback(savepoint) }$/;"	m
rootAction	JavaAction.scala	/^    val rootAction = new JAction[Any] {$/;"	V
route	Helpers.scala	/^  def route[T](app: Application, req: Request[T])(implicit w: Writeable[T]): Option[Result] = route(app, req, req.body)$/;"	m
route	Helpers.scala	/^  def route[T](app: Application, rh: RequestHeader, body: T)(implicit w: Writeable[T]): Option[Result] = {$/;"	m
route	Helpers.scala	/^  def route[T](req: Request[T])(implicit w: Writeable[T]): Option[Result] = route(Play.current, req)$/;"	m
route	Helpers.scala	/^  def route[T](rh: RequestHeader, body: T)(implicit w: Writeable[T]): Option[Result] = route(Play.current, rh, body)$/;"	m
route	RoutesCompiler.scala	/^                    val route = routes(0)$/;"	V
route	RoutesCompiler.scala	/^    def route = httpVerb ~! separator ~ path ~ separator ~ positioned(call) ~ ignoreWhiteSpace ^^ {$/;"	m
routeAndCall	Helpers.scala	/^  def routeAndCall[T, ROUTER <: play.core.Router.Routes](router: Class[ROUTER], request: FakeRequest[T]): Option[Result] = {$/;"	m
routeAndCall	Helpers.scala	/^  def routeAndCall[T](request: FakeRequest[T]): Option[Result] = {$/;"	m
routeDefinitions	RoutesCompiler.scala	/^  def routeDefinitions(rules: List[Rule]): String = {$/;"	m
routeFile	RoutesCompiler.scala	/^      val routeFile = Path(file).toAbsolute$/;"	V
routeToHome	Routes.scala	/^     * var routeToHome = MyRouter.controllers.Application.index()$/;"	v
router	RoutesCompiler.scala	/^    def router: Parser[String] = rep1sep(identifier, ".") ^^ {$/;"	m
routes	Application.scala	/^  lazy val routes: Option[Router.Routes] = try {$/;"	V
routes	Helpers.scala	/^    val routes = router.getClassLoader.loadClass(router.getName + "$").getDeclaredField("MODULE$").get(null).asInstanceOf[play.core.Router.Routes]$/;"	V
routes	Play.scala	/^  def routes(implicit app: Application): Option[play.core.Router.Routes] = app.routes$/;"	m
routes	Router.scala	/^    def routes: PartialFunction[RequestHeader, Handler]$/;"	m
routes	RoutesCompiler.scala	/^    val routes = rules.collect { case r: Route => r }$/;"	V
routesContent	RoutesCompiler.scala	/^      val routesContent = routeFile.string$/;"	V
routesImport	PlayKeys.scala	/^  val routesImport = SettingKey[Seq[String]]("play-routes-imports")$/;"	V
routesPositionMapper	PlayPositionMapper.scala	/^  val routesPositionMapper: Position => Option[Position] = position => {$/;"	V
routing	RoutesCompiler.scala	/^  def routing(routes: List[Rule]): String = {$/;"	m
rsMetaData	Anorm.scala	/^    val rsMetaData = metaData(rs)$/;"	V
rule	RoutesCompilerSpec.scala	/^      val rule = parseRule("-> \/s someFile")$/;"	V
rule	RoutesCompilerSpec.scala	/^      val rule = parseRule(line)$/;"	V
run	Console.scala	/^  def run(app: xsbti.AppConfiguration): Exit = {$/;"	m
run	Enumerator.scala	/^  def run[A](i: Iteratee[E, A]): Future[A] = |>>>(i)$/;"	m
run	Iteratee.scala	/^  def run: Future[A] = fold({$/;"	m
run	TemplateCompilerSpec.scala	/^      val run = new compiler.Run$/;"	V
runTask	PlayReloader.scala	/^      def runTask(task: String): AnyRef = {$/;"	m
running	Helpers.scala	/^  def running[T, WEBDRIVER <: WebDriver](testServer: TestServer, webDriver: Class[WEBDRIVER])(block: TestBrowser => T): T = {$/;"	m
running	Helpers.scala	/^  def running[T](fakeApp: FakeApplication)(block: => T): T = {$/;"	m
running	Helpers.scala	/^  def running[T](testServer: TestServer)(block: => T): T = {$/;"	m
rw	JsPath.scala	/^  def rw[T](implicit r:Reads[T], w:Writes[T]): OFormat[T] = Format.at[T](this)(Format(r, w))$/;"	m
s	Anorm.scala	/^    val s = if (getGeneratedKeys) connection.prepareStatement(sql.query, java.sql.Statement.RETURN_GENERATED_KEYS)$/;"	V
s	Concurrent.scala	/^          val s = state.single.getAndTransform {$/;"	V
s	Evolutions.scala	/^      val s = c.createStatement()$/;"	V
s	ScalaTemplateCompiler.scala	/^      val s = new File(meta("SOURCE"))$/;"	V
s0	Reads.scala	/^      val s0 = input.substring( 0, input.length - inset )$/;"	V
s1	Iteratee.scala	/^      case Input.El(e) => { val s1 = f(s, e); Cont[E, A](i => step(s1)(i)) }$/;"	V
s1	Reads.scala	/^      val s1 = input.substring( input.length - inset, input.length )$/;"	V
safeEquals	Http.scala	/^      def safeEquals(a: String, b: String) = {$/;"	m
safeExpression	ScalaTemplateCompiler.scala	/^      def safeExpression: Parser[Display] = {$/;"	m
safeFileName	ContentTypes.scala	/^          val safeFileName = fileName.split('\\\\').takeRight(1).mkString$/;"	V
sb	Templates.scala	/^    val sb = new StringBuilder(text.length)$/;"	V
sbinary.DefaultProtocol.StringFormat	PlayCommands.scala	/^import sbinary.DefaultProtocol.StringFormat$/;"	i
sbt	PlayAssetsCompiler.scala	/^package sbt$/;"	p
sbt	PlayCommands.scala	/^package sbt$/;"	p
sbt	PlayEclipse.scala	/^package sbt$/;"	p
sbt	PlayExceptions.scala	/^package sbt$/;"	p
sbt	PlayJvm.scala	/^package sbt$/;"	p
sbt	PlayKeys.scala	/^package sbt$/;"	p
sbt	PlayLogger.scala	/^package sbt$/;"	p
sbt	PlayPositionMapper.scala	/^package sbt$/;"	p
sbt	PlayProject.scala	/^package sbt$/;"	p
sbt	PlayReloader.scala	/^package sbt$/;"	p
sbt	PlaySettings.scala	/^package sbt$/;"	p
sbt	PlayTestListener.scala	/^package sbt$/;"	p
sbt.Logger.m2o	PlayLogger.scala	/^    import sbt.Logger.m2o$/;"	i
sbt.NameFilter._	PlayCommands.scala	/^    import sbt.NameFilter._$/;"	i
sbt.PlayExceptions.AssetCompilationException	CoffeescriptCompiler.scala	/^import sbt.PlayExceptions.AssetCompilationException$/;"	i
sbt.PlayExceptions.AssetCompilationException	JavascriptCompiler.scala	/^import sbt.PlayExceptions.AssetCompilationException$/;"	i
sbt.PlayExceptions.AssetCompilationException	LessCompiler.scala	/^import sbt.PlayExceptions.AssetCompilationException$/;"	i
sbt._	PlayJvm.scala	/^import sbt._$/;"	i
sbt.{Project=>_,_}	Project.scala	/^import sbt.{Project=>_,_}$/;"	i
sbtLoader	PlayCommands.scala	/^    val sbtLoader = this.getClass.getClassLoader$/;"	V
sbtLoader	PlayReloader.scala	/^          val sbtLoader = this.getClass.getClassLoader.getParent.asInstanceOf[java.net.URLClassLoader]$/;"	V
sc	csrf.scala	/^          lazy val sc = Cookies.encode(Seq(Cookie(Session.COOKIE_NAME, Session.encode(newSession.data))))$/;"	V
sc	csrf.scala	/^          lazy val sc = Cookies.encode(Seq(Cookie(c, token.value)))$/;"	V
scala.Console._	Color.scala	/^  import scala.Console._$/;"	i
scala.Console._	Console.scala	/^  import scala.Console._$/;"	i
scala.Console._	PlayCommands.scala	/^        import scala.Console._$/;"	i
scala.Console.{ GREEN, RESET }	PlayJvm.scala	/^import scala.Console.{ GREEN, RESET }$/;"	i
scala.Predef._	OpenIDSpec.scala	/^import scala.Predef._$/;"	i
scala.annotation._	Binders.scala	/^import scala.annotation._$/;"	i
scala.annotation._	ContentTypeOf.scala	/^import scala.annotation._$/;"	i
scala.annotation._	Forms.scala	/^import scala.annotation._$/;"	i
scala.annotation._	Http.scala	/^  import scala.annotation._$/;"	i
scala.annotation._	Writeable.scala	/^import scala.annotation._$/;"	i
scala.annotation.implicitNotFound	Format.scala	/^import scala.annotation.implicitNotFound$/;"	i
scala.annotation.implicitNotFound	Reads.scala	/^import scala.annotation.implicitNotFound$/;"	i
scala.annotation.implicitNotFound	Writes.scala	/^import scala.annotation.implicitNotFound$/;"	i
scala.annotation.tailrec	Console.scala	/^import scala.annotation.tailrec$/;"	i
scala.annotation.tailrec	JsValue.scala	/^import scala.annotation.tailrec$/;"	i
scala.annotation.tailrec	PlayCommands.scala	/^import scala.annotation.tailrec$/;"	i
scala.annotation.tailrec	ScalaTemplateCompiler.scala	/^  import scala.annotation.tailrec$/;"	i
scala.collection.JavaConversions._	DynamicFormSpec.scala	/^import scala.collection.JavaConversions._$/;"	i
scala.collection.JavaConversions._	JavascriptCompiler.scala	/^    import scala.collection.JavaConversions._$/;"	i
scala.collection.JavaConversions._	OpenID.scala	/^    import scala.collection.JavaConversions._$/;"	i
scala.collection.JavaConverters	JavaPromise.scala	/^import scala.collection.JavaConverters$/;"	i
scala.collection.JavaConverters._	Application.scala	/^    import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	Application.scala	/^import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	ApplicationProvider.scala	/^                import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	Binders.scala	/^import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	CoffeescriptCompiler.scala	/^  import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	Configuration.scala	/^import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	ContentTypes.scala	/^      import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	FakeRuntime.scala	/^      import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	FormSpec.scala	/^import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	Http.scala	/^    import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	JavaHelpers.scala	/^import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	JavaParsers.scala	/^import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	JavaResults.scala	/^import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	JavaWebSocket.scala	/^import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	JavascriptCompiler.scala	/^    import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	JavascriptCompiler.scala	/^import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	LessCompiler.scala	/^  import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	Messages.scala	/^  import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	OAuth.scala	/^    import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	PartialValidationSpec.scala	/^import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	Play.scala	/^import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	PlayCommands.scala	/^import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	PlayDefaultUpstreamHandler.scala	/^                    import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	PlayDefaultUpstreamHandler.scala	/^import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	PlayReloader.scala	/^            import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	PlayReloader.scala	/^        import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	RequestBodyHandler.scala	/^import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	ScalaTemplate.scala	/^      import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	TemplateMagicForJava.scala	/^  import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	WS.scala	/^    import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	WebSocketHandler.scala	/^import scala.collection.JavaConverters._$/;"	i
scala.collection.JavaConverters._	csrf.scala	/^      import scala.collection.JavaConverters._$/;"	i
scala.collection._	JsValue.scala	/^import scala.collection._$/;"	i
scala.collection._	Promise.scala	/^import scala.collection._$/;"	i
scala.collection._	Reads.scala	/^import scala.collection._$/;"	i
scala.collection._	Writes.scala	/^import scala.collection._$/;"	i
scala.collection.concurrent._	ReflectionsCache.scala	/^  import scala.collection.concurrent._$/;"	i
scala.collection.generic.CanBuildFrom	Promise.scala	/^import scala.collection.generic.CanBuildFrom$/;"	i
scala.collection.immutable.Queue	Concurrent.scala	/^    import scala.collection.immutable.Queue$/;"	i
scala.collection.immutable.Stack	JsValue.scala	/^import scala.collection.immutable.Stack$/;"	i
scala.collection.mutable	PlayLogger.scala	/^  import scala.collection.mutable$/;"	i
scala.collection.mutable.Builder	Promise.scala	/^import scala.collection.mutable.Builder$/;"	i
scala.collection.mutable.ListBuffer	JUnitXmlTestListener.scala	/^import scala.collection.mutable.ListBuffer$/;"	i
scala.collection.mutable.ListBuffer	RoutesCompiler.scala	/^      import scala.collection.mutable.ListBuffer$/;"	i
scala.collection.mutable.ListBuffer	ScalaTemplateCompiler.scala	/^        import scala.collection.mutable.ListBuffer$/;"	i
scala.collection.mutable.ListBuffer	ScalaTemplateCompiler.scala	/^    import scala.collection.mutable.ListBuffer$/;"	i
scala.collection.mutable._	ContentTypes.scala	/^  import scala.collection.mutable._$/;"	i
scala.collection.mutable.{ HashMap }	FormUrlEncodedParser.scala	/^    import scala.collection.mutable.{ HashMap }$/;"	i
scala.concurrent.Await	ApplicationProvider.scala	/^import scala.concurrent.Await$/;"	i
scala.concurrent.Await	DiscoverySpec.scala	/^import scala.concurrent.Await$/;"	i
scala.concurrent.Await	OpenIDSpec.scala	/^import scala.concurrent.Await$/;"	i
scala.concurrent.ExecutionContext	Execution.scala	/^import scala.concurrent.ExecutionContext$/;"	i
scala.concurrent.ExecutionContext.Implicits.global	ConcurrentSpec.scala	/^import scala.concurrent.ExecutionContext.Implicits.global$/;"	i
scala.concurrent.ExecutionContext.Implicits.global	EnumerateesSpec.scala	/^import scala.concurrent.ExecutionContext.Implicits.global$/;"	i
scala.concurrent.ExecutionContext.Implicits.global	EnumeratorsSpec.scala	/^import scala.concurrent.ExecutionContext.Implicits.global$/;"	i
scala.concurrent.ExecutionContext.Implicits.global	Helpers.scala	/^import scala.concurrent.ExecutionContext.Implicits.global$/;"	i
scala.concurrent.ExecutionContext.Implicits.global	ParsingSpec.scala	/^import scala.concurrent.ExecutionContext.Implicits.global$/;"	i
scala.concurrent.ExecutionContext.Implicits.global	PromiseSpec.scala	/^import scala.concurrent.ExecutionContext.Implicits.global$/;"	i
scala.concurrent.Future	Action.scala	/^import scala.concurrent.Future$/;"	i
scala.concurrent.Future	ApplicationProvider.scala	/^import scala.concurrent.Future$/;"	i
scala.concurrent.Future	Concurrent.scala	/^import scala.concurrent.Future$/;"	i
scala.concurrent.Future	Enumeratee.scala	/^import scala.concurrent.Future$/;"	i
scala.concurrent.Future	Iteratee.scala	/^import scala.concurrent.Future$/;"	i
scala.concurrent.Future	OpenID.scala	/^import scala.concurrent.Future$/;"	i
scala.concurrent.Future	RequestBodyHandler.scala	/^import scala.concurrent.Future$/;"	i
scala.concurrent.Future	WebSocket.scala	/^import scala.concurrent.Future$/;"	i
scala.concurrent.Promise	Concurrent.scala	/^import scala.concurrent.Promise$/;"	i
scala.concurrent._	EnumerateesSpec.scala	/^import scala.concurrent._$/;"	i
scala.concurrent.duration.Duration	DiscoverySpec.scala	/^import scala.concurrent.duration.Duration$/;"	i
scala.concurrent.duration.Duration	EnumerateesSpec.scala	/^import scala.concurrent.duration.Duration$/;"	i
scala.concurrent.duration.Duration	NettyPromise.scala	/^import scala.concurrent.duration.Duration$/;"	i
scala.concurrent.duration.Duration	OpenIDSpec.scala	/^import scala.concurrent.duration.Duration$/;"	i
scala.concurrent.duration.Duration	Promise.scala	/^import scala.concurrent.duration.Duration$/;"	i
scala.concurrent.duration._	ApplicationProvider.scala	/^import scala.concurrent.duration._$/;"	i
scala.concurrent.duration._	Server.scala	/^import scala.concurrent.duration._$/;"	i
scala.concurrent.duration.{Duration}	Akka.scala	/^import scala.concurrent.duration.{Duration}$/;"	i
scala.concurrent.stm.Ref	Concurrent.scala	/^    import scala.concurrent.stm.Ref$/;"	i
scala.concurrent.stm._	Concurrent.scala	/^    import scala.concurrent.stm._$/;"	i
scala.concurrent.stm._	Enumerator.scala	/^    import scala.concurrent.stm._$/;"	i
scala.concurrent.stm._	Promise.scala	/^    import scala.concurrent.stm._$/;"	i
scala.concurrent.stm._	RequestBodyHandler.scala	/^    import scala.concurrent.stm._$/;"	i
scala.concurrent.stm._	WebSocketHandler.scala	/^import scala.concurrent.stm._$/;"	i
scala.concurrent.{ ExecutionContext, CanAwait }	NettyPromise.scala	/^import scala.concurrent.{ ExecutionContext, CanAwait }$/;"	i
scala.concurrent.{ Future, Await }	Akka.scala	/^import scala.concurrent.{ Future, Await }$/;"	i
scala.concurrent.{ Future, ExecutionContext }	JavaPromise.scala	/^import scala.concurrent.{ Future, ExecutionContext }$/;"	i
scala.concurrent.{ Future, ExecutionContext }	Results.scala	/^import scala.concurrent.{ Future, ExecutionContext }$/;"	i
scala.concurrent.{ Future, Promise }	Enumerator.scala	/^import scala.concurrent.{ Future, Promise }$/;"	i
scala.concurrent.{CanAwait,ExecutionContext}	Akka.scala	/^import scala.concurrent.{CanAwait,ExecutionContext}$/;"	i
scala.concurrent.{Future, ExecutionContext}	Promise.scala	/^import scala.concurrent.{Future, ExecutionContext}$/;"	i
scala.concurrent.{Future, Promise}	WS.scala	/^import scala.concurrent.{Future, Promise}$/;"	i
scala.io.Source	JavascriptCompiler.scala	/^import scala.io.Source$/;"	i
scala.language.existentials	Form.scala	/^import scala.language.existentials$/;"	i
scala.language.existentials	JavaAction.scala	/^import scala.language.existentials$/;"	i
scala.language.higherKinds	Promise.scala	/^import scala.language.higherKinds$/;"	i
scala.language.higherKinds	Reads.scala	/^import scala.language.higherKinds$/;"	i
scala.language.higherKinds	Util.scala	/^import scala.language.higherKinds$/;"	i
scala.language.implicitConversions	Json.scala	/^  import scala.language.implicitConversions$/;"	i
scala.language.implicitConversions	Utils.scala	/^  import scala.language.implicitConversions$/;"	i
scala.language.postfixOps	Messages.scala	/^import scala.language.postfixOps$/;"	i
scala.language.postfixOps	Server.scala	/^import scala.language.postfixOps$/;"	i
scala.language.postfixOps	SqlStatementParser.scala	/^import scala.language.postfixOps$/;"	i
scala.language.reflectiveCalls	Comet.scala	/^import scala.language.reflectiveCalls$/;"	i
scala.language.reflectiveCalls	ContentTypes.scala	/^import scala.language.reflectiveCalls$/;"	i
scala.language.reflectiveCalls	DB.scala	/^import scala.language.reflectiveCalls$/;"	i
scala.language.reflectiveCalls	Enumeratee.scala	/^import scala.language.reflectiveCalls$/;"	i
scala.language.reflectiveCalls	EventSource.scala	/^import scala.language.reflectiveCalls$/;"	i
scala.language.reflectiveCalls	Helpers.scala	/^import scala.language.reflectiveCalls$/;"	i
scala.language.reflectiveCalls	JavaResults.scala	/^import scala.language.reflectiveCalls$/;"	i
scala.language.reflectiveCalls	JsMacroImpl.scala	/^import scala.language.reflectiveCalls$/;"	i
scala.language.reflectiveCalls	Json.scala	/^import scala.language.reflectiveCalls$/;"	i
scala.language.reflectiveCalls	PlayDefaultUpstreamHandler.scala	/^import scala.language.reflectiveCalls$/;"	i
scala.language.reflectiveCalls	WebSocketHandler.scala	/^import scala.language.reflectiveCalls$/;"	i
scala.language.reflectiveCalls	csrf.scala	/^  import scala.language.reflectiveCalls$/;"	i
scala.language.{postfixOps,reflectiveCalls}	Anorm.scala	/^import scala.language.{postfixOps,reflectiveCalls}$/;"	i
scala.reflect.ClassTag	Writes.scala	/^import scala.reflect.ClassTag$/;"	i
scala.reflect.Manifest	Anorm.scala	/^  import scala.reflect.Manifest$/;"	i
scala.reflect.macros.Context	JsMacroImpl.scala	/^import scala.reflect.macros.Context$/;"	i
scala.reflect.macros.Context	Json.scala	/^  import scala.reflect.macros.Context$/;"	i
scala.sys.process._	CoffeescriptCompiler.scala	/^    import scala.sys.process._$/;"	i
scala.sys.process._	JavascriptCompiler.scala	/^    import scala.sys.process._$/;"	i
scala.tools.nsc.Global	TemplateCompilerSpec.scala	/^    import scala.tools.nsc.Global$/;"	i
scala.tools.nsc.Settings	ScalaTemplateCompiler.scala	/^      import scala.tools.nsc.Settings$/;"	i
scala.tools.nsc.Settings	TemplateCompilerSpec.scala	/^    import scala.tools.nsc.Settings$/;"	i
scala.tools.nsc.interactive.{ Response, Global }	ScalaTemplateCompiler.scala	/^      import scala.tools.nsc.interactive.{ Response, Global }$/;"	i
scala.tools.nsc.io.AbstractFile	ScalaTemplateCompiler.scala	/^      import scala.tools.nsc.io.AbstractFile$/;"	i
scala.tools.nsc.io.AbstractFile	TemplateCompilerSpec.scala	/^    import scala.tools.nsc.io.AbstractFile$/;"	i
scala.tools.nsc.reporters.ConsoleReporter	ScalaTemplateCompiler.scala	/^      import scala.tools.nsc.reporters.ConsoleReporter$/;"	i
scala.tools.nsc.reporters.ConsoleReporter	TemplateCompilerSpec.scala	/^    import scala.tools.nsc.reporters.ConsoleReporter$/;"	i
scala.tools.nsc.util.{ SourceFile, Position, BatchSourceFile }	ScalaTemplateCompiler.scala	/^      import scala.tools.nsc.util.{ SourceFile, Position, BatchSourceFile }$/;"	i
scala.tools.nsc.util.{ SourceFile, Position, BatchSourceFile }	TemplateCompilerSpec.scala	/^    import scala.tools.nsc.util.{ SourceFile, Position, BatchSourceFile }$/;"	i
scala.util.Try	Akka.scala	/^import scala.util.Try$/;"	i
scala.util._	NettyPromise.scala	/^import scala.util._$/;"	i
scala.util.control.Exception	Server.scala	/^    import scala.util.control.Exception$/;"	i
scala.util.control.Exception._	Anorm.scala	/^  import scala.util.control.Exception._$/;"	i
scala.util.control.Exception._	Console.scala	/^      import scala.util.control.Exception._$/;"	i
scala.util.control.Exception._	Evolutions.scala	/^import scala.util.control.Exception._$/;"	i
scala.util.control.Exception._	JavascriptCompiler.scala	/^    import scala.util.control.Exception._$/;"	i
scala.util.control.Exception._	JsPathSpec.scala	/^import scala.util.control.Exception._$/;"	i
scala.util.control.Exception._	JsValue.scala	/^  import scala.util.control.Exception._$/;"	i
scala.util.control.Exception._	JsonRichSpec.scala	/^import scala.util.control.Exception._$/;"	i
scala.util.control.Exception._	JsonSpec.scala	/^import scala.util.control.Exception._$/;"	i
scala.util.control.Exception._	JsonTransSpec.scala	/^import scala.util.control.Exception._$/;"	i
scala.util.control.Exception._	JsonValidSpec.scala	/^import scala.util.control.Exception._$/;"	i
scala.util.control.Exception._	OpenID.scala	/^import scala.util.control.Exception._$/;"	i
scala.util.control.Exception._	PlayAssetsCompiler.scala	/^      import scala.util.control.Exception._$/;"	i
scala.util.control.Exception._	Reads.scala	/^    import scala.util.control.Exception._$/;"	i
scala.util.control.Exception._	Writes.scala	/^    import scala.util.control.Exception._$/;"	i
scala.util.control.NonFatal	Application.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.control.NonFatal	ApplicationProvider.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.control.NonFatal	Assets.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.control.NonFatal	Configuration.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.control.NonFatal	DB.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.control.NonFatal	Evolutions.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.control.NonFatal	FakeKeyStore.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.control.NonFatal	GlobalSettings.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.control.NonFatal	Http.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.control.NonFatal	Logger.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.control.NonFatal	Messages.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.control.NonFatal	NettyServer.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.control.NonFatal	Play.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.control.NonFatal	PlayDefaultUpstreamHandler.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.control.NonFatal	Promise.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.control.NonFatal	Server.scala	/^import scala.util.control.NonFatal$/;"	i
scala.util.matching.Regex	OpenID.scala	/^import scala.util.matching.Regex$/;"	i
scala.util.matching._	Messages.scala	/^import scala.util.matching._$/;"	i
scala.util.matching._	PathParts.scala	/^import scala.util.matching._$/;"	i
scala.util.matching._	Router.scala	/^import scala.util.matching._$/;"	i
scala.util.matching._	RoutesCompiler.scala	/^import scala.util.matching._$/;"	i
scala.util.parsing.combinator.JavaTokenParsers	ScalaTemplateCompiler.scala	/^    import scala.util.parsing.combinator.JavaTokenParsers$/;"	i
scala.util.parsing.combinator._	Messages.scala	/^import scala.util.parsing.combinator._$/;"	i
scala.util.parsing.combinator._	PathParts.scala	/^import scala.util.parsing.combinator._$/;"	i
scala.util.parsing.combinator._	Router.scala	/^import scala.util.parsing.combinator._$/;"	i
scala.util.parsing.combinator._	RoutesCompiler.scala	/^import scala.util.parsing.combinator._$/;"	i
scala.util.parsing.combinator._	SqlStatementParser.scala	/^import scala.util.parsing.combinator._$/;"	i
scala.util.parsing.input.CharSequenceReader	ScalaTemplateCompiler.scala	/^    import scala.util.parsing.input.CharSequenceReader$/;"	i
scala.util.parsing.input.CharSequenceReader	TemplateParserSpec.scala	/^    import scala.util.parsing.input.CharSequenceReader$/;"	i
scala.util.parsing.input.OffsetPosition	ScalaTemplateCompiler.scala	/^import scala.util.parsing.input.OffsetPosition$/;"	i
scala.util.parsing.input.Positional	ScalaTemplateCompiler.scala	/^    import scala.util.parsing.input.Positional$/;"	i
scala.util.parsing.input._	Messages.scala	/^import scala.util.parsing.input._$/;"	i
scala.util.parsing.input._	PathParts.scala	/^import scala.util.parsing.input._$/;"	i
scala.util.parsing.input._	Router.scala	/^import scala.util.parsing.input._$/;"	i
scala.util.parsing.input._	RoutesCompiler.scala	/^import scala.util.parsing.input._$/;"	i
scala.util.parsing.input.{ Position, OffsetPosition, NoPosition }	ScalaTemplateCompiler.scala	/^  import scala.util.parsing.input.{ Position, OffsetPosition, NoPosition }$/;"	i
scala.util.{ Try, Success, Failure }	Enumerator.scala	/^import scala.util.{ Try, Success, Failure }$/;"	i
scala.util.{Try, Failure, Success}	Concurrent.scala	/^import scala.util.{Try, Failure, Success}$/;"	i
scala.xml._	ContentTypes.scala	/^import scala.xml._$/;"	i
scala.xml._	JavaParsers.scala	/^import scala.xml._$/;"	i
scala.xml._	PlayCommands.scala	/^    import scala.xml._$/;"	i
scala.xml._	PlayEclipse.scala	/^    import scala.xml._$/;"	i
scala.xml._	WS.scala	/^  import scala.xml._$/;"	i
scala.xml.transform.RewriteRule	PlayEclipse.scala	/^    import scala.xml.transform.RewriteRule$/;"	i
scala.xml.{ Elem, Node, XML }	JUnitXmlTestListener.scala	/^import scala.xml.{ Elem, Node, XML }$/;"	i
scalaBlock	ScalaTemplateCompiler.scala	/^      def scalaBlock: Parser[Simple] = {$/;"	m
scalaBlockChained	ScalaTemplateCompiler.scala	/^      def scalaBlockChained: Parser[Block] = {$/;"	m
scalaBlockDisplayed	ScalaTemplateCompiler.scala	/^      def scalaBlockDisplayed: Parser[Display] = {$/;"	m
scalaClasspath	PlayJvm.scala	/^ * val scalaClasspath = scalaJars.map(_.getAbsolutePath).mkString(JFile.pathSeparator)$/;"	V
scalaCode	ScalaTemplateCompiler.scala	/^      val scalaCode = new StringBuilder$/;"	V
scalaGlobal	Application.scala	/^  lazy private val scalaGlobal: GlobalSettings = try {$/;"	V
scalaLib	PlayEclipse.scala	/^          val scalaLib = classpath.filter(_.data.getAbsolutePath.contains("scala-library.jar")).headOption.map(_.data.getAbsolutePath).getOrElse(throw new RuntimeException("could not find scala-library.jar"))$/;"	V
scalaObjectSource	ScalaTemplateCompiler.scala	/^          val scalaObjectSource = Class.forName("scala.ScalaObject").getProtectionDomain.getCodeSource$/;"	V
scalaObjectSource	TemplateCompilerSpec.scala	/^      val scalaObjectSource = Class.forName("scala.ScalaObject").getProtectionDomain.getCodeSource$/;"	V
scalaOptions	PlayJvm.scala	/^ * val scalaOptions = options.scala(mainClass, args)$/;"	V
scalaReservedWords	RoutesCompiler.scala	/^  val scalaReservedWords = List($/;"	V
scalaRoutes	PlayCommands.scala	/^    val scalaRoutes = (generatedDir ** "routes_*.scala")$/;"	V
scalar	SqlParser.scala	/^  def scalar[T](implicit transformer: Column[T]): RowParser[T] = RowParser[T] { row =>$/;"	m
scalax.file._	Application.scala	/^    import scalax.file._$/;"	i
scalax.file._	ApplicationProvider.scala	/^        import scalax.file._$/;"	i
scalax.file._	CoffeescriptCompiler.scala	/^  import scalax.file._$/;"	i
scalax.file._	Console.scala	/^import scalax.file._$/;"	i
scalax.file._	Evolutions.scala	/^import scalax.file._$/;"	i
scalax.file._	Files.scala	/^import scalax.file._$/;"	i
scalax.file._	JavascriptCompiler.scala	/^    import scalax.file._$/;"	i
scalax.file._	JavascriptCompiler.scala	/^import scalax.file._$/;"	i
scalax.file._	LessCompiler.scala	/^  import scalax.file._$/;"	i
scalax.file._	Messages.scala	/^  import scalax.file._$/;"	i
scalax.file._	RoutesCompiler.scala	/^  import scalax.file._$/;"	i
scalax.file._	ScalaTemplateCompiler.scala	/^  import scalax.file._$/;"	i
scalax.io.JavaConverters._	Application.scala	/^    import scalax.io.JavaConverters._$/;"	i
scalax.io.JavaConverters._	Configuration.scala	/^    import scalax.io.JavaConverters._$/;"	i
scalax.io.JavaConverters._	Enumerator.scala	/^  import scalax.io.JavaConverters._$/;"	i
scalax.io.JavaConverters._	Evolutions.scala	/^import scalax.io.JavaConverters._$/;"	i
scalax.io.JavaConverters._	Messages.scala	/^  import scalax.io.JavaConverters._$/;"	i
scalax.io._	Files.scala	/^import scalax.io._$/;"	i
scalax.io.{ Resource }	Assets.scala	/^import scalax.io.{ Resource }$/;"	i
scan	Iteratee.scala	/^    def scan(previousMatches: List[MatchInfo[Array[Byte]]], piece: Array[Byte], startScan: Int): (List[MatchInfo[Array[Byte]]], Array[Byte]) = {$/;"	m
scanLeft	Enumeratee.scala	/^  def scanLeft[From] = new {$/;"	m
scheme	OpenID.scala	/^      def scheme(uri:URI) = Option(uri.getScheme) getOrElse schemeForPort(uri.getPort)$/;"	m
schemeForPort	OpenID.scala	/^      def schemeForPort(p: Int) = p match {$/;"	m
scope	CoffeescriptCompiler.scala	/^    val scope = ctx.initStandardObjects(global)$/;"	V
scope	JavascriptCompiler.scala	/^    val scope = ctx.initStandardObjects(global)$/;"	V
scope	LessCompiler.scala	/^    val scope = ctx.initStandardObjects(global)$/;"	V
screen	PlayLogger.scala	/^  val screen = defaultScreen$/;"	V
script	Evolutions.scala	/^          val script = Evolutions.evolutionScript(dbApi, app.path, app.classloader, db)$/;"	V
script	Evolutions.scala	/^          val script = evolutionScript(api, app.path, app.classloader, db)$/;"	V
script	Evolutions.scala	/^        val script = state match {$/;"	V
script	Evolutions.scala	/^      val script = Evolutions.evolutionScript(db.api, path, db.getClass.getClassLoader, dbName)$/;"	V
script	Evolutions.scala	/^    val script = Evolutions.evolutionScript(dbApi, appPath, classloader, dbName)$/;"	V
scriptStatements	ScriptSpec.scala	/^      val scriptStatements = ScriptSansEvolution(s"""$/;"	V
scripts	PlayCommands.scala	/^    val scripts = Seq(start -> (packageName + "\/start"))$/;"	V
search	Iteratee.scala	/^  def search(needle: Array[Byte]): Enumeratee[Array[Byte], MatchInfo[Array[Byte]]] = new Enumeratee[Array[Byte], MatchInfo[Array[Byte]]] {$/;"	m
secure	Http.scala	/^    def secure = false$/;"	m
self	JsPath.scala	/^  private val self = this$/;"	V
sendFile	Results.scala	/^    def sendFile(content: java.io.File, inline: Boolean = false, fileName: java.io.File => String = _.getName, onClose: () => Unit = () => ()): SimpleResult[Array[Byte]] = {$/;"	m
sendHandler	Server.scala	/^    def sendHandler: Either[Throwable, (Handler, Application)] = {$/;"	m
sentence	Messages.scala	/^    def sentence = (comment | positioned(message)) <~ newLine$/;"	m
sentence	RoutesCompiler.scala	/^    def sentence: Parser[Product with Serializable] = namedError((comment | positioned(include) | positioned(route)), "HTTP Verb (GET, POST, ...), include (->) or comment (#) expected") <~ (newLine | EOF)$/;"	m
separator	OpenID.scala	/^      val separator = if (server.url.contains("?")) "&" else "?"$/;"	V
separator	PlayCommands.scala	/^          val separator = "+-%s-+-%s-+-%s-+".format($/;"	V
separator	RoutesCompiler.scala	/^    def separator: Parser[String] = namedError(whiteSpace, "Whitespace expected")$/;"	m
seq	EnumeratorsSpec.scala	/^    val seq = List(1, 2, 3, 7, 42, 666)$/;"	V
seq	Forms.scala	/^  def seq[A](mapping: Mapping[A]): Mapping[Seq[A]] = RepeatedMapping(mapping).transform(_.toSeq, _.toList)$/;"	m
seq	JsConstraints.scala	/^  def seq[A](implicit reads:Reads[A]): Reads[Seq[A]] = Reads.traversableReads[Seq, A]$/;"	m
seq	JsConstraints.scala	/^  def seq[A](implicit writes:Writes[A]): Writes[Seq[A]] = Writes.traversableWrites[A]$/;"	m
sequence	JavaPromise.scala	/^  def sequence[A](promises: JList[F.Promise[_ <: A]]): Future[JList[A]] = {$/;"	m
sequence	Promise.scala	/^  def sequence[A](in: Option[Future[A]]): Future[Option[A]] = {$/;"	m
sequence	Promise.scala	/^  def sequence[B, M[_]](in: M[Future[B]])(implicit toTraversableLike: M[Future[B]] => TraversableLike[Future[B], M[Future[B]]], cbf: CanBuildFrom[M[Future[B]], B, M[B]]): Future[M[B]] = {$/;"	m
sequence	SqlParser.scala	/^    def sequence(results: SqlResult[List[A]], rows: Stream[Row]): SqlResult[List[A]] = {$/;"	m
sequenceEither	Promise.scala	/^  def sequenceEither[A, B](e: Either[A, Future[B]]): Future[Either[A, B]] = e.fold(r => Promise.pure(Left(r)), _.map(Right(_))(internalContext))$/;"	m
sequenceEither1	Promise.scala	/^  def sequenceEither1[A, B](e: Either[Future[A], Future[B]]): Future[Either[A, B]] = e.fold(_.map(Left(_))(internalContext), _.map(Right(_))(internalContext))$/;"	m
sequenceOption	Promise.scala	/^  def sequenceOption[A](o: Option[Future[A]]): Future[Option[A]] = o.map(_.map(Some(_))(internalContext)).getOrElse(Promise.pure(None))$/;"	m
ser	JsValue.scala	/^    val ser: Object = if (classOf[JsValue].isAssignableFrom(beanDesc.getBeanClass)) {$/;"	V
serialize	Http.scala	/^    def serialize(flash: Flash) = flash.data$/;"	m
serialize	Http.scala	/^    def serialize(session: Session) = session.data$/;"	m
serialize	JsValue.scala	/^  def serialize(value: JsValue, json: JsonGenerator, provider: SerializerProvider) {$/;"	m
server	NettyServer.scala	/^      val server = new NettyServer($/;"	V
server	OpenID.scala	/^        val server: Future[OpenIDServer] = discovery.discoverServer(id)$/;"	V
server	PlayCommands.scala	/^      val server = mainDev.invoke(null, reloader, port: java.lang.Integer).asInstanceOf[play.core.server.ServerWithStop]$/;"	V
server	Selenium.scala	/^  private var server: play.core.server.NettyServer = _$/;"	v
server.Server	PlayDefaultUpstreamHandler.scala	/^import server.Server$/;"	i
server.Server	RequestBodyHandler.scala	/^import server.Server$/;"	i
serverRegex	OpenID.scala	/^    private val serverRegex = new Regex( """<link[^>]+openid[.]server[^>]+>""")$/;"	V
serverUrl	OpenID.scala	/^      val serverUrl: Option[String] = providerRegex.findFirstIn(response.body)$/;"	V
serviceTypeId	OpenID.scala	/^    private val serviceTypeId = Seq("http:\/\/specs.openid.net\/auth\/2.0\/server", "http:\/\/specs.openid.net\/auth\/2.0\/signon", "http:\/\/openid.net\/server\/1.0", "http:\/\/openid.net\/server\/1.1")$/;"	V
session	Helpers.scala	/^  def session(of: Result): Session = Session.decodeFromCookie(cookies(of).get(Session.COOKIE_NAME))$/;"	m
session	Http.scala	/^    lazy val session: Session = Session.decodeFromCookie(cookies.get(Session.COOKIE_NAME))$/;"	V
session	csrf.scala	/^           val session = Cookies(r.header.headers.get("Set-Cookie"))$/;"	V
set	Anorm.scala	/^    def set(s: java.sql.PreparedStatement, index: Int, aValue: Option[A]): Unit = {$/;"	m
set	Anorm.scala	/^    def set(s: java.sql.PreparedStatement, index: Int, aValue: Pk[A]): Unit =$/;"	m
set	Anorm.scala	/^    def set(s: java.sql.PreparedStatement, index: Int, aValue: T): Unit = setAny(index, aValue, s)$/;"	m
set	Anorm.scala	/^    def set(s: java.sql.PreparedStatement, index: Int, aValue: java.util.Date): Unit = s.setTimestamp(index, new java.sql.Timestamp(aValue.getTime()))$/;"	m
set	Anorm.scala	/^  def set(s: java.sql.PreparedStatement, index: Int) = statementSetter.set(s, index, aValue)$/;"	m
set	Cache.scala	/^    def set(key: String, value: Any, expiration: Int) {$/;"	m
set	Cache.scala	/^  def set(key: String, value: Any, expiration: Int = 0)(implicit app: Application) = {$/;"	m
set	Cache.scala	/^  def set(key: String, value: Any, expiration: Int)$/;"	m
set	JsConstraints.scala	/^  def set[A](implicit reads:Reads[A]): Reads[Set[A]] = Reads.traversableReads[Set, A]$/;"	m
set	JsConstraints.scala	/^  def set[A](implicit writes:Writes[A]): Writes[Set[A]] = Writes.traversableWrites[A]$/;"	m
set	JsPath.scala	/^  def set(json: JsValue, transform: JsValue => JsValue): JsValue = json match {$/;"	m
set	JsPath.scala	/^  def set(json: JsValue, transform: JsValue => JsValue): JsValue$/;"	m
setAutoCommit	DB.scala	/^  def setAutoCommit(autoCommit: Boolean) { connection.setAutoCommit(autoCommit) }$/;"	m
setCatalog	DB.scala	/^  def setCatalog(catalog: String) { connection.setCatalog(catalog) }$/;"	m
setClientInfo	DB.scala	/^  def setClientInfo(name: String, value: String) { connection.setClientInfo(name, value) }$/;"	m
setClientInfo	DB.scala	/^  def setClientInfo(properties: java.util.Properties) { connection.setClientInfo(properties) }$/;"	m
setContent	ScalaTemplateCompiler.scala	/^    def setContent(newContent: String) {$/;"	m
setCookieHeader	ResultsSpec.scala	/^      val setCookieHeader = Cookies.encode(Seq(Cookie("session", "items"), Cookie("preferences", "blue")))$/;"	V
setCookies	ResultsSpec.scala	/^      val setCookies = Cookies.decode(headers("Set-Cookie")).map(c => c.name -> c).toMap$/;"	V
setField	JsValue.scala	/^  def setField(fieldName: String) = KeyRead(content, fieldName)$/;"	m
setHeaders	WS.scala	/^    def setHeaders(hdrs: Map[String, Seq[String]]) = {$/;"	m
setHoldability	DB.scala	/^  def setHoldability(holdability: Int) { connection.setHoldability(holdability) }$/;"	m
setLevel	Application.scala	/^    val setLevel = (level: String) => level match {$/;"	V
setNetworkTimeout	DB.scala	/^  def setNetworkTimeout(executor: java.util.concurrent.Executor, milliseconds: Int) {$/;"	m
setPrefix	Router.scala	/^    def setPrefix(prefix: String)$/;"	m
setQueryString	WS.scala	/^    def setQueryString(queryString: Map[String, Seq[String]]) = {$/;"	m
setReadOnly	DB.scala	/^  def setReadOnly(readOnly: Boolean) { connection.setReadOnly(readOnly) }$/;"	m
setSavepoint	DB.scala	/^  def setSavepoint() = connection.setSavepoint()$/;"	m
setSavepoint	DB.scala	/^  def setSavepoint(name: String) = connection.setSavepoint(name)$/;"	m
setSchema	DB.scala	/^  def setSchema(schema: String) {$/;"	m
setTransactionIsolation	DB.scala	/^  def setTransactionIsolation(level: Int) { connection.setTransactionIsolation(level) }$/;"	m
setTypeMap	DB.scala	/^  def setTypeMap(map: java.util.Map[String, Class[_]]) { connection.setTypeMap(map) }$/;"	m
settings	PlayReloader.scala	/^      lazy val settings = {$/;"	V
settings	ScalaTemplateCompiler.scala	/^          val settings = new Settings$/;"	V
settings	TemplateCompilerSpec.scala	/^      val settings = new Settings$/;"	V
settingsDir	PlayEclipse.scala	/^    val settingsDir = new File(".settings")$/;"	V
setupMockRequest	OpenIDSpec.scala	/^  def setupMockRequest(queryString:Params = openIdResponse) = {$/;"	m
several	RoutesCompiler.scala	/^    def several[T](p: => Parser[T]): Parser[List[T]] = Parser { in =>$/;"	m
several	ScalaTemplateCompiler.scala	/^      def several[T](p: => Parser[T]): Parser[List[T]] = Parser { in =>$/;"	m
severity	PlayReloader.scala	/^                def severity = xsbti.Severity.Error$/;"	m
severity	PlayReloader.scala	/^            def severity = problem.severity$/;"	m
shCommand	PlayCommands.scala	/^  val shCommand = Command.args("sh", "<shell command>") { (state: State, args: Seq[String]) =>$/;"	V
sha1	Codecs.scala	/^  def sha1(bytes: Array[Byte]): String = {$/;"	m
sha1	Codecs.scala	/^  def sha1(text: String): String = sha1(text.getBytes)$/;"	m
shake	WebSocketHandshake.scala	/^  def shake(ctx: ChannelHandlerContext, req: HttpRequest): Unit = {$/;"	m
shaker	WebSocketHandshake.scala	/^    val shaker = factory.newHandshaker(req)$/;"	V
sharedClasses	PlayCommands.scala	/^        val sharedClasses = Seq($/;"	V
shim	PlayCommands.scala	/^      val shim = if (!requireJsShim.isEmpty) {"""mainConfigFile: """" + jsFolder + """\/""" + requireJsShim + """", """} else {""};$/;"	V
shutdownPool	DB.scala	/^  def shutdownPool(ds: DataSource) = {$/;"	m
shutdownPool	DB.scala	/^  def shutdownPool(ds: DataSource)$/;"	m
sign	Crypto.scala	/^  def sign(message: String): String = {$/;"	m
sign	Crypto.scala	/^  def sign(message: String, key: Array[Byte]): String = {$/;"	m
sign	WS.scala	/^    def sign(calc: SignatureCalculator): WSRequestHolder = this.copy(calc = Some(calc))$/;"	m
sign	WS.scala	/^  def sign(request: WS.WSRequest)$/;"	m
signedFields	OpenID.scala	/^    private lazy val signedFields = params.get("openid.signed") flatMap { _.headOption map { _.split(",") } } getOrElse (Array())$/;"	V
simpleCheck	JavascriptCompiler.scala	/^    val simpleCheck = simpleCompilerOptions.contains("rjs")$/;"	V
simpleExpr	ScalaTemplateCompiler.scala	/^        val simpleExpr: Parser[List[ScalaExpPart]] = positioned(methodCall ^^ { Simple(_) }) ~ several(expressionPart) ^^ {$/;"	V
simpleQuotes	SqlStatementParser.scala	/^  def simpleQuotes = ("'" + """([^'\\p{Cntrl}\\\\]|\\\\[\\\\\/bfnrt]|\\\\u[a-fA-F0-9]{4})*""" + "'").r$/;"	m
single	Anorm.scala	/^  def single()(implicit connection: java.sql.Connection): T = as(ResultSetParser.single(defaultParser))$/;"	m
single	Anorm.scala	/^  def single[A](rowParser: RowParser[A])(implicit connection: java.sql.Connection): A = as(ResultSetParser.single(rowParser))$/;"	m
single	Forms.scala	/^  def single[A1](a1: (String, Mapping[A1])): Mapping[(A1)] = mapping(a1)((a1: A1) => (a1))((t: (A1)) => Some(t))$/;"	m
single	SqlParser.scala	/^  def single = ResultSetParser.single(parent)$/;"	m
single	SqlParser.scala	/^  def single[A](p: RowParser[A]): ResultSetParser[A] = ResultSetParser {$/;"	m
singleComponentPathPart	RoutesCompiler.scala	/^    def singleComponentPathPart: Parser[DynamicPart] = (":" ~> identifier) ^^ {$/;"	m
singleOpt	Anorm.scala	/^  def singleOpt()(implicit connection: java.sql.Connection): Option[T] = as(ResultSetParser.singleOpt(defaultParser))$/;"	m
singleOpt	Anorm.scala	/^  def singleOpt[A](rowParser: RowParser[A])(implicit connection: java.sql.Connection): Option[A] = as(ResultSetParser.singleOpt(rowParser))$/;"	m
singleOpt	SqlParser.scala	/^  def singleOpt = ResultSetParser.singleOpt(parent)$/;"	m
singleOpt	SqlParser.scala	/^  def singleOpt[A](p: RowParser[A]): ResultSetParser[Option[A]] = ResultSetParser {$/;"	m
size	ContentTypes.scala	/^  def size: Long = {$/;"	m
size	JavaParsers.scala	/^          def size = rawBuffer.size$/;"	m
skeySpec	Crypto.scala	/^    val skeySpec = new SecretKeySpec(raw, "AES")$/;"	V
skipToEof	Iteratee.scala	/^  def skipToEof[E]: Iteratee[E, Unit] = {$/;"	m
slowIteratee	ConcurrentSpec.scala	/^      val slowIteratee = Iteratee.flatten(timeout(Cont[Long,List[Long]]{case Input.El(e) => Done(List(e),Input.Empty)}, Duration(100, MILLISECONDS)))$/;"	V
slowIteratee	ConcurrentSpec.scala	/^      val slowIteratee = Iteratee.flatten(timeout(Cont[Long,List[Long]]{case _ => Done(List(1),Input.Empty)}, Duration(1000, MILLISECONDS)))$/;"	V
slowIteratee	ConcurrentSpec.scala	/^      val slowIteratee = Iteratee.foldM(List[Long]()){ (s,e:Long) => timeout(s :+ e, Duration(100, MILLISECONDS)) }$/;"	V
socketIn	JavaWebSocket.scala	/^      val socketIn = new play.mvc.WebSocket.In[A]$/;"	V
socketOut	JavaWebSocket.scala	/^      val socketOut = new play.mvc.WebSocket.Out[A] {$/;"	V
source	Application.scala	/^        val source = sources.flatMap(_.sourceFor(e))$/;"	V
source	RoutesCompiler.scala	/^    val source = lines.headOption.filter(_.startsWith("\/\/ @SOURCE:")).map(m => Path.fromString(m.trim.drop(11)))$/;"	V
source	ScalaTemplateCompiler.scala	/^    def source: Option[File] = {$/;"	m
source2TemplateName	ScalaTemplateCompiler.scala	/^    def source2TemplateName(f: File, sourceDirectory: File, ext: String, suffix: String = "", topDirectory: String = "views", setExt: Boolean = true): String = {$/;"	m
sourceDir	TemplateCompilerSpec.scala	/^  val sourceDir = new File("src\/templates-compiler\/src\/test\/templates")$/;"	V
sourceFile	PlayLogger.scala	/^      def sourceFile() = Maybe.just(file)$/;"	m
sourceFile	PlayPositionMapper.scala	/^          val sourceFile = xsbti.Maybe.just(generatedSource.source.get)$/;"	V
sourceFile	PlayPositionMapper.scala	/^          val sourceFile = xsbti.Maybe.just(new File(generatedSource.source.get.path))$/;"	V
sourceFile	PlayReloader.scala	/^                  def sourceFile = xsbti.Maybe.just(file(error._1))$/;"	m
sourceFor	ApplicationProvider.scala	/^  def sourceFor(e: Throwable): Option[(File, Option[Int])] = {$/;"	m
sourceName	Application.scala	/^          def sourceName = source.map(_._1.getAbsolutePath).orNull$/;"	m
sourceName	Configuration.scala	/^      def sourceName = Option(origin.filename).orNull$/;"	m
sourceName	JavascriptCompiler.scala	/^    def sourceName = jsFile.getAbsolutePath$/;"	m
sourceName	Messages.scala	/^            def sourceName = messageSourceName$/;"	m
sourceName	PlayExceptions.scala	/^    def sourceName = problem.position.sourceFile.map(_.getAbsolutePath).orNull$/;"	m
sourceName	PlayExceptions.scala	/^    def sourceName = source.getAbsolutePath$/;"	m
sourceName	PlayExceptions.scala	/^    def sourceName = source.map(_.getAbsolutePath).orNull$/;"	m
sourceOf	ApplicationProvider.scala	/^                def sourceOf(className: String, line: Option[Int]) = {$/;"	m
sourceOf	ApplicationProvider.scala	/^  def sourceOf(className: String, line: Option[Int] = None): Option[(File, Option[Int])]$/;"	m
sourcePath	PlayLogger.scala	/^      def sourcePath() = Maybe.just(file.name)$/;"	m
sourcePath	PlayPositionMapper.scala	/^          val sourcePath = xsbti.Maybe.just(sourceFile.get.getCanonicalPath)$/;"	V
sourcePath	PlayReloader.scala	/^                  def sourcePath = xsbti.Maybe.just(error._1)$/;"	m
sourcePositionFilter	PlayLogger.scala	/^  val sourcePositionFilter = new PlaySourcePositionFilter(playPositionMapper)$/;"	V
sourcePrefix	PlayLogger.scala	/^    val sourcePrefix = m2o(pos.sourcePath).getOrElse("")$/;"	V
sources	Application.scala	/^  def sources: Option[SourceMapper]$/;"	m
sources	Application.scala	/^  override val sources: Option[SourceMapper],$/;"	V
sources	Fakes.scala	/^  override val sources = None$/;"	V
sourcesFinder	PlayCommands.scala	/^        val sourcesFinder = PathFinder { watched watchPaths s }$/;"	V
spaces	PlayAssetsCompiler.scala	/^        val spaces = (line: Seq[Char]).take(pos).map {$/;"	V
splitOnceAt	TraversableIteratee.scala	/^  def splitOnceAt[M,E](p: E => Boolean)(implicit traversableLike: M => scala.collection.TraversableLike[E, M]):Enumeratee[M,M] =  new CheckDone[M, M] {$/;"	m
splitted	Http.scala	/^          val splitted = data.split("-")$/;"	V
spoofedEndpoint	OpenIDSpec.scala	/^      val spoofedEndpoint = "http:\/\/evilhackerendpoint.com"$/;"	V
sql	Anorm.scala	/^  def sql(inSql: String): SqlQuery = {$/;"	m
sql	Evolutions.scala	/^  val sql: String$/;"	V
sqlDate	Forms.scala	/^  def sqlDate(pattern: String, timeZone: java.util.TimeZone = java.util.TimeZone.getDefault): Mapping[java.sql.Date] = of[java.sql.Date] as sqlDateFormat(pattern, timeZone)$/;"	m
sqlDate	Forms.scala	/^  val sqlDate: Mapping[java.sql.Date] = of[java.sql.Date]$/;"	V
sqlDateReads	Reads.scala	/^  def sqlDateReads(pattern: String, corrector: String => String = identity): Reads[java.sql.Date] = $/;"	m
sqlDateWrites	Writes.scala	/^  def sqlDateWrites(pattern: String): Writes[java.sql.Date] = new Writes[java.sql.Date] {$/;"	m
squareBrackets	ScalaTemplateCompiler.scala	/^      def squareBrackets: Parser[String] = {$/;"	m
src	PlayCommands.scala	/^    val src = inAllDependencies(ref, sourceDirectories in Compile, Project structure state).foldLeft(Seq.empty[File])(_ ++ _)$/;"	V
sslContext	NettyServer.scala	/^          val sslContext = SSLContext.getInstance("TLS")$/;"	V
sslContext	NettyServer.scala	/^    lazy val sslContext: Option[SSLContext] =  \/\/the sslContext should be reused on each connection$/;"	V
sslEngine	NettyServer.scala	/^            val sslEngine = ctxt.createSSLEngine$/;"	V
staged	PlayCommands.scala	/^    val staged = target \/ "staged"$/;"	V
start	JUnitXmlTestListener.scala	/^    val start = System.currentTimeMillis$/;"	V
start	Play.scala	/^  def start(app: Application) {$/;"	m
start	PlayCommands.scala	/^            val start = System.currentTimeMillis$/;"	V
start	PlayCommands.scala	/^    val start = target \/ "start"$/;"	V
started	Concurrent.scala	/^    val started = Ref(false)$/;"	V
state	Concurrent.scala	/^      val state: Ref[State] = Ref(Queueing(Queue[Input[E]](), 0))$/;"	V
state	Evolutions.scala	/^        val state = problem.getString("state")$/;"	V
statement	Anorm.scala	/^    val statement = getFilledStatement(connection, getGeneratedKeys)$/;"	V
statement	Anorm.scala	/^    val statement = if (getGeneratedKeys) connection.prepareStatement(sql.query, java.sql.Statement.RETURN_GENERATED_KEYS)$/;"	V
statement	DB.scala	/^    val statement = b$/;"	V
statement	ScriptSpec.scala	/^      val statement = "SELECT cream_filling FROM twinkies"$/;"	V
statements	DB.scala	/^  private val statements = scala.collection.mutable.ListBuffer.empty[Statement]$/;"	V
statements	Evolutions.scala	/^  def statements: Seq[String] = {$/;"	m
statements	ScriptSpec.scala	/^      val statements = IndexedSeq("FIRST", "SECOND", "THIRD", "FOURTH")$/;"	V
statements	ScriptSpec.scala	/^      val statements = IndexedSeq($/;"	V
statementsWithEscapeSequence	ScriptSpec.scala	/^      val statementsWithEscapeSequence = statements.map(_.replace(";", ";;"))$/;"	V
staticPathPart	RoutesCompiler.scala	/^    def staticPathPart: Parser[StaticPart] = (not(":") ~> not("*") ~> not("$") ~> """[^\\s]""".r +) ^^ {$/;"	m
status	Helpers.scala	/^  def status(of: Result): Int = of match {$/;"	m
status	WS.scala	/^  def status: Int = ahcResponse.getStatusCode()$/;"	m
statusCode	WS.scala	/^      var statusCode = 0$/;"	v
statusText	WS.scala	/^  def statusText: String = ahcResponse.getStatusText()$/;"	m
step	Concurrent.scala	/^      def step(inner: Iteratee[E, A])(in: Input[E]): Iteratee[E, Iteratee[E, A]] = {$/;"	m
step	Concurrent.scala	/^      def step(it: Iteratee[E, A]): K[E, Iteratee[E, A]] = {$/;"	m
step	Concurrent.scala	/^      def step(ref: Ref[Iteratee[E, Option[A]]])(in: Input[E]): Iteratee[E, Option[A]] = {$/;"	m
step	Concurrent.scala	/^      def step: K[E, Iteratee[E, A]] = {$/;"	m
step	Concurrent.scala	/^    def step(in: Input[E]): Iteratee[E, Unit] = {$/;"	m
step	Enumeratee.scala	/^      def step(inner: Iteratee[E, A])(in: Input[E]): Iteratee[E, Iteratee[E, A]] = {$/;"	m
step	Enumeratee.scala	/^      def step[A](f: Iteratee[From, To])(k: K[To, A]): K[From, Iteratee[To, A]] = {$/;"	m
step	Enumeratee.scala	/^      def step[A](k: K[To, A]): K[From, Iteratee[To, A]] = {$/;"	m
step	Enumeratee.scala	/^      def step[A](lastTo: To)(k: K[To, A]): K[From, Iteratee[To, A]] = {$/;"	m
step	Enumeratee.scala	/^    def step(it1: Iteratee[E, A], it2: Iteratee[E, B])(in: Input[E]) = {$/;"	m
step	Enumeratee.scala	/^    def step[A](k: K[E, A]): K[E, Iteratee[E, A]] = {$/;"	m
step	Enumeratee.scala	/^    def step[A](k: K[M, A]): K[M, Iteratee[M, A]] = {$/;"	m
step	Enumeratee.scala	/^    def step[A](remaining: Int)(k: K[E, A]): K[E, Iteratee[E, A]] = {$/;"	m
step	Enumerator.scala	/^        def step(in: Input[EE]): Iteratee[EE, Unit] = {$/;"	m
step	Enumerator.scala	/^      def step(it: Iteratee[E, A]) {$/;"	m
step	Enumerator.scala	/^      def step(it: Iteratee[E, A]): Future[Iteratee[E,A]] = it.fold {$/;"	m
step	Enumerator.scala	/^      def step(it: Iteratee[E, A], initial: Boolean = false) {$/;"	m
step	Enumerator.scala	/^      def step(it: Iteratee[E, A], state:S): Future[Iteratee[E,A]] = it.fold{$/;"	m
step	Iteratee.scala	/^    def step(s: A)(i: Input[E]): Iteratee[E, A] = i match {$/;"	m
step	Iteratee.scala	/^    def step(s: Seq[A])(input: Input[E]): Iteratee[E, Seq[A]] = {$/;"	m
step	Iteratee.scala	/^    def step: K[E, Option[E]] = {$/;"	m
step	Iteratee.scala	/^    def step[A](rest: Array[Byte], inner: Iteratee[MatchInfo[Array[Byte]], A])(in: Input[Array[Byte]]): Iteratee[Array[Byte], Iteratee[MatchInfo[Array[Byte]], A]] = {$/;"	m
step	JsPath.scala	/^      def step(path: List[PathNode], value: JsValue): JsObject = {$/;"	m
step	JsPath.scala	/^    def step(json: JsObject, lpath: JsPath): JsResult[JsObject] = {$/;"	m
step	JsPath.scala	/^    def step(path: List[PathNode], json: JsValue): Either[JsError, JsResult[JsValue]] = path match {$/;"	m
step	JsValue.scala	/^    def step(fields: List[(String, JsValue)], others: List[(String, JsValue)]): Seq[(String, JsValue)] = {$/;"	m
step	PlayDefaultUpstreamHandler.scala	/^                    def step(in:Input[r.BODY_CONTENT]):Iteratee[r.BODY_CONTENT,Unit] = (e.getChannel.isConnected(),in) match {$/;"	m
step	TraversableIteratee.scala	/^      def step(inner: Iteratee[M, A], leftToTake: Int)(in: Input[M]): Iteratee[M, Iteratee[M, A]] = {$/;"	m
step	TraversableIteratee.scala	/^      def step(it: Iteratee[M, A], leftToDrop: Int)(in: Input[M]): Iteratee[M, Iteratee[M, A]] = {$/;"	m
step	TraversableIteratee.scala	/^      def step:K[E,Option[A]] = {$/;"	m
step	TraversableIteratee.scala	/^      def step[A](k: K[M, A]): K[M, Iteratee[M, A]] = {$/;"	m
stepNode	JsPath.scala	/^    def stepNode(json: JsObject, node: PathNode): JsResult[JsObject] = {$/;"	m
stop	JUnitXmlTestListener.scala	/^    def stop(): Elem = {$/;"	m
stop	NettyServer.scala	/^  def stop(): Unit$/;"	m
str	SqlParser.scala	/^  def str(columnName: String): RowParser[String] = get[String](columnName)(implicitly[anorm.Column[String]])$/;"	m
stream	Assets.scala	/^            val stream = url.openStream()$/;"	V
stream	Results.scala	/^    def stream[C](content: Enumerator[C])(implicit writeable: Writeable[C]): ChunkedResult[C] = {$/;"	m
stream	Results.scala	/^    def stream[C](content: Iteratee[C, Unit] => Unit)(implicit writeable: Writeable[C]): ChunkedResult[C] = {$/;"	m
string	RoutesCompiler.scala	/^    def string: Parser[String] = {$/;"	m
stringFrame	WebSocket.scala	/^    implicit val stringFrame: FrameFormatter[String] = play.core.server.websocket.Frames.textFrame$/;"	V
stringIteratee	PlayDefaultUpstreamHandler.scala	/^                  val stringIteratee = Iteratee.fold(channelBuffer)((c, e: r.BODY_CONTENT) => { writer(c, e); c })$/;"	V
stringMessages	Comet.scala	/^    implicit val stringMessages = CometMessage[String](str => "'" + StringEscapeUtils.escapeEcmaScript(str) + "'")$/;"	V
stringWriter	JUnitXmlTestListener.scala	/^                                                     val stringWriter = new StringWriter()$/;"	V
stringify	Json.scala	/^  def stringify(json: JsValue): String = JacksonJson.generateFromJsValue(json)$/;"	m
stuckIteratee	ConcurrentSpec.scala	/^      val stuckIteratee = Iteratee.foldM(List[Long]()){ (s,e:Long) => p.future }$/;"	V
subKeys	Configuration.scala	/^   * val subKeys = configuration.subKeys$/;"	V
subKeys	Configuration.scala	/^  def subKeys: Set[String] = underlying.root().keySet().asScala.toSet$/;"	m
subTitle	Evolutions.scala	/^  def subTitle = "This SQL script must be run:"$/;"	m
subTitle	Evolutions.scala	/^  def subTitle = "We got the following error: " + error + ", while trying to run this SQL script:"$/;"	m
subject	BindersSpec.scala	/^    val subject = implicitly[PathBindable[String]]$/;"	V
subject	BindersSpec.scala	/^    val subject = implicitly[PathBindable[UUID]]$/;"	V
subject	BindersSpec.scala	/^    val subject = implicitly[QueryStringBindable[UUID]]$/;"	V
subobj	JsPath.scala	/^      val subobj = buildSubPath(path, value)$/;"	V
success	PlayJvm.scala	/^  def success(message: => String) = log(Level.Info, message)$/;"	m
sum	EnumerateesSpec.scala	/^      val sum = Iteratee.fold[Int, Int](0)(_+_)$/;"	V
sum	EnumeratorsSpec.scala	/^    val sum = e |>> i1$/;"	V
sum	EnumeratorsSpec.scala	/^    val sum = hub.getPatchCord() |>>> i1$/;"	V
sun.security.x509._	FakeKeyStore.scala	/^import sun.security.x509._$/;"	i
sw	JsValue.scala	/^    val sw = new java.io.StringWriter$/;"	V
switches	Configuration.scala	/^   * val switches = configuration.getBooleanList("board.switches")$/;"	V
sym	Action.scala	/^  lazy val sym = {$/;"	V
sync	RoutesCompiler.scala	/^    def sync(): Boolean = {$/;"	m
system	Akka.scala	/^    val system = ActorSystem("application", app.configuration.underlying, app.classloader)$/;"	V
system	Akka.scala	/^  def system(implicit app: Application) = {$/;"	m
system	Invoker.scala	/^  val system: ActorSystem = ActorSystem("play", loadActorConfig)$/;"	V
t	JsonSpec.scala	/^      val t = 1330950829160L$/;"	V
t	PlayCommands.scala	/^        val t = new Transformer(cp, "debug=-1")$/;"	V
t	TemplateCompilerSpec.scala	/^      val t = classloader.loadClass(className + "$").getDeclaredField("MODULE$").get(null)$/;"	V
tagRequest	Action.scala	/^  def tagRequest(request: RequestHeader): RequestHeader$/;"	m
tagRequest	Router.scala	/^          def tagRequest(rh: RequestHeader) = doTagRequest(rh, handler)$/;"	m
taggedResponse	Assets.scala	/^                val taggedResponse = etagFor(url).map(etag => gzippedResponse.withHeaders(ETAG -> etag)).getOrElse(gzippedResponse)$/;"	V
taggedRh	Helpers.scala	/^    val taggedRh = handler.map({$/;"	V
tags	Http.scala	/^        val tags = _tags$/;"	V
tags	Http.scala	/^      def tags = rh.tags$/;"	m
tags	Http.scala	/^      def tags = self.tags$/;"	m
tags	Http.scala	/^    def tags = request.tags$/;"	m
tags	Http.scala	/^    def tags: Map[String,String]$/;"	m
tags	PlayDefaultUpstreamHandler.scala	/^          val tags = Map.empty[String,String]$/;"	V
take	Enumeratee.scala	/^  def take[E](count: Int): Enumeratee[E, E] = new CheckDone[E, E] {$/;"	m
take	TraversableIteratee.scala	/^  def take[M](count: Int)(implicit p: M => scala.collection.TraversableLike[_, M]): Enumeratee[M, M] = new Enumeratee[M, M] {$/;"	m
take3AndConsume	EnumerateesSpec.scala	/^      val take3AndConsume = (Enumeratee.takeWhile[String](_ != "4") &>>  Iteratee.consume()).flatMap(_ => Iteratee.consume())$/;"	V
take3AndConsume	EnumerateesSpec.scala	/^      val take3AndConsume = (Enumeratee.take[String](3) &>>  Iteratee.consume()).flatMap(_ => Iteratee.consume())$/;"	V
take3AndConsume	EnumerateesSpec.scala	/^      val take3AndConsume = (Traversable.take[String](3) &>>  Iteratee.consume()).flatMap(_ => Iteratee.consume())$/;"	V
take3AndConsume	EnumerateesSpec.scala	/^      val take3AndConsume = Enumeratee.takeWhile[String](_ != "4" ) &>>  Iteratee.consume()$/;"	V
take3AndConsume	EnumerateesSpec.scala	/^      val take3AndConsume = Enumeratee.take[String](3) &>>  Iteratee.consume()$/;"	V
take3AndConsume	EnumerateesSpec.scala	/^      val take3AndConsume = Traversable.take[String](3) &>>  Iteratee.consume()$/;"	V
takeUpTo	TraversableIteratee.scala	/^  def takeUpTo[M](count: Int)(implicit p: M => scala.collection.TraversableLike[_, M]): Enumeratee[M, M] = new Enumeratee[M, M] {$/;"	m
takeUpToBoundary	ContentTypes.scala	/^            val takeUpToBoundary = Enumeratee.takeWhile[MatchInfo[Array[Byte]]](!_.isMatch)$/;"	V
takeWhile	Enumeratee.scala	/^  def takeWhile[E](p: E => Boolean): Enumeratee[E, E] = new CheckDone[E, E] {$/;"	m
takesOnlyStringsWithLessThan4Chars	EnumerateesSpec.scala	/^      val takesOnlyStringsWithLessThan4Chars = Enumeratee.collect[String]{ case e@("One" | "Two" | "Six") => e.toUpperCase } &>>  Iteratee.consume()$/;"	V
takesOnlyStringsWithLessThan4Chars	EnumerateesSpec.scala	/^      val takesOnlyStringsWithLessThan4Chars = Enumeratee.filter[String](_.length < 4) &>>  Iteratee.consume()$/;"	V
targetDir	JUnitXmlTestListener.scala	/^  val targetDir = new File(outputDir + "\/test-reports\/")$/;"	V
targetDirectory	PlayReloader.scala	/^          val targetDirectory = extracted.get(target)$/;"	V
targetMarker	ScalaTemplateCompiler.scala	/^        val targetMarker = mapPosition(marker)$/;"	V
taskForm	Forms.scala	/^ * val taskForm = Form($/;"	V
taskInAllDependencies	PlayCommands.scala	/^      def taskInAllDependencies[T](taskKey: TaskKey[T]): Task[Seq[T]] =$/;"	m
tempFile	ContentTypes.scala	/^            val tempFile = TemporaryFile("multipartBody", "asTemporaryFile")$/;"	V
tempFile	ContentTypes.scala	/^      val tempFile = TemporaryFile("requestBody", "asTemporaryFile")$/;"	V
tempFile	Files.scala	/^     * val tempFile = TemporaryFile(prefix = "uploaded")$/;"	V
template	Console.scala	/^      val template: (String, String) = if (args.length == 3 && args(1) == "--g8") (args.last, defaultName)$/;"	V
template	ScalaTemplateCompiler.scala	/^      def template: Parser[Template] = {$/;"	m
templateClasses	PlayCommands.scala	/^    val templateClasses = (srcManaged ** "*.template.scala").get flatMap { sourceFile =>$/;"	V
templateCode	ScalaTemplateCompiler.scala	/^    def templateCode(template: Template, resultType: String): Seq[Any] = {$/;"	m
templateCompiler	TemplateCompilerSpec.scala	/^    val templateCompiler = ScalaTemplateCompiler$/;"	V
templateContent	ScalaTemplateCompiler.scala	/^      def templateContent: Parser[(List[Simple], List[Def], List[Template], List[TemplateTree])] = {$/;"	m
templateDeclaration	ScalaTemplateCompiler.scala	/^      def templateDeclaration: Parser[(PosString, PosString)] = {$/;"	m
templateExt	PlayCommands.scala	/^    val templateExt: PartialFunction[File, (File, String, String, String)] = {$/;"	V
templateFile	TemplateCompilerSpec.scala	/^      val templateFile = new File(sourceDir, templateName)$/;"	V
templateName	ScalaTemplateCompiler.scala	/^      val templateName = source2TemplateName(template, sourceDirectory, template.getName.split('.').takeRight(1).head).split('.')$/;"	V
templateParser	ScalaTemplateCompiler.scala	/^    val templateParser = new TemplateParser$/;"	V
templatePositionMapper	PlayPositionMapper.scala	/^  val templatePositionMapper: Position => Option[Position] = position => {$/;"	V
templateToUse	Console.scala	/^        val templateToUse = Option(consoleReader.readLine(Colors.cyan("> "))).map(_.trim).getOrElse("") match {$/;"	V
templateType	ScalaTemplateCompiler.scala	/^        var templateType = "play.api.templates.Template%s[%s%s]".format($/;"	v
templatesImport	PlayKeys.scala	/^  val templatesImport = SettingKey[Seq[String]]("play-templates-imports")$/;"	V
templatesTypes	PlayKeys.scala	/^  val templatesTypes = SettingKey[PartialFunction[String, (String, String)]]("play-templates-formats")$/;"	V
temporaryFile	ContentTypes.scala	/^    def temporaryFile: BodyParser[TemporaryFile] = BodyParser("temporaryFile") { request =>$/;"	m
testClassLoader	ThreadsSpec.scala	/^  val testClassLoader = new ClassLoader(){}$/;"	V
testListener	PlayCommands.scala	/^  protected lazy val testListener = new PlayTestListener$/;"	V
testMessages	MessagesSpec.scala	/^  val testMessages = Map($/;"	V
testParam	TemplateCompilerSpec.scala	/^      val testParam = "12345"$/;"	V
testResultReporter	PlayCommands.scala	/^  val testResultReporter = TaskKey[List[String]]("test-result-reporter")$/;"	V
testResultReporterReset	PlayCommands.scala	/^  val testResultReporterReset = TaskKey[Unit]("test-result-reporter-reset")$/;"	V
testResultReporterResetTask	PlayCommands.scala	/^  val testResultReporterResetTask = (state, thisProjectRef) map { (s, r) =>$/;"	V
testResultReporterTask	PlayCommands.scala	/^  val testResultReporterTask = (state, thisProjectRef) map { (s, r) =>$/;"	V
testServerPort	Helpers.scala	/^  lazy val testServerPort = Option(System.getProperty("testserver.port")).map(_.toInt).getOrElse(19001)$/;"	V
testSuite	JUnitXmlTestListener.scala	/^  var testSuite: TestSuite = null$/;"	v
text	ContentTypes.scala	/^    def text(maxLength: Int): BodyParser[String] = when($/;"	m
text	ContentTypes.scala	/^    def text: BodyParser[String] = text(DEFAULT_MAX_TEXT_LENGTH)$/;"	m
text	CryptoSpec.scala	/^      val text = "Play Framework 2.0"$/;"	V
text	Forms.scala	/^  def text(minLength: Int = 0, maxLength: Int = Int.MaxValue): Mapping[String] = (minLength, maxLength) match {$/;"	m
text	Forms.scala	/^  val text: Mapping[String] = of[String]$/;"	V
text	JavaParsers.scala	/^  def text(maxLength: Int): BodyParser[RequestBody] = parse.maxLength(orDefault(maxLength), parse.text(Integer.MAX_VALUE)).map {$/;"	m
text	TemplateUtilsSpec.scala	/^        val text = TextFormat.raw("<h1>") + TextFormat.escape("Hello <world>") + TextFormat.raw("<\/h1>")$/;"	V
textFrame	Frame.scala	/^  val textFrame = FrameFormatter[String]($/;"	V
this	csrf.scala	/^    def this() = this(CSRF.generate _) \/\/ Default constructor, useful from Java$/;"	m
thread	NamedThreadFactory.scala	/^    val thread = backingThreadFactory.newThread(r)$/;"	V
thread	Threads.scala	/^    val thread = Thread.currentThread$/;"	V
threadNo	NamedThreadFactory.scala	/^  val threadNo = new AtomicInteger()$/;"	V
through	Enumerator.scala	/^  def through[To](enumeratee: Enumeratee[E, To]): Enumerator[To] = &>(enumeratee)$/;"	m
throwing	JavaPromise.scala	/^  def throwing[A](throwable: Throwable) = Promise.pure[A](throw throwable)$/;"	m
throwing	Promise.scala	/^  def throwing(t: Throwable): Unit = p.failure(t)$/;"	m
throwing	Promise.scala	/^  def throwing(t: Throwable): Unit$/;"	m
tidy	PlayTestListener.scala	/^  def tidy(s: String) = s$/;"	m
timeZoneCode	Assets.scala	/^  private val timeZoneCode = "GMT"$/;"	V
timeout	ConcurrentSpec.scala	/^  def timeout[A](a: => A, d: Duration)(implicit e: ExecutionContext): Future[A] = {$/;"	m
timeout	Configuration.scala	/^   * val timeout = configuration.getMilliseconds("engine.timeout")$/;"	V
timeout	Configuration.scala	/^   * val timeout = configuration.getNanoseconds("engine.timeout")$/;"	V
timeout	JavaPromise.scala	/^  def timeout: Future[Nothing] = Promise.timeout$/;"	m
timeout	JavaPromise.scala	/^  def timeout[A](callable: Callable[A], duration: Long, unit: TimeUnit = TimeUnit.MILLISECONDS, ec: ExecutionContext): scala.concurrent.Future[A] =$/;"	m
timeout	JavaPromise.scala	/^  def timeout[A](message: A, delay: Long, unit: java.util.concurrent.TimeUnit) = {$/;"	m
timeout	Promise.scala	/^  def timeout: Future[Nothing] = {$/;"	m
timeout	Promise.scala	/^  def timeout[A](message: => A, duration: Long, unit: TimeUnit = TimeUnit.MILLISECONDS)(implicit ec: ExecutionContext): Future[A] = {$/;"	m
timeout	Promise.scala	/^  def timeout[A](message: => A, duration: scala.concurrent.duration.Duration)(implicit ec: ExecutionContext): Future[A] = {$/;"	m
timeouts	Configuration.scala	/^   * val timeouts = configuration.getMillisecondsList("engine.timeouts")$/;"	V
timeouts	Configuration.scala	/^   * val timeouts = configuration.getNanosecondsList("engine.timeouts")$/;"	V
timer	Concurrent.scala	/^  private val timer = new java.util.Timer()$/;"	V
timer	ConcurrentSpec.scala	/^  val timer = new java.util.Timer$/;"	V
timer	Promise.scala	/^  private val timer = new java.util.Timer()$/;"	V
timers	LessCompiler.scala	/^                var timers = [],$/;"	v
timestampFile	PlayCommands.scala	/^    val timestampFile = cacheDir \/ "play_instrumentation"$/;"	V
tm	NettyServer.scala	/^          val tm = Option(System.getProperty("https.trustStore")).map {$/;"	V
to	Binders.scala	/^    def to(value: Boolean) = value.toString$/;"	m
to	Binders.scala	/^    def to(value: Int) = value.toString$/;"	m
to	Binders.scala	/^    def to(value: Long) = value.toString$/;"	m
to	Binders.scala	/^    def to(value: Option[T]) = value.map(jsl.to(_)).getOrElse("null")$/;"	m
to	Binders.scala	/^    def to(value: String) = "\\"" + value + "\\""$/;"	m
to	Binders.scala	/^    def to(value: java.lang.Integer) = value.toString$/;"	m
to	Binders.scala	/^  def to(value: A): String$/;"	m
toCookie	Http.scala	/^    def toCookie = Cookie(name, "", Some(-1), path, domain, secure)$/;"	m
toFlatForm	JsResult.scala	/^  def toFlatForm(e: JsError): Seq[(String, Seq[ValidationError])] = e.errors.map{ case(path, seq) => path.toJsonString -> seq }$/;"	m
toFlatJson	JsResult.scala	/^  def toFlatJson(e: JsError): JsObject = toFlatJson(e.errors)$/;"	m
toFlatJson	JsResult.scala	/^  def toFlatJson(errors: Seq[(JsPath, Seq[ValidationError])]): JsObject =$/;"	m
toGitRepo	Console.scala	/^          def toGitRepo(user: String, proj: String) =$/;"	m
toHex	Codecs.scala	/^  def toHex(array: Array[Byte]): Array[Char] = {$/;"	m
toHexString	Codecs.scala	/^  def toHexString(array: Array[Byte]): String = {$/;"	m
toHtmlArgs	Templates.scala	/^  def toHtmlArgs(args: Map[Symbol, Any]) = Html(args.map(a => a._1.name + "=\\"" + HtmlFormat.escape(a._2.toString).body + "\\"").mkString(" "))$/;"	m
toHumanReadableScript	Evolutions.scala	/^  def toHumanReadableScript(script: Seq[Script]): String = {$/;"	m
toJson	Json.scala	/^  def toJson[A : Writes]: Enumeratee[A, JsValue] = Enumeratee.map(Json.toJson(_))$/;"	m
toJson	Json.scala	/^  def toJson[T](o: T)(implicit tjs: Writes[T]): JsValue = tjs.writes(o)$/;"	m
toJsonString	JsPath.scala	/^  def toJsonString = "*" + key$/;"	m
toJsonString	JsPath.scala	/^  def toJsonString = "." + key$/;"	m
toJsonString	JsPath.scala	/^  def toJsonString = "[%d]".format(idx)$/;"	m
toJsonString	JsPath.scala	/^  def toJsonString = path.foldLeft("obj")((acc, p) => acc + p.toJsonString)$/;"	m
toJsonString	JsPath.scala	/^  def toJsonString: String$/;"	m
toLocale	Messages.scala	/^  def toLocale: java.util.Locale = {$/;"	m
toMap	Http.scala	/^    lazy val toMap: Map[String, Seq[String]] = {$/;"	V
toMap	csrf.scala	/^            override lazy val toMap: Map[String,Seq[String]] = request.headers.toMap - HeaderNames.COOKIE + (HeaderNames.COOKIE -> Seq(cookiesHeader))$/;"	V
toOption	Anorm.scala	/^  def toOption: Option[ID] = this match {$/;"	m
toOptionLoggingError	Utils.scala	/^  def toOptionLoggingError(): Option[A] = {$/;"	m
toPass	JsValue.scala	/^        val toPass = maybeValue.map { v =>$/;"	V
toPass	TraversableIteratee.scala	/^                val toPass = if (i < 0) Input.El(e.drop(leftToDrop)) else Input.Empty$/;"	V
toPush	Concurrent.scala	/^    val toPush = new Channel[E] {$/;"	V
toSimpleMap	Http.scala	/^    def toSimpleMap: Map[String, String] = keys.map { headerKey =>$/;"	m
toSourcePosition	ScalaTemplateCompiler.scala	/^    def toSourcePosition(marker: Int): (Int, Int) = {$/;"	m
todo	Default.scala	/^  def todo: Action[AnyContent] = TODO$/;"	m
token	csrf.scala	/^        val token = generator()$/;"	V
tolerantFormUrlEncoded	ContentTypes.scala	/^    def tolerantFormUrlEncoded(maxLength: Int): BodyParser[Map[String, Seq[String]]] = BodyParser("urlFormEncoded, maxLength=" + maxLength) { request =>$/;"	m
tolerantFormUrlEncoded	ContentTypes.scala	/^    def tolerantFormUrlEncoded: BodyParser[Map[String, Seq[String]]] = tolerantFormUrlEncoded(DEFAULT_MAX_TEXT_LENGTH)$/;"	m
tolerantJson	ContentTypes.scala	/^    def tolerantJson(maxLength: Int): BodyParser[JsValue] = BodyParser("json, maxLength=" + maxLength) { request =>$/;"	m
tolerantJson	ContentTypes.scala	/^    def tolerantJson: BodyParser[JsValue] = tolerantJson(DEFAULT_MAX_TEXT_LENGTH)$/;"	m
tolerantJson	JavaParsers.scala	/^  def tolerantJson(maxLength: Int): BodyParser[RequestBody] = parse.maxLength(orDefault(maxLength), parse.tolerantJson(Integer.MAX_VALUE)).map {$/;"	m
tolerantText	ContentTypes.scala	/^    def tolerantText(maxLength: Int): BodyParser[String] = BodyParser("text, maxLength=" + maxLength) { request =>$/;"	m
tolerantText	ContentTypes.scala	/^    def tolerantText: BodyParser[String] = tolerantText(DEFAULT_MAX_TEXT_LENGTH)$/;"	m
tolerantText	JavaParsers.scala	/^  def tolerantText(maxLength: Int): BodyParser[RequestBody] = parse.maxLength(orDefault(maxLength), parse.tolerantText(Integer.MAX_VALUE)).map {$/;"	m
tolerantXml	ContentTypes.scala	/^    def tolerantXml(maxLength: Int): BodyParser[NodeSeq] = BodyParser("xml, maxLength=" + maxLength) { request =>$/;"	m
tolerantXml	ContentTypes.scala	/^    def tolerantXml: BodyParser[NodeSeq] = tolerantXml(DEFAULT_MAX_TEXT_LENGTH)$/;"	m
tolerantXml	JavaParsers.scala	/^  def tolerantXml(maxLength: Int): BodyParser[RequestBody] = parse.maxLength(orDefault(maxLength), parse.tolerantXml(Integer.MAX_VALUE)).map {$/;"	m
tools.nsc.interactive.Response	ScalaTemplateCompiler.scala	/^          import tools.nsc.interactive.Response$/;"	i
topType	PlayReloader.scala	/^        val topType = className.split('$').head$/;"	V
totalCount	PlayTestListener.scala	/^    val totalCount = failures + errors + skipped + passed$/;"	V
trace	JUnitXmlTestListener.scala	/^                                                   var trace: String = if (e.error != null) {$/;"	v
trace	Logger.scala	/^  def trace(message: => String) {$/;"	m
trace	Logger.scala	/^  def trace(message: => String, error: => Throwable) {$/;"	m
trace	PlayJvm.scala	/^  def trace(t: => Throwable) = System.out.synchronized {$/;"	m
traceLevel	PlayJvm.scala	/^    val traceLevel = getTrace$/;"	V
trailing	Enumeratee.scala	/^  def trailing[M](es: Enumerator[M]) =  new Enumeratee.CheckDone[M, M] {$/;"	m
transfer	PlayJvm.scala	/^  def transfer(in: InputStream, out: OutputStream): Unit = {$/;"	m
transform	Binders.scala	/^  def transform[B](toB: A => B, toA: B => A) = new PathBindable[B] {$/;"	m
transform	Binders.scala	/^  def transform[B](toB: A => B, toA: B => A) = new QueryStringBindable[B] {$/;"	m
transform	Enumeratee.scala	/^  def transform[A](inner: Iteratee[To, A]): Iteratee[From, A] = apply(inner).joinI$/;"	m
transform	Form.scala	/^  def transform[B](f1: T => B, f2: B => T): Mapping[B] = WrappedMapping(this, f1, f2)$/;"	m
transform	Frame.scala	/^  def transform[B](fba: B => A, fab: A => B): FrameFormatter[B] = {$/;"	m
transform	JsValue.scala	/^  def transform[A <: JsValue](rds: Reads[A]): JsResult[A] = rds.reads(this)$/;"	m
transform	Results.scala	/^  def transform(f: PlainResult => Result)(implicit ec: ExecutionContext): AsyncResult = AsyncResult (result.map {$/;"	m
transform	WebSocket.scala	/^    def transform[B](fba: B => A, fab: A => B): FrameFormatter[B]$/;"	m
transform	Writes.scala	/^  def transform(transformer: JsValue => JsValue): Writes[A] = Writes[A]{ a => transformer(this.writes(a)) }$/;"	m
transform	Writes.scala	/^  def transform(transformer: Writes[JsValue]): Writes[A] = Writes[A]{ a => transformer.writes(this.writes(a)) }$/;"	m
transformed	Enumerator.scala	/^      val transformed = enumeratee.applyOn(i)$/;"	V
translate	Messages.scala	/^  def translate(key: String, args: Seq[Any])(implicit lang: Lang): Option[String] = {$/;"	m
translate	MessagesSpec.scala	/^  def translate(msg: String, lang: String, reg: String): Option[String] =$/;"	m
treeFrom	ScalaTemplateCompiler.scala	/^        def treeFrom(file: SourceFile): global.Tree = {$/;"	m
treeFrom	ScalaTemplateCompiler.scala	/^        def treeFrom(src: String): global.Tree = {$/;"	m
trimmed	OpenID.scala	/^      val trimmed = openID.trim$/;"	V
tripleQuote	ScalaTemplateCompiler.scala	/^          val tripleQuote = "\\"\\"\\""$/;"	V
tuple	Forms.scala	/^  def tuple[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15]), a16: (String, Mapping[A16]), a17: (String, Mapping[A17]), a18: (String, Mapping[A18])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18)] = mapping(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18)((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11, a12: A12, a13: A13, a14: A14, a15: A15, a16: A16, a17: A17, a18: A18) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18))((t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15]), a16: (String, Mapping[A16]), a17: (String, Mapping[A17])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17)] = mapping(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17)((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11, a12: A12, a13: A13, a14: A14, a15: A15, a16: A16, a17: A17) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17))((t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15]), a16: (String, Mapping[A16])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16)] = mapping(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16)((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11, a12: A12, a13: A13, a14: A14, a15: A15, a16: A16) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16))((t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14]), a15: (String, Mapping[A15])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)] = mapping(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15)((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11, a12: A12, a13: A13, a14: A14, a15: A15) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15))((t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13]), a14: (String, Mapping[A14])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)] = mapping(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11, a12: A12, a13: A13, a14: A14) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14))((t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12]), a13: (String, Mapping[A13])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)] = mapping(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11, a12: A12, a13: A13) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13))((t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11]), a12: (String, Mapping[A12])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)] = mapping(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11, a12: A12) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12))((t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10]), a11: (String, Mapping[A11])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)] = mapping(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10, a11: A11) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11))((t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2, A3, A4, A5, A6, A7, A8, A9, A10](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9]), a10: (String, Mapping[A10])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)] = mapping(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9, a10: A10) => (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10))((t: (A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2, A3, A4, A5, A6, A7, A8, A9](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8]), a9: (String, Mapping[A9])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8, A9)] = mapping(a1, a2, a3, a4, a5, a6, a7, a8, a9)((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8, a9: A9) => (a1, a2, a3, a4, a5, a6, a7, a8, a9))((t: (A1, A2, A3, A4, A5, A6, A7, A8, A9)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2, A3, A4, A5, A6, A7, A8](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7]), a8: (String, Mapping[A8])): Mapping[(A1, A2, A3, A4, A5, A6, A7, A8)] = mapping(a1, a2, a3, a4, a5, a6, a7, a8)((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7, a8: A8) => (a1, a2, a3, a4, a5, a6, a7, a8))((t: (A1, A2, A3, A4, A5, A6, A7, A8)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2, A3, A4, A5, A6, A7](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6]), a7: (String, Mapping[A7])): Mapping[(A1, A2, A3, A4, A5, A6, A7)] = mapping(a1, a2, a3, a4, a5, a6, a7)((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6, a7: A7) => (a1, a2, a3, a4, a5, a6, a7))((t: (A1, A2, A3, A4, A5, A6, A7)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2, A3, A4, A5, A6](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5]), a6: (String, Mapping[A6])): Mapping[(A1, A2, A3, A4, A5, A6)] = mapping(a1, a2, a3, a4, a5, a6)((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => (a1, a2, a3, a4, a5, a6))((t: (A1, A2, A3, A4, A5, A6)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2, A3, A4, A5](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4]), a5: (String, Mapping[A5])): Mapping[(A1, A2, A3, A4, A5)] = mapping(a1, a2, a3, a4, a5)((a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => (a1, a2, a3, a4, a5))((t: (A1, A2, A3, A4, A5)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2, A3, A4](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3]), a4: (String, Mapping[A4])): Mapping[(A1, A2, A3, A4)] = mapping(a1, a2, a3, a4)((a1: A1, a2: A2, a3: A3, a4: A4) => (a1, a2, a3, a4))((t: (A1, A2, A3, A4)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2, A3](a1: (String, Mapping[A1]), a2: (String, Mapping[A2]), a3: (String, Mapping[A3])): Mapping[(A1, A2, A3)] = mapping(a1, a2, a3)((a1: A1, a2: A2, a3: A3) => (a1, a2, a3))((t: (A1, A2, A3)) => Some(t))$/;"	m
tuple	Forms.scala	/^  def tuple[A1, A2](a1: (String, Mapping[A1]), a2: (String, Mapping[A2])): Mapping[(A1, A2)] = mapping(a1, a2)((a1: A1, a2: A2) => (a1, a2))((t: (A1, A2)) => Some(t))$/;"	m
txt	Evolutions.scala	/^    val txt = script.map {$/;"	V
types	MimeTypes.scala	/^  def types: Map[String, String] = defaultTypes ++ applicationTypes$/;"	m
tz	JsonValidSpec.scala	/^      val tz = c.getTimeZone().getOffset(c.getTime.getTime).toInt \/ 3600000$/;"	V
u	DB.scala	/^    val u = conn.getMetaData.getURL$/;"	V
ue	Anorm.scala	/^    def apply(value: Any, meta: MetaDataItem): MayErr[SqlRequestError, A] = transformer(value, meta)$/;"	V
ue	Anorm.scala	/^    private def setAny(index: Int, value: Any, stmt: java.sql.PreparedStatement): java.sql.PreparedStatement = {$/;"	V
ue	Binders.scala	/^    def bind(key: String, value: String) = {$/;"	V
ue	Binders.scala	/^    def bind(key: String, value: String): Either[String, A] = {$/;"	V
ue	Binders.scala	/^    def bind(key: String, value: String): Either[String, B] = self.bind(key, value).right.map(toB)$/;"	V
ue	Binders.scala	/^    def to(value: Boolean) = value.toString$/;"	V
ue	Binders.scala	/^    def to(value: Int) = value.toString$/;"	V
ue	Binders.scala	/^    def to(value: Long) = value.toString$/;"	V
ue	Binders.scala	/^    def to(value: Option[T]) = value.map(jsl.to(_)).getOrElse("null")$/;"	V
ue	Binders.scala	/^    def to(value: String) = "\\"" + value + "\\""$/;"	V
ue	Binders.scala	/^    def to(value: java.lang.Integer) = value.toString$/;"	V
ue	Binders.scala	/^    def unbind(key: String, value: A) = key + "=" + serialize(value)$/;"	V
ue	Binders.scala	/^    def unbind(key: String, value: A): String = serialize(value)$/;"	V
ue	Binders.scala	/^    def unbind(key: String, value: B): String = self.unbind(key, toA(value))$/;"	V
ue	Binders.scala	/^    def unbind(key: String, value: Option[T]) = value.map(implicitly[QueryStringBindable[T]].unbind(key, _)).getOrElse("")$/;"	V
ue	Binders.scala	/^    def unbind(key: String, value: String) = key + "=" + (URLEncoder.encode(value, "utf-8"))$/;"	V
ue	Binders.scala	/^    def unbind(key: String, value: T) = {$/;"	V
ue	Binders.scala	/^    def unbind(key: String, value: play.libs.F.Option[T]) = {$/;"	V
ue	Binders.scala	/^  def bind(key: String, value: String): Either[String, A]$/;"	V
ue	Binders.scala	/^  def to(value: A): String$/;"	V
ue	Binders.scala	/^  def unbind(key: String, value: A): String$/;"	V
ue	Binders.scala	/^ *       override def bind(key: String, value: String): Either[String, User] = {$/;"	V
ue	Cache.scala	/^    def set(key: String, value: Any, expiration: Int) {$/;"	V
ue	Cache.scala	/^  def set(key: String, value: Any, expiration: Int = 0)(implicit app: Application) = {$/;"	V
ue	Cache.scala	/^  def set(key: String, value: Any, expiration: Int)$/;"	V
ue	ContentTypes.scala	/^  case class DataPart(key: String, value: String) extends Part$/;"	V
ue	Crypto.scala	/^  def decryptAES(value: String): String = {$/;"	V
ue	Crypto.scala	/^  def decryptAES(value: String, privateKey: String): String = {$/;"	V
ue	Crypto.scala	/^  def encryptAES(value: String): String = {$/;"	V
ue	Crypto.scala	/^  def encryptAES(value: String, privateKey: String): String = {$/;"	V
ue	DB.scala	/^  def setClientInfo(name: String, value: String) { connection.setClientInfo(name, value) }$/;"	V
ue	DynamicFormSpec.scala	/^      html must contain("value=\\"\\"")$/;"	V
ue	DynamicFormSpec.scala	/^      html must contain("value=\\"bar\\"")$/;"	V
ue	Enumerator.scala	/^        override def write(value: Int) {$/;"	V
ue	Evolutions.scala	/^    <input name="evolution-button" type="button" value="Apply this script now!" onclick={ javascript }\/>$/;"	V
ue	Evolutions.scala	/^    <input name="evolution-button" type="button" value="Mark it resolved" onclick={ javascript }\/>$/;"	V
ue	Form.scala	/^    errors => this.copy(data = data, errors = errors, value = None),$/;"	V
ue	Form.scala	/^    this.copy(data = result._1, errors = result._2, value = Some(value))$/;"	V
ue	Form.scala	/^    this.copy(data = result._1, value = Some(value))$/;"	V
ue	Form.scala	/^    value => this.copy(data = data, errors = Nil, value = Some(value)))$/;"	V
ue	Form.scala	/^   *   <input type="text" name={field.name} value={field.value.getOrElse("")} \/>$/;"	V
ue	Form.scala	/^  def fill(value: T): Form[T] = {$/;"	V
ue	Form.scala	/^  def fillAndValidate(value: T): Form[T] = {$/;"	V
ue	Form.scala	/^  def unbind(value: B): (Map[String, String], Seq[FormError]) = {$/;"	V
ue	Form.scala	/^  def unbind(value: List[T]): (Map[String, String], Seq[FormError]) = {$/;"	V
ue	Form.scala	/^  def unbind(value: Option[T]): (Map[String, String], Seq[FormError]) = {$/;"	V
ue	Form.scala	/^  def unbind(value: R) = {$/;"	V
ue	Form.scala	/^  def unbind(value: T): (Map[String, String], Seq[FormError]) = {$/;"	V
ue	Form.scala	/^  def unbind(value: T): (Map[String, String], Seq[FormError])$/;"	V
ue	Form.scala	/^  def withError(error: FormError): Form[T] = this.copy(errors = errors :+ error, value = None)$/;"	V
ue	Form.scala	/^case class Form[T](mapping: Mapping[T], data: Map[String, String], errors: Seq[FormError], value: Option[T]) {$/;"	V
ue	Forms.scala	/^  def default[A](mapping: Mapping[A], value:A): Mapping[A] = OptionalMapping(mapping).transform(_.getOrElse(value), Some(_))$/;"	V
ue	Forms.scala	/^  def ignored[A](value: A): Mapping[A] = of(ignoredFormat(value))$/;"	V
ue	Http.scala	/^        value = value0.trim$/;"	V
ue	Http.scala	/^  case class Cookie(name: String, value: String, maxAge: Option[Int] = None, path: String = "\/", domain: Option[String] = None, secure: Boolean = false, httpOnly: Boolean = true)$/;"	V
ue	JUnitXmlTestListener.scala	/^          props += <property name={ next.getKey.toString } value={ next.getValue.toString }\/>$/;"	V
ue	JUnitXmlTestListener.scala	/^   *           <property name="os.name" value="Linux" \/>$/;"	V
ue	JsPath.scala	/^                step(o, JsPath(tail)).repath(lpath).flatMap( value => $/;"	V
ue	JsPath.scala	/^      def step(path: List[PathNode], value: JsValue): JsObject = {$/;"	V
ue	JsPath.scala	/^    def buildSubPath(path: JsPath, value: JsValue) = {$/;"	V
ue	JsPath.scala	/^    def filterPathNode(json: JsObject, node: PathNode, value: JsValue): JsResult[JsObject] = {$/;"	V
ue	JsPath.scala	/^  private[json] def toJsonField(value: JsValue): JsValue = value$/;"	V
ue	JsPath.scala	/^  private[json] override def toJsonField(value: JsValue) = Json.obj(key -> value)$/;"	V
ue	JsPath.scala	/^  private[json] override def toJsonField(value: JsValue) = value$/;"	V
ue	JsResult.scala	/^case class JsSuccess[T](value: T, path: JsPath = JsPath()) extends JsResult[T] {$/;"	V
ue	JsValue.scala	/^  def :+(el: JsValue): JsArray = JsArray(value :+ el)$/;"	V
ue	JsValue.scala	/^  def addValue(value: JsValue): DeserializerContext = ReadingMap(content :+ (fieldName -> value))$/;"	V
ue	JsValue.scala	/^  def addValue(value: JsValue): DeserializerContext = throw new Exception("Cannot add a value on an object without a key, malformed JSON object!")$/;"	V
ue	JsValue.scala	/^  def addValue(value: JsValue): DeserializerContext$/;"	V
ue	JsValue.scala	/^  def serialize(value: JsValue, json: JsonGenerator, provider: SerializerProvider) {$/;"	V
ue	JsValue.scala	/^  override def addValue(value: JsValue): DeserializerContext = {$/;"	V
ue	JsValue.scala	/^case class JsArray(value: Seq[JsValue] = List()) extends JsValue{$/;"	V
ue	JsValue.scala	/^case class JsBoolean(value: Boolean) extends JsValue$/;"	V
ue	JsValue.scala	/^case class JsNumber(value: BigDecimal) extends JsValue$/;"	V
ue	JsValue.scala	/^case class JsString(value: String) extends JsValue$/;"	V
ue	NettyPromise.scala	/^    def value: Option[Try[Unit]] = (channelPromise.isDone, channelPromise.isSuccess) match {$/;"	V
ue	OAuth.scala	/^    override def setHeader(name: String, value: String) {$/;"	V
ue	ObjectMappings.scala	/^  def unbind(value: R): (Map[String, String], Seq[FormError]) = {$/;"	V
ue	OpenID.scala	/^        case (fullKey, shortKey) if signedFields.contains(fullKey) => values.headOption map { value => Map(shortKey -> value) }$/;"	V
ue	PartialValidationSpec.scala	/^  @MaxLength(value = 3, groups = Array(classOf[Partial]))$/;"	V
ue	PathParts.scala	/^case class StaticPart(value: String) extends PathPart {$/;"	V
ue	Results.scala	/^        pair._2.map(value => (pair._1 + "=" + URLEncoder.encode(value, "utf-8")))$/;"	V
ue	Router.scala	/^  case class Param[T](name: String, value: Either[String, T])$/;"	V
ue	Router.scala	/^case class StaticPart(value: String) extends PathPart {$/;"	V
ue	RoutesCompiler.scala	/^  case class HttpVerb(value: String) {$/;"	V
ue	ScalaTemplateCompiler.scala	/^            settings.bootclasspath.value = ((origBootclasspath :: pathList) ::: additionalClassPathEntry.toList) mkString File.pathSeparator$/;"	V
ue	TemplateCompilerSpec.scala	/^        settings.bootclasspath.value = ((origBootclasspath :: pathList) ::: additionalClassPathEntry.toList) mkString File.pathSeparator$/;"	V
ue	TemplateCompilerSpec.scala	/^        settings.outdir.value = generatedClasses.getAbsolutePath$/;"	V
ue	WS.scala	/^      hdrs.foreach(header => header._2.foreach(value =>$/;"	V
ue	WS.scala	/^    override def addHeader(name: String, value: String) = {$/;"	V
ue	WS.scala	/^    override def setHeader(name: String, value: String) = {$/;"	V
ue	csrf.scala	/^    case class Token(value: String)$/;"	V
ue1	Promise.scala	/^  def value1 = await$/;"	V
ues	Binders.scala	/^    def unbind(key: String, values: List[T]) = unbindList(key, values)$/;"	V
ues	Binders.scala	/^    def unbind(key: String, values: java.util.List[T]) = unbindList(key, values.asScala)$/;"	V
ues	Binders.scala	/^  private def unbindList[T: QueryStringBindable](key: String, values: Iterable[T]): String = {$/;"	V
ues	Configuration.scala	/^   * This method supports an optional set of valid values:$/;"	V
ues	ContentTypes.scala	/^            values = value.split(";").map(_.trim).map {$/;"	V
ues	JsValue.scala	/^  def values: Set[JsValue] = fields.map(_._2).toSet$/;"	V
ues	Results.scala	/^    map(_.flashing(values: _*))(internalContext)$/;"	V
ues	Results.scala	/^  def flashing(values: (String, String)*): A$/;"	V
ues	Results.scala	/^  def flashing(values: (String, String)*): AsyncResult = {$/;"	V
ues	Results.scala	/^  def flashing(values: (String, String)*): PlainResult = flashing(Flash(values.toMap))$/;"	V
unapply	ContentTypes.scala	/^        def unapply(headers: Map[String, String]): Option[(String, String, Option[String])] = {$/;"	m
unapply	ContentTypes.scala	/^        def unapply(headers: Map[String, String]): Option[String] = {$/;"	m
unapply	JsMacroImpl.scala	/^        val unapply = s.asMethod$/;"	V
unapply	RequestExtractors.scala	/^    def unapply(request: RequestHeader): Option[(RequestHeader, RequestHeader)] = Some((request, request))$/;"	m
unapply	RequestExtractors.scala	/^  def unapply(mediaRange: play.api.http.MediaRange): Boolean = mediaRange.accepts(mimeType)$/;"	m
unapply	RequestExtractors.scala	/^  def unapply(request: RequestHeader): Boolean = request.accepts(mimeType)$/;"	m
unapply	Results.scala	/^  def unapply(result: Result): Option[(Int, Map[String, String])] = result match {$/;"	m
unapply	Router.scala	/^      def unapply(request: RequestHeader): Option[Handler] = {$/;"	m
unapply	Router.scala	/^      def unapply(request: RequestHeader): Option[RouteParams] = {$/;"	m
unapply	Router.scala	/^      def unapply(request: RequestHeader): Option[RouteParams]$/;"	m
unapply	RoutesCompiler.scala	/^    def unapply(source: File): Option[GeneratedSource] = {$/;"	m
unapply	ScalaTemplateCompiler.scala	/^    def unapply(source: File): Option[GeneratedSource] = {$/;"	m
unapplyMethod	JsMacroImpl.scala	/^                    val unapplyMethod = Apply($/;"	V
unapplyReturnTypes	JsMacroImpl.scala	/^        val unapplyReturnTypes = unapply.returnType match { $/;"	V
unapplySeq	Anorm.scala	/^  def unapplySeq(row: Row): Option[List[Any]] = Some(row.asList)$/;"	m
unbind	Binders.scala	/^    def unbind(key: String, value: A) = key + "=" + serialize(value)$/;"	m
unbind	Binders.scala	/^    def unbind(key: String, value: A): String = serialize(value)$/;"	m
unbind	Binders.scala	/^    def unbind(key: String, value: B): String = self.unbind(key, toA(value))$/;"	m
unbind	Binders.scala	/^    def unbind(key: String, value: Option[T]) = value.map(implicitly[QueryStringBindable[T]].unbind(key, _)).getOrElse("")$/;"	m
unbind	Binders.scala	/^    def unbind(key: String, value: String) = key + "=" + (URLEncoder.encode(value, "utf-8"))$/;"	m
unbind	Binders.scala	/^    def unbind(key: String, value: T) = {$/;"	m
unbind	Binders.scala	/^    def unbind(key: String, value: play.libs.F.Option[T]) = {$/;"	m
unbind	Binders.scala	/^    def unbind(key: String, values: List[T]) = unbindList(key, values)$/;"	m
unbind	Binders.scala	/^    def unbind(key: String, values: java.util.List[T]) = unbindList(key, values.asScala)$/;"	m
unbind	Binders.scala	/^  def unbind(key: String, value: A): String$/;"	m
unbind	Form.scala	/^  def unbind(value: B): (Map[String, String], Seq[FormError]) = {$/;"	m
unbind	Form.scala	/^  def unbind(value: List[T]): (Map[String, String], Seq[FormError]) = {$/;"	m
unbind	Form.scala	/^  def unbind(value: Option[T]): (Map[String, String], Seq[FormError]) = {$/;"	m
unbind	Form.scala	/^  def unbind(value: R) = {$/;"	m
unbind	Form.scala	/^  def unbind(value: T): (Map[String, String], Seq[FormError]) = {$/;"	m
unbind	Form.scala	/^  def unbind(value: T): (Map[String, String], Seq[FormError])$/;"	m
unbind	ObjectMappings.scala	/^  def unbind(value: R): (Map[String, String], Seq[FormError]) = {$/;"	m
underlying	JavaGlobalSettingsAdapter.scala	/^class JavaGlobalSettingsAdapter(val underlying: play.GlobalSettings) extends GlobalSettings {$/;"	V
underlyingLogger	Logger.scala	/^  lazy val underlyingLogger = logger$/;"	V
unflatten	Iteratee.scala	/^  def unflatten: Future[Step[E, A]] = pureFold(identity)$/;"	m
unflatten	Results.scala	/^  def unflatten:Future[PlainResult] = result.flatMap {$/;"	m
unfold	Anorm.scala	/^  def unfold[T, R](init: T)(f: T => Option[(R, T)]): Stream[R] = f(init) match {$/;"	m
unfold	Enumerator.scala	/^  def unfold[S,E](s:S)(f: S => Option[(S,E)] ): Enumerator[E] = checkContinue1(s)(new TreatCont1[E,S]{$/;"	m
unfold1	Anorm.scala	/^  def unfold1[T, R](init: T)(f: T => Option[(R, T)]): (Stream[R], T) = f(init) match {$/;"	m
unfoldLeft	Collections.scala	/^  def unfoldLeft[A, B](seed: B)(f: B => Option[(B, A)]): Seq[A] = {$/;"	m
unfoldM	Enumerator.scala	/^  def unfoldM[S,E](s:S)(f: S => Future[Option[(S,E)]] ): Enumerator[E] = checkContinue1(s)(new TreatCont1[E,S]{$/;"	m
unliftIdent	JsMacroImpl.scala	/^    val unliftIdent = Select(functionalSyntaxPkg, "unlift")$/;"	V
unlock	Evolutions.scala	/^  def unlock(c: Connection, s: Statement) {$/;"	m
unsafeApplication	Play.scala	/^  def unsafeApplication: Application = _currentApp$/;"	m
untaggedRequestHeader	PlayDefaultUpstreamHandler.scala	/^        val untaggedRequestHeader = new RequestHeader {$/;"	V
unwrap	DB.scala	/^  def unwrap[T](iface: Class[T]) = connection.unwrap(iface)$/;"	m
upToSpace	EnumerateesSpec.scala	/^      val upToSpace = Traversable.splitOnceAt[String,Char](c => c != '\\n')  &>> Iteratee.consume()$/;"	V
update	JsPath.scala	/^    def update[A <: JsValue](reads: Reads[A]): Reads[JsObject] = Reads.jsUpdate(self)(reads)$/;"	m
updateAnalysis	PlayReloader.scala	/^      def updateAnalysis(newAnalysis: sbt.inc.Analysis) = {$/;"	m
updateEvolutionScript	Evolutions.scala	/^  def updateEvolutionScript(db: String = "default", revision: Int = 1, comment: String = "Generated", ups: String, downs: String)(implicit application: Application) {$/;"	m
updated	PlayReloader.scala	/^        val updated = if (newProducts != currentProducts || reloadNextTime) {$/;"	V
ups	Evolutions.scala	/^    val ups = (nonConflictingUps ++ conflictingUps).reverse.map(e => UpScript(e, e.sql_up))$/;"	V
upsMarker	Evolutions.scala	/^    val upsMarker = """^#.*!Ups.*$""".r$/;"	V
uri	FormSpec.scala	/^  def uri() = "\/test"$/;"	m
uri	Http.scala	/^        val uri = _uri$/;"	V
uri	Http.scala	/^      def uri = rh.uri$/;"	m
uri	Http.scala	/^      def uri = self.uri$/;"	m
uri	Http.scala	/^    def uri = request.uri$/;"	m
uri	Http.scala	/^    def uri: String$/;"	m
uri	JavaHelpers.scala	/^      def uri = req.uri$/;"	m
uri	OpenID.scala	/^      val uri = (if(url.matches("^(http|HTTP)(s|S)?:.*")) new URI(url) else new URI("http:\/\/" + url)).normalize()$/;"	V
uri	PlayDefaultUpstreamHandler.scala	/^          def uri = nettyHttpRequest.getUri$/;"	m
uri	csrf.scala	/^          def uri = request.uri$/;"	m
url	DB.scala	/^    val url = configuration.getString(dbName + ".url").getOrElse(error(dbName, "Missing configuration [db." + dbName + ".url]"))$/;"	V
url	DB.scala	/^    val url = connection.getMetaData.getURL$/;"	V
url	WS.scala	/^    def url: String = _url$/;"	m
url	WS.scala	/^  def url(url: String): WSRequestHolder = WSRequestHolder(url, Map(), Map(), None, None, None, None, None)$/;"	m
url	WsMock.scala	/^    def url(url: String): WSRequestHolder = {$/;"	m
urlFormEncoded	ContentTypes.scala	/^    def urlFormEncoded(maxLength: Int): BodyParser[Map[String, Seq[String]]] = when($/;"	m
urlFormEncoded	ContentTypes.scala	/^    def urlFormEncoded: BodyParser[Map[String, Seq[String]]] = urlFormEncoded(DEFAULT_MAX_TEXT_LENGTH)$/;"	m
urldecode	Http.scala	/^      def urldecode(data: String) = java.net.URLDecoder.decode(data, "UTF-8").split("\\u0000").map(_.split(":")).map(p => p(0) -> p.drop(1).mkString(":")).toMap$/;"	m
urls	WsMock.scala	/^    val urls:collection.mutable.Buffer[String] = new collection.mutable.ArrayBuffer[String]()$/;"	V
usage	Console.scala	/^          def usage = """$/;"	m
user	FormSpec.scala	/^    val user = userForm.bind(new java.util.HashMap[String, String]()).get()$/;"	V
user1	FormSpec.scala	/^    val user1 = JForm.form(classOf[play.data.AnotherUser]).bindFromRequest(new DummyRequest(Map("name" -> Array("Kiki")))).get$/;"	V
user2	FormSpec.scala	/^    val user2 = JForm.form(classOf[play.data.AnotherUser]).bindFromRequest(new DummyRequest(Map("name" -> Array("Kiki"), "emails[0]" -> Array("kiki@gmail.com")) )).get$/;"	V
user3	FormSpec.scala	/^    val user3 = JForm.form(classOf[play.data.AnotherUser]).bindFromRequest(new DummyRequest(Map("name" -> Array("Kiki"), "emails[0]" -> Array("kiki@gmail.com"), "emails[1]" -> Array("kiki@zen.com")) )).get$/;"	V
user4	FormSpec.scala	/^    val user4 = JForm.form(classOf[play.data.AnotherUser]).bindFromRequest(new DummyRequest(Map("name" -> Array("Kiki"), "emails[]" -> Array("kiki@gmail.com")) )).get$/;"	V
user5	FormSpec.scala	/^    val user5 = JForm.form(classOf[play.data.AnotherUser]).bindFromRequest(new DummyRequest(Map("name" -> Array("Kiki"), "emails[]" -> Array("kiki@gmail.com", "kiki@zen.com")) )).get$/;"	V
userForm	Form.scala	/^   * val userForm = Form($/;"	V
userForm	Form.scala	/^ * val userForm = Form($/;"	V
userForm	FormSpec.scala	/^    val userForm = Form($/;"	V
userForm	FormSpec.scala	/^    val userForm: Form[MyUser] = JForm.form(classOf[MyUser])$/;"	V
userFormat	JsonExtensionSpec.scala	/^      implicit val userFormat = Json.format[User1]$/;"	V
userFormat	JsonExtensionSpec.scala	/^      implicit val userFormat = Json.format[User]$/;"	V
userFormat	JsonValidSpec.scala	/^      implicit val userFormat = ($/;"	V
userFormats	JsonValidSpec.scala	/^      implicit val userFormats = { $/;"	V
userFormats	JsonValidSpec.scala	/^      implicit val userFormats = { import Format.path._; import Format.constraints._$/;"	V
userInfo	OpenIDSpec.scala	/^      val userInfo = Await.result(openId.verifiedId(setupMockRequest(responseQueryString)), dur)$/;"	V
userInfo	UserInfoSpec.scala	/^      val userInfo = UserInfo(createDefaultResponse(claimedId, identity, defaultSigned) - "openid.claimed_id")$/;"	V
userInfo	UserInfoSpec.scala	/^      val userInfo = UserInfo(createDefaultResponse(claimedId, identity, defaultSigned))$/;"	V
userInfo	UserInfoSpec.scala	/^      val userInfo = UserInfo(requestParams)$/;"	V
userInfo	UserInfoSpec.scala	/^    val userInfo = UserInfo(requestParams)$/;"	V
userReads	Json.scala	/^   *   implicit val userReads = ($/;"	V
userReads	Json.scala	/^   *   implicit val userReads = Json.reads[User]$/;"	V
userReads	JsonExtensionSpec.scala	/^      implicit val userReads = Json.reads[User1]$/;"	V
userReads	JsonExtensionSpec.scala	/^      implicit val userReads = Json.reads[UserFail]$/;"	V
userReads	JsonExtensionSpec.scala	/^      implicit val userReads = Json.reads[UserMap]$/;"	V
userReads	JsonExtensionSpec.scala	/^      implicit val userReads = Json.reads[User]$/;"	V
userReads	JsonValidSpec.scala	/^      implicit val userReads = { import Reads.path._$/;"	V
userWrites	Json.scala	/^   *   implicit val userWrites = ($/;"	V
userWrites	Json.scala	/^   *   implicit val userWrites = Json.format[User]$/;"	V
userWrites	Json.scala	/^   *   implicit val userWrites = Json.writes[User]$/;"	V
userWrites	JsonExtensionSpec.scala	/^      implicit val userWrites = Json.writes[User1]$/;"	V
userWrites	JsonExtensionSpec.scala	/^      implicit val userWrites = Json.writes[User]$/;"	V
userWrites	JsonValidSpec.scala	/^      implicit val userWrites = { import Writes.path._$/;"	V
username	Controller.scala	/^   *   val username = session("username")$/;"	V
username	Http.scala	/^      def username = None$/;"	m
username	PlayDefaultUpstreamHandler.scala	/^          def username = None$/;"	m
username	Security.scala	/^  lazy val username: String = Play.maybeApplication.flatMap(_.configuration.getString("session.username")) getOrElse ("username")$/;"	V
usernameField	Form.scala	/^   * val usernameField = userForm("username")$/;"	V
using	Anorm.scala	/^  def using[U](p: RowParser[U]): SimpleSql[U] = SimpleSql(sql, params, p)$/;"	m
using	ContentTypes.scala	/^    def using[A](f: RequestHeader => BodyParser[A]) = BodyParser { request =>$/;"	m
using	FakeRuntime.scala	/^    def using[T](t: T) = t$/;"	m
using	ScalaTemplate.scala	/^    def using[T](t: T) = t$/;"	m
using	WebSocket.scala	/^  def using[A](f: RequestHeader => (Iteratee[A, _], Enumerator[A]))(implicit frameFormatter: FrameFormatter[A]): WebSocket[A] = {$/;"	m
utf_8	Results.scala	/^  implicit val utf_8 = javaSupported("utf-8")$/;"	V
util._	JsonSpec.scala	/^      import util._$/;"	i
util.control.Exception._	ThreadsSpec.scala	/^import util.control.Exception._$/;"	i
utilPkg	JsMacroImpl.scala	/^    val utilPkg = Select(jsonPkg, "util")$/;"	V
uuid	BindersSpec.scala	/^  val uuid = UUID.randomUUID$/;"	V
validFrom	FakeKeyStore.scala	/^    val validFrom = new Date()$/;"	V
validTo	FakeKeyStore.scala	/^    val validTo = new Date(validFrom.getTime + 50l * 365l * 24l * 60l * 60l * 1000l)$/;"	V
validValues	Application.scala	/^    val validValues = Set("TRACE", "DEBUG", "INFO", "WARN", "ERROR", "OFF", "INHERITED")$/;"	V
validate	JsValue.scala	/^  def validate[T](implicit rds: Reads[T]): JsResult[T] = rds.reads(this)$/;"	m
validation.Constraints.{MaxLength, Required}	PartialValidationSpec.scala	/^import validation.Constraints.{MaxLength, Required}$/;"	i
validation._	Form.scala	/^import validation._$/;"	i
validation._	ObjectMappings.scala	/^import validation._$/;"	i
validation._	csrf.scala	/^  import validation._$/;"	i
validity	FakeKeyStore.scala	/^    val validity = new CertificateValidity(validFrom, validTo)$/;"	V
value	Cache.scala	/^      val value = orElse$/;"	V
value	DiscoverySpec.scala	/^      val value = params.get("openid.identity")$/;"	V
value	FormUrlEncodedParser.scala	/^        val value = URLDecoder.decode(parts.tail.headOption.getOrElse(""), encoding)$/;"	V
value	JsValue.scala	/^    val value = deserialize(jp, ctxt, List())$/;"	V
value	JsValue.scala	/^  lazy val value: Map[String, JsValue] = fields.toMap$/;"	V
value	NettyPromise.scala	/^    def value: Option[Try[Unit]] = (channelPromise.isDone, channelPromise.isSuccess) match {$/;"	m
value1	Promise.scala	/^  def value1 = await$/;"	m
values	JsValue.scala	/^  def values: Set[JsValue] = fields.map(_._2).toSet$/;"	m
variable	SqlStatementParser.scala	/^  def variable = "{" ~> (ident ~ (("." ~> ident)?)) <~ "}" ^^ {$/;"	m
verificationQuery	OpenIDSpec.scala	/^        val verificationQuery = argument.getValue$/;"	V
verifiedId	OpenID.scala	/^  def verifiedId(implicit request: Request[_]): Future[UserInfo] = verifiedId(request.queryString)$/;"	m
verifiedId	OpenID.scala	/^  def verifiedId(queryString: java.util.Map[String, Array[String]]): Future[UserInfo] = {$/;"	m
verifying	Form.scala	/^  def verifying(addConstraints: Constraint[List[T]]*): Mapping[List[T]] = {$/;"	m
verifying	Form.scala	/^  def verifying(addConstraints: Constraint[Option[T]]*): Mapping[Option[T]] = {$/;"	m
verifying	Form.scala	/^  def verifying(addConstraints: Constraint[R]*) = {$/;"	m
verifying	Form.scala	/^  def verifying(addConstraints: Constraint[T]*): Mapping[T] = {$/;"	m
verifying	Form.scala	/^  def verifying(constraint: (T => Boolean)): Mapping[T] = verifying("error.unknown", constraint)$/;"	m
verifying	Form.scala	/^  def verifying(constraints: Constraint[B]*): Mapping[B] = copy(additionalConstraints = additionalConstraints ++ constraints)$/;"	m
verifying	Form.scala	/^  def verifying(constraints: Constraint[T]*): Mapping[T]$/;"	m
verifying	Form.scala	/^  def verifying(error: => String, constraint: (T => Boolean)): Mapping[T] = {$/;"	m
verifying	JsConstraints.scala	/^  def verifying[A](cond: A => Boolean)(implicit rds: Reads[A]) =$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping10[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping11[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping12[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping13[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping14[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping15[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping16[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping17[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping18[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping2[R, A1, A2] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping3[R, A1, A2, A3] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping4[R, A1, A2, A3, A4] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping5[R, A1, A2, A3, A4, A5] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping6[R, A1, A2, A3, A4, A5, A6] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping7[R, A1, A2, A3, A4, A5, A6, A7] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping8[R, A1, A2, A3, A4, A5, A6, A7, A8] = {$/;"	m
verifying	ObjectMappings.scala	/^  def verifying(addConstraints: Constraint[R]*): ObjectMapping9[R, A1, A2, A3, A4, A5, A6, A7, A8, A9] = {$/;"	m
verifyingIf	JsConstraints.scala	/^  def verifyingIf[A](cond: A => Boolean)(subreads: Reads[_])(implicit rds: Reads[A]) = $/;"	m
version	FormSpec.scala	/^  def version() = "HTTP\/1.1"$/;"	m
version	Http.scala	/^        val version = _version$/;"	V
version	Http.scala	/^      def version = rh.version$/;"	m
version	Http.scala	/^      def version = self.version$/;"	m
version	Http.scala	/^    def version = request.version$/;"	m
version	Http.scala	/^    def version: String$/;"	m
version	JavaHelpers.scala	/^      def version = req.version$/;"	m
version	PlayDefaultUpstreamHandler.scala	/^          def version = nettyVersion.getText$/;"	m
version	PlayReloader.scala	/^          val version = classLoaderVersion.incrementAndGet$/;"	V
views.html.helper.FieldConstructor.defaultField	DynamicFormSpec.scala	/^import views.html.helper.FieldConstructor.defaultField$/;"	i
views.html.helper.inputText	DynamicFormSpec.scala	/^import views.html.helper.inputText$/;"	i
visit	ScalaTemplateCompiler.scala	/^    def visit(elem: Seq[TemplateTree], previous: Seq[Any]): Seq[Any] = {$/;"	m
wBytes	Writeable.scala	/^  implicit val wBytes: Writeable[Array[Byte]] = Writeable(identity)$/;"	V
wResult	JavaHelpers.scala	/^      val wResult = result.withHeaders(javaContext.response.getHeaders.asScala.toSeq: _*)$/;"	V
wait	Selenium.scala	/^    val wait = new FluentWait[WebDriver](webDriver).withTimeout(timeout, timeUnit)$/;"	V
waitUntil	Selenium.scala	/^  def waitUntil[T](block: => T): T = waitUntil(3000, TimeUnit.MILLISECONDS)(block)$/;"	m
waitUntil	Selenium.scala	/^  def waitUntil[T](timeout: Int, timeUnit: TimeUnit)(block: => T): T = {$/;"	m
warn	Logger.scala	/^  def warn(message: => String) {$/;"	m
warn	Logger.scala	/^  def warn(message: => String, error: => Throwable) {$/;"	m
watchChanges	PlayReloader.scala	/^      val watchChanges: Seq[Int] = monitoredDirs.map( f => jnotify.addWatch(f.getAbsolutePath) )$/;"	V
watchFiles	PlayReloader.scala	/^      lazy val watchFiles = extracted.runTask(watchTransitiveSources, state)._2$/;"	V
watchState	PlayCommands.scala	/^        val watchState = ws.getOrElse(s get ContinuousState getOrElse WatchState.empty)$/;"	V
webDriver	Specs.scala	/^        val webDriver: Class[WEBDRIVER] = Helpers.HTMLUNIT,$/;"	V
webSocketURL	Http.scala	/^    def webSocketURL(secure: Boolean = false)(implicit request: RequestHeader) = {$/;"	m
webSocketWrapper	JavaWebSocket.scala	/^  def webSocketWrapper[A](retrieveWebSocket: => play.mvc.WebSocket[A])(implicit frameFormatter: play.api.mvc.WebSocket.FrameFormatter[A]): WebSocket[A] = WebSocket[A] { request =>$/;"	m
websocketHandshake	WebSocketHandler.scala	/^  def websocketHandshake[A](ctx: ChannelHandlerContext, req: HttpRequest, e: MessageEvent)(frameFormatter: play.api.mvc.WebSocket.FrameFormatter[A]): Enumerator[A] = {$/;"	m
websocketable	WebSocketHandler.scala	/^  def websocketable(req: HttpRequest) = new server.WebSocketable {$/;"	m
websocketableRequest	PlayDefaultUpstreamHandler.scala	/^        val websocketableRequest = websocketable(nettyHttpRequest)$/;"	V
when	ContentTypes.scala	/^    def when[A](predicate: RequestHeader => Boolean, parser: BodyParser[A], badResult: RequestHeader => Result): BodyParser[A] = {$/;"	m
when	FakeRuntime.scala	/^      def when(predicate: => Boolean) = {$/;"	m
when	ScalaTemplate.scala	/^      def when(predicate: => Boolean) = {$/;"	m
white	Color.scala	/^  def white(str: String): String = if (isANSISupported) (WHITE + str + RESET) else str$/;"	m
white	Console.scala	/^  def white(str: String): String = if (isANSISupported) (WHITE + str + RESET) else str$/;"	m
whiteSpace	Messages.scala	/^    override val whiteSpace = """[ \\t]+""".r$/;"	V
whiteSpace	RoutesCompiler.scala	/^    override val whiteSpace = """[ \\t]+""".r$/;"	V
whiteSpaceNoBreak	ScalaTemplateCompiler.scala	/^      def whiteSpaceNoBreak = """[ \\t]+""".r$/;"	m
wikiPage	ApplicationProvider.scala	/^    val wikiPage = """\/@documentation\/([^\/]*)""".r$/;"	V
wikiResource	ApplicationProvider.scala	/^    val wikiResource = """\/@documentation\/resources\/(.*)""".r$/;"	V
withAuth	WS.scala	/^    def withAuth(username: String, password: String, scheme: AuthScheme): WSRequestHolder =$/;"	m
withBody	Fakes.scala	/^  def withBody[B](body: B): FakeRequest[B] = {$/;"	m
withCharset	StandardValues.scala	/^  def withCharset(mimeType: String)(implicit codec: Codec) = mimeType + "; charset=" + codec.charset$/;"	m
withConnection	DB.scala	/^  def withConnection[A](block: Connection => A)(implicit app: Application): A = {$/;"	m
withConnection	DB.scala	/^  def withConnection[A](name: String)(block: Connection => A)(implicit app: Application): A = {$/;"	m
withConnection	DB.scala	/^  def withConnection[A](name: String)(block: Connection => A): A = {$/;"	m
withContextClassLoader	Threads.scala	/^  def withContextClassLoader[T](classloader: ClassLoader)(b: => T): T = {$/;"	m
withCookies	Fakes.scala	/^  def withCookies(cookies: Cookie*): FakeRequest[A] = {$/;"	m
withCookies	Results.scala	/^  def withCookies(cookies: Cookie*): A$/;"	m
withCookies	Results.scala	/^  def withCookies(cookies: Cookie*): AsyncResult = {$/;"	m
withCookies	Results.scala	/^  def withCookies(cookies: Cookie*): PlainResult = {$/;"	m
withError	Form.scala	/^  def withError(error: FormError): Form[T] = this.copy(errors = errors :+ error, value = None)$/;"	m
withError	Form.scala	/^  def withError(key: String, message: String, args: Any*): Form[T] = withError(FormError(key, message, args))$/;"	m
withFilter	JsResult.scala	/^    def withFilter(q: A => Boolean) = new WithFilter(a => p(a) && q(a))$/;"	m
withFilter	JsResult.scala	/^  def withFilter(p: A => Boolean) = new WithFilter(p)$/;"	m
withFlash	Fakes.scala	/^  def withFlash(data: (String, String)*): FakeRequest[A] = {$/;"	m
withFollowRedirects	WS.scala	/^    def withFollowRedirects(follow: Boolean): WSRequestHolder =$/;"	m
withFormUrlEncodedBody	Fakes.scala	/^  def withFormUrlEncodedBody(data: (String, String)*): FakeRequest[AnyContentAsFormUrlEncoded] = {$/;"	m
withGlobal	Fakes.scala	/^    val withGlobal: Option[play.api.GlobalSettings] = None) extends {$/;"	V
withGlobalError	Form.scala	/^  def withGlobalError(message: String, args: Any*): Form[T] = withError(FormError("", message, args))$/;"	m
withHeaders	Fakes.scala	/^  def withHeaders(newHeaders: (String, String)*): FakeRequest[A] = {$/;"	m
withHeaders	Results.scala	/^  def withHeaders(headers: (String, String)*) = {$/;"	m
withHeaders	Results.scala	/^  def withHeaders(headers: (String, String)*): A$/;"	m
withHeaders	Results.scala	/^  def withHeaders(headers: (String, String)*): AsyncResult = {$/;"	m
withHeaders	WS.scala	/^    def withHeaders(hdrs: (String, String)*): WSRequestHolder = {$/;"	m
withJsonBody	Fakes.scala	/^  def withJsonBody(json: JsValue): FakeRequest[AnyContentAsJson] = {$/;"	m
withJsonBody	Fakes.scala	/^  def withJsonBody(node: JsValue, _method: String): FakeRequest[AnyContentAsJson] = {$/;"	m
withLang	Results.scala	/^  def withLang(lang: Lang)(implicit app: Application): A = withCookies(Cookie(Play.langCookieName, lang.code))$/;"	m
withLock	Evolutions.scala	/^  def withLock(ds: DataSource)(block: => Unit) {$/;"	m
withMessage	Form.scala	/^  def withMessage(message: String): FormError = FormError(key, message)$/;"	m
withNewSession	Results.scala	/^  def withNewSession: A$/;"	m
withNewSession	Results.scala	/^  def withNewSession: AsyncResult = {$/;"	m
withNewSession	Results.scala	/^  def withNewSession: PlainResult = withSession(Session())$/;"	m
withPrefix	Form.scala	/^  def withPrefix(prefix: String) = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	Form.scala	/^  def withPrefix(prefix: String): Mapping[B] = {$/;"	m
withPrefix	Form.scala	/^  def withPrefix(prefix: String): Mapping[List[T]] = {$/;"	m
withPrefix	Form.scala	/^  def withPrefix(prefix: String): Mapping[Option[T]] = {$/;"	m
withPrefix	Form.scala	/^  def withPrefix(prefix: String): Mapping[T] = {$/;"	m
withPrefix	Form.scala	/^  def withPrefix(prefix: String): Mapping[T]$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping10[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping11[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping12[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping13[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping14[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping15[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping16[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping17[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping18[R, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, A16, A17, A18] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping2[R, A1, A2] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping3[R, A1, A2, A3] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping4[R, A1, A2, A3, A4] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping5[R, A1, A2, A3, A4, A5] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping6[R, A1, A2, A3, A4, A5, A6] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping7[R, A1, A2, A3, A4, A5, A6, A7] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping8[R, A1, A2, A3, A4, A5, A6, A7, A8] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withPrefix	ObjectMappings.scala	/^  def withPrefix(prefix: String): ObjectMapping9[R, A1, A2, A3, A4, A5, A6, A7, A8, A9] = addPrefix(prefix).map(newKey => this.copy(key = newKey)).getOrElse(this)$/;"	m
withQueryString	WS.scala	/^    def withQueryString(parameters: (String, String)*): WSRequestHolder =$/;"	m
withQueryTimeout	Anorm.scala	/^  def withQueryTimeout(seconds: Option[Int]): BatchSql = this.copy(sql = sql.withQueryTimeout(seconds))$/;"	m
withQueryTimeout	Anorm.scala	/^  def withQueryTimeout(seconds: Option[Int]): SimpleSql[T] = this.copy(sql = sql.withQueryTimeout(seconds))$/;"	m
withQueryTimeout	Anorm.scala	/^  def withQueryTimeout(seconds: Option[Int]): SqlQuery = this.copy(queryTimeout = seconds)$/;"	m
withRawBody	Fakes.scala	/^  def withRawBody(bytes: Array[Byte]): FakeRequest[AnyContentAsRaw] = {$/;"	m
withSession	Fakes.scala	/^  def withSession(newSessions: (String, String)*): FakeRequest[A] = {$/;"	m
withSession	Results.scala	/^  def withSession(session: (String, String)*): A$/;"	m
withSession	Results.scala	/^  def withSession(session: (String, String)*): AsyncResult = {$/;"	m
withSession	Results.scala	/^  def withSession(session: (String, String)*): PlainResult = withSession(Session(session.toMap))$/;"	m
withSession	Results.scala	/^  def withSession(session: Session): A$/;"	m
withSession	Results.scala	/^  def withSession(session: Session): AsyncResult = {$/;"	m
withSession	Results.scala	/^  def withSession(session: Session): PlainResult = {$/;"	m
withTextBody	Fakes.scala	/^  def withTextBody(text: String): FakeRequest[AnyContentAsText] = {$/;"	m
withTimeout	WS.scala	/^    def withTimeout(timeout: Int): WSRequestHolder =$/;"	m
withTransaction	DB.scala	/^  def withTransaction[A](block: Connection => A)(implicit app: Application): A = {$/;"	m
withTransaction	DB.scala	/^  def withTransaction[A](name: String = "default")(block: Connection => A)(implicit app: Application): A = {$/;"	m
withTransaction	DB.scala	/^  def withTransaction[A](name: String)(block: Connection => A): A = {$/;"	m
withVirtualHost	WS.scala	/^    def withVirtualHost(vh: String): WSRequestHolder = {$/;"	m
withXmlBody	Fakes.scala	/^  def withXmlBody(xml: NodeSeq): FakeRequest[AnyContentAsXml] = {$/;"	m
withoutPlugins	Fakes.scala	/^    val withoutPlugins: Seq[String] = Nil,$/;"	V
wrappedCoffeescriptCompiler	CoffeescriptCompiler.scala	/^    val wrappedCoffeescriptCompiler = Context.javaToJS(this, scope)$/;"	V
wrappedLessCompiler	LessCompiler.scala	/^    val wrappedLessCompiler = Context.javaToJS(this, scope)$/;"	V
write	JavaWebSocket.scala	/^        def write(frame: A) {$/;"	m
write	JsPath.scala	/^  def write[T](implicit w: Writes[T]): OWrites[T] = Writes.at[T](this)(w)$/;"	m
write	JsPath.scala	/^  def write[T](t: T)(implicit w: Writes[T]): OWrites[JsValue] = Writes.pure(this, t)$/;"	m
writeBytes	JavaResults.scala	/^  def writeBytes(contentType: String): Writeable[Array[Byte]] = Writeable((bs: Array[Byte]) => bs)(contentTypeOfBytes(contentType))$/;"	m
writeBytes	JavaResults.scala	/^  def writeBytes: Writeable[Array[Byte]] = Writeable.wBytes$/;"	m
writeContent	JavaResults.scala	/^  def writeContent(mimeType: String)(implicit codec: Codec): Writeable[Content] = Writeable(content => codec.encode(content.body), Some(ContentTypes.withCharset(mimeType)))$/;"	m
writeEmptyContent	JavaResults.scala	/^  def writeEmptyContent: Writeable[Results.EmptyContent] = writeableOf_EmptyContent$/;"	m
writeFile	Files.scala	/^  def writeFile(path: File, content: String): Unit = Path(path).write(content)$/;"	m
writeFileIfChanged	Files.scala	/^  def writeFileIfChanged(path: File, content: String) {$/;"	m
writeJson	JavaResults.scala	/^  def writeJson(implicit codec: Codec): Writeable[org.codehaus.jackson.JsonNode] = Writeable(json => codec.encode(json.toString), Some(ContentTypes.JSON))$/;"	m
writeNullable	JsPath.scala	/^  def writeNullable[T](implicit w: Writes[T]): OWrites[Option[T]] = Writes.nullable[T](this)(w)$/;"	m
writeOpt	JsPath.scala	/^  def writeOpt[T](implicit w: Writes[T]): OWrites[Option[T]] = Writes.optional[T](this)(w)$/;"	m
writeString	JavaResults.scala	/^  def writeString(implicit codec: Codec): Writeable[String] = writeString(MimeTypes.TEXT)$/;"	m
writeString	JavaResults.scala	/^  def writeString(mimeType: String)(implicit codec: Codec): Writeable[String] = Writeable(s => codec.encode(s), Some(ContentTypes.withCharset(mimeType)))$/;"	m
writeable	Results.scala	/^case class ChunkedResult[A](header: ResponseHeader, chunks: Iteratee[A, Unit] => _)(implicit val writeable: Writeable[A]) extends PlainResult {$/;"	V
writeable	Results.scala	/^case class SimpleResult[A](header: ResponseHeader, body: Enumerator[A])(implicit val writeable: Writeable[A]) extends PlainResult {$/;"	V
writeableOf_EmptyContent	Writeable.scala	/^  implicit val writeableOf_EmptyContent: Writeable[Results.EmptyContent] = Writeable(_ => Array.empty)$/;"	V
writer	JUnitXmlTestListener.scala	/^                                                     val writer = new PrintWriter(stringWriter)$/;"	V
writer	JavascriptCompiler.scala	/^    val writer = new java.io.StringWriter()$/;"	V
writer	PlayDefaultUpstreamHandler.scala	/^                  val writer: Function2[ChannelBuffer, r.BODY_CONTENT, Unit] = (c, x) => c.writeBytes(r.writeable.transform(x))$/;"	V
writes	Format.scala	/^      def writes(o: A) = tjs.writes(o)$/;"	m
writes	Format.scala	/^      def writes(o: T) = tjs.writes(o)$/;"	m
writes	Format.scala	/^    def writes(a:A):JsObject = w.writes(a)    $/;"	m
writes	Format.scala	/^    def writes(a:A):JsObject = write(a)$/;"	m
writes	JsConstraints.scala	/^    def writes(a: A): JsValue = JsUndefined("pruned")$/;"	m
writes	Json.scala	/^  def writes[A] = macro JsMacroImpl.writesImpl[A]  $/;"	m
writes	Writes.scala	/^    def writes(a:A): JsObject = f(a)$/;"	m
writes	Writes.scala	/^    def writes(a:A):JsValue = f(a)$/;"	m
writes	Writes.scala	/^    def writes(as: Traversable[A]) = JsArray(as.map(toJson(_)).toSeq)$/;"	m
writes	Writes.scala	/^    def writes(d: java.sql.Date): JsValue = JsString(new java.text.SimpleDateFormat(pattern).format(d))$/;"	m
writes	Writes.scala	/^    def writes(d: java.util.Date): JsValue = JsNumber(d.getTime) $/;"	m
writes	Writes.scala	/^    def writes(d: java.util.Date): JsValue = JsString(new java.text.SimpleDateFormat(pattern).format(d))$/;"	m
writes	Writes.scala	/^    def writes(d: org.joda.time.DateTime): JsValue = JsNumber(d.getMillis) $/;"	m
writes	Writes.scala	/^    def writes(d: org.joda.time.DateTime): JsValue = JsString(d.toString(pattern))$/;"	m
writes	Writes.scala	/^    def writes(d: org.joda.time.LocalDate): JsValue = JsString(d.toString(pattern))$/;"	m
writes	Writes.scala	/^    def writes(d: org.joda.time.LocalDate): JsValue = JsString(d.toString)$/;"	m
writes	Writes.scala	/^    def writes(o: BigDecimal) = JsNumber(o)$/;"	m
writes	Writes.scala	/^    def writes(o: Boolean) = JsBoolean(o)$/;"	m
writes	Writes.scala	/^    def writes(o: Double) = JsNumber(o)$/;"	m
writes	Writes.scala	/^    def writes(o: Float) = JsNumber(o)$/;"	m
writes	Writes.scala	/^    def writes(o: Int) = JsNumber(o)$/;"	m
writes	Writes.scala	/^    def writes(o: JsValue) = o$/;"	m
writes	Writes.scala	/^    def writes(o: Long) = JsNumber(o)$/;"	m
writes	Writes.scala	/^    def writes(o: Option[T]) = o match {$/;"	m
writes	Writes.scala	/^    def writes(o: Short) = JsNumber(o)$/;"	m
writes	Writes.scala	/^    def writes(o: String) = JsString(o)$/;"	m
writes	Writes.scala	/^    def writes(ts: Array[T]) = JsArray((ts.map(t => toJson(t)(fmt))).toList)$/;"	m
writes	Writes.scala	/^  def writes(o: A): JsObject$/;"	m
writes	Writes.scala	/^  def writes(o: A): JsValue$/;"	m
writesImpl	JsMacroImpl.scala	/^  def writesImpl[A : c.WeakTypeTag](c: Context) : c.Expr[Writes[A]] = {$/;"	m
writesSelect	JsMacroImpl.scala	/^    val writesSelect = Select(jsonPkg, "Writes")$/;"	V
writesTree	JsMacroImpl.scala	/^                          val writesTree = $/;"	V
ws	DiscoverySpec.scala	/^        val ws = new WSMock$/;"	V
ws	DiscoverySpec.scala	/^    val ws = new WSMock$/;"	V
ws	OpenIDSpec.scala	/^      val ws = createMockWithValidOpDiscoveryAndVerification$/;"	V
ws	OpenIDSpec.scala	/^      val ws = new WSMock$/;"	V
ws	OpenIDSpec.scala	/^    val ws = new WSMock$/;"	V
wsCall	Helpers.scala	/^  def wsCall(call: Call)(implicit port: Port): WS.WSRequestHolder = wsUrl(call.url)$/;"	m
wsUrl	Helpers.scala	/^  def wsUrl(url: String)(implicit port: Port): WS.WSRequestHolder = WS.url("http:\/\/localhost:" + port + url)$/;"	m
x	JsonValidSpec.scala	/^      val x = for {$/;"	V
xml	ContentTypes.scala	/^    def xml(maxLength: Int): BodyParser[NodeSeq] = when($/;"	m
xml	ContentTypes.scala	/^    def xml: BodyParser[NodeSeq] = xml(DEFAULT_MAX_TEXT_LENGTH)$/;"	m
xml	JavaParsers.scala	/^  def xml(maxLength: Int): BodyParser[RequestBody] = parse.maxLength(orDefault(maxLength), parse.xml(Integer.MAX_VALUE)).map {$/;"	m
xml	WS.scala	/^  lazy val xml: Elem = XML.loadString(body)$/;"	V
xml.Node	OpenID.scala	/^import xml.Node$/;"	i
xml.NodeSeq	Fakes.scala	/^import xml.NodeSeq$/;"	i
xs	JsonSpec.scala	/^      val xs: List[Int] = (1 to 5).toList$/;"	V
xsbti.Position	PlayPositionMapper.scala	/^import xsbti.Position$/;"	i
xsbti.{Maybe, Position}	PlayLogger.scala	/^import xsbti.{Maybe, Position}$/;"	i
xx	Enumerator.scala	/^      val xx = parent |>> transformed$/;"	V
yellow	Color.scala	/^  def yellow(str: String): String = if (isANSISupported) (YELLOW + str + RESET) else str$/;"	m
yellow	Console.scala	/^  def yellow(str: String): String = if (isANSISupported) (YELLOW + str + RESET) else str$/;"	m
yoshi	JsonSpec.scala	/^      val yoshi = User(3, "Yoshi", List())$/;"	V
zip	Enumeratee.scala	/^  def zip[E, A, B](inner1: Iteratee[E, A], inner2: Iteratee[E, B]): Iteratee[E, (A, B)] = zipWith(inner1, inner2)((_, _))$/;"	m
zip	PlayCommands.scala	/^    val zip = dist \/ (packageName + ".zip")$/;"	V
zipWith	Enumeratee.scala	/^  def zipWith[E, A, B, C](inner1: Iteratee[E, A], inner2: Iteratee[E, B])(zipper: (A, B) => C): Iteratee[E, C] = {$/;"	m
